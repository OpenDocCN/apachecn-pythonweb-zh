# 管理工作流

在本章中，我们将把前面章节中描述的不同流程合并到一个通用工作流中，以便我们可以对单个微服务进行更改。我们将从获取新功能请求的过程转到本地开发、审查、在演示环境中测试、批准更改并将其发布到 live cluster。

这与我们在[第 4 章](04.html)*创建管道和工作流*中介绍的管道概念有关。然而，在本章中，我们将讨论任务的过程。管道和建筑结构的存在是为了确保任何拟议的变更符合质量标准。在本章中，我们将重点介绍该技术的团队合作方面，以及如何在跟踪不同变化的同时实现平滑交互。

在本章中，我们将介绍以下主题：

*   了解功能的生命周期
*   审查和批准新功能
*   设置多个环境
*   扩展工作流并使其工作

在本章结束时，我们将清楚地了解为我们的一个微服务设置新功能所涉及的不同步骤，以及如何使用多个环境来测试并确保发布成功。

# 了解功能的生命周期

遵循敏捷原则，任何团队的主要目标都是能够快速实现新特性，而不会影响系统的质量或稳定性。变化的第一个要素是**特性请求**的形式。

A feature request is a description of a change in the system in non-technical terms. Feature requests are normally generated by non-engineers (product owners, managers, and CEOs) who are looking to improve the system for business-related reasons, such as making a better product or increasing revenue.

Feature requests can be simple, such as *updating the logo of the company in the main page*, or big and complicated, such as *adding support to the new 5G network*. Feature requests may include bug reports. While they don't usually, they will for the purpose of this chapter.

复杂的特性请求可能需要细分为较小的自包含特性请求，以便我们可以以较小的增量进行迭代。

Our focus is on the elements that need to be taken into account due to the microservices approaches and practices more than agile practices. Such practices deal with how to structure feature requests into tasks and estimations, but they are not specific to the underlying technologies.

Take a look at the *Further reading* section at the end of this chapter to find out more about agile practices and methodologies.

在一个整体中，所有元素都在同一个代码库下。因此，无论一个特定的功能请求有多复杂，只有一个系统会受到影响。在一个整体中只有一个系统。然而，一旦我们迁移到微服务，情况就不是这样了。

在微服务体系结构中，我们需要根据微服务或微服务的影响来分析任何传入的功能请求。如果我们正确设计微服务，大多数请求将只影响单个微服务。然而，最终，一些功能请求将太大，无法整齐地放入单个微服务中，并且需要分为两个或多个步骤，每个步骤更改一个不同的微服务。

例如，如果我们有一个新的功能请求，允许我们在思想文本中提及用户（类似于在 Twitter 上提及的方式），那么这个提及必须存储在思想后端，并显示在前端。此功能影响两个微服务：前端和后端。

In this section, we are referring to concepts that we introduced in the previous chapters and are joining them together from a global point of view.

在下一小节中，我们将研究影响多个微服务的功能。

# 影响多个微服务的功能

对于多个微服务功能请求，您需要将该功能划分为多个技术功能，每个功能都影响单个微服务。

每个技术特性都应该涵盖与其影响的微服务相关的方面。如果每个微服务都有明确的目的和目标，那么将完成并推广该功能，以便可以用于以后的请求。

The basis for a successful microservice architecture is to have loosely coupled services. Ensuring that the API of each microservice makes sense on its own is important if we wish to avoid blurring the lines between services. Not doing so may mean that independent work and deployments aren't allowed.

还应考虑请求和微服务之间的依赖关系，以便将工作安排在前后。这意味着准备将添加额外数据或功能的新功能，但默认情况下保留旧行为。完成此操作后，可以部署使用此额外数据的新功能。这种工作方式确保了在任何给定时间的向后兼容性。

We will look at the features that affect multiple microservices in more detail in [Chapter 11](11.html), *Handling Change, Dependencies, and Secrets in the System*. We'll also learn how to coordinate work and dependencies in more detail.

回到上一个示例，为了向用户的想法中添加用户的提及，我们需要使 Thinks 后端能够处理对用户的可选引用。这是一个独立的任务，不会影响现有功能。它可以部署和测试。

然后，我们可以在前端进行相应的更改，以允许外部用户通过 HTML 界面与之交互。

正如我们在[第 1 章](01.html)中所讨论的，*移动——设计、规划和执行*，对于任何微服务架构来说，我们能够独立部署服务是至关重要的。这使我们能够独立地测试服务，并避免任何需要复杂部署的开销，这些部署会使我们在出现错误时难以调试和回滚。

如果不同的团队在不同的微服务上独立工作，那么他们也需要协调。

在下一节中，我们将学习如何在单个微服务中实现功能。

# 实现特性

一旦我们有了独立技术特性的定义，就可以实现它。

Defining a technical feature in a clear manner can be challenging. Remember that a single feature may need to be further subdivided into smaller tasks. However, as we mentioned previously, the objective here is not to structure our tasks.

通过创建新的 Git 分支开始您的任务。可以更改代码以反映此分支中的新功能。正如我们在[第 2 章](02.html)、*使用 Python*创建 REST 服务以及[第 3 章](03.html)、*使用 Docker*构建、运行和测试您的服务，可以运行单元测试以确保这项工作不会破坏构建。

As we described in [Chapter 3](03.html), *Build, Run, and Test Your Service Using Docker*, in the *Operating with an immutable container* section, we can use `pytest` arguments to run subsets of tests to speed up development, thereby enabling quick feedback when running tests. Make sure you use it.

可以通过部署本地集群来检查该功能相对于整个系统的工作方式。这将启动可能受此分支中的工作影响的其他微服务，但有助于确保当前工作不会中断影响其他微服务的任何现有调用。

基于管道，推送到 Git 的任何提交都将运行其所有测试。这将及早发现问题，并确保在与主分支合并之前构建是正确的。

在这个过程中，我们可以使用 pull 请求来查看主分支和新特性之间的更改。我们可以检查 GitHub 配置，以确保在合并代码之前代码处于良好状态。

一旦特性准备好并与主分支合并，就应该创建一个新标记以允许其部署。作为已配置管道的一部分，此标记将触发在注册表中生成图像并使用相同标记标记该图像的生成。标记和图像是不可变的，因此我们可以确保代码不会在不同的环境中更改。您可以放心地前后滚动，确保代码与标记中定义的代码完全相同。

正如我们在[第 8 章](08.html)中看到的，*使用 GitOps 原则*，可以按照 GitOps 原则部署标签。部署在 Git 控制下的 Kubernetes 配置文件中进行了描述，并在需要批准的 pull 请求中进行了审查。一旦 pull 请求与主分支合并，它将由 Flux 自动部署，正如我们在[第 8 章](08.html)中所述，*使用 GitOps 原理*在*设置 Flux 以控制 Kubernetes 集群*一节中所述。此时，该功能在群集中可用。

让我们回顾一下这个生命周期，从技术请求的描述到何时将其部署到集群中：

This is a more complete version of the Flow that we introduced in [Chapter 4](04.html), *Creating a Pipeline and Workflow*.

1.  该技术请求已准备好在单个微服务中实现。
2.  将创建一个新的要素分支。
3.  微服务的代码在此分支中更改，直到该功能就绪。
4.  将创建一个拉请求，用于将要素分支合并到主分支中。如[第 4 章](04.html)*创建管道和工作流*中所述，在*理解持续集成实践*一节中，运行 CI 流程以确保其具有高质量。
5.  拉动请求将被审查、批准并合并到主分支中。
6.  将创建一个新标记。
7.  在 GitOps 存储库中创建了一个部署分支，将微服务的版本更改为新标记。
8.  将创建用于合并此部署分支的请求。然后，对其进行审查和合并。
9.  一旦代码被合并，集群就会自动发布新版本的微服务。
10.  最后，新功能在集群中可用！

This is a simplified version of the life cycle; in reality, it may be more complicated. Later in this chapter, we will look at a situation where the life cycle needs to be deployed to more than one cluster.

在下一节中，我们将研究一些关于审查和批准请求的建议。

# 审查和批准新功能

正如我们在[第 4 章](04.html)*创建管道和工作流*中描述的管道模型所规定的，候选代码经过一系列阶段，如果出现问题，则停止。

正如我们前面提到的，如果我们希望在微服务的代码中引入新功能，以及如果我们希望通过 GitOps 实践将这些更改部署到集群中，那么使用 GitHub pull 请求进行审查是可行的。

在这两种情况下，我们都可以通过自动化测试和流程自动检查这一点。然而，还有最后一步需要人工干预：知识转移和一双额外的眼睛。一旦审查者认为新功能已经准备好，他们就可以批准它。

这些工具是相同的，尽管审查过程的工作方式略有不同。这是因为目标不同。对于功能代码，在获得批准并合并到主分支之前，审查更容易讨论。另一方面，审查和批准发布通常更直接、更快。

让我们从学习如何查看功能代码开始。

# 查看功能部件代码

可以在开发功能并打开合并请求时启动代码审阅。正如我们已经看到的，在 GitHub 中，代码可以在**pull 请求**阶段进行审查。

代码评审基本上是关于代码和新特性的定型讨论；也就是说，我们正在检查代码，然后再将其引入主分支。这为我们提供了在开发过程中以及在它成为系统组件之前改进该特性的机会。

在这里，团队成员可以阅读尚未合并的代码，并向作者提供一些反馈。这可以反复进行，直到审阅者认为代码已经准备好合并并批准它为止。本质上，除了该特性的作者之外，其他人需要同意新代码符合要求的标准。

Code bases grow over time and their components can help each other out. Merging code into the main branch states that you fully accept that the new code will be maintained by the team as part of the code base.

代码可能需要一个或多个人员或特定人员的批准。

In GitHub, you can enable code owners. These are engineers who are responsible for approving repositories, or parts of repositories. Check out the GitHub documentation for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).

如今，代码审查是一个非常常见的过程，在 GitHub 中使用 pull 请求的流行性和易用性已经得到了传播。大多数开发人员都熟悉这个过程。

不过，实施良好的反馈文化比看上去要困难得多。编写代码是一种深刻的个人体验；没有两个人会写相同的代码。对于开发人员来说，除非有明确的规则，否则让别人批评您的代码可能是一种困难的经历。

以下是一些建议：

*   告诉你的评论者他们应该寻找什么。注意遵循检查表。这有助于在团队中培养一种文化，使他们关注共同的核心价值观。这也有助于初级开发人员了解要寻找什么。这可能因团队而异，但以下是一些示例：
    *   有新的测试。
    *   测试错误条件。
    *   文件已适当更新。
    *   任何新端点都符合标准。
    *   更新架构图。
*   检查代码与编写代码不是一回事。始终存在差异（例如，可以更改此变量名），但需要检查的是是否需要执行此类更改。吹毛求疵会削弱团队成员之间的信任。

*   要检查的代码越大，执行起来就越困难。最好是以小的增量工作，这符合持续集成的原则。
*   所有准则都应在平等的基础上进行审查。这包括高级开发人员的代码，应该鼓励初级开发人员留下诚实的反馈。这有助于提高代码的所有权及其公平性。
*   代码评审是一种对话。评论并不一定意味着评审员的反馈必须在你不提问的情况下实施。它打开了一个关于改进代码的对话，澄清和推回是完全好的。有时，处理请求的正确方法，即更改代码的一部分，是留下注释，解释为什么以特定方式执行此操作。
*   审查有助于传播有关代码库的知识。不过，这不是一颗灵丹妙药。代码审查倾向于陷入隧道式的视野，只关注诸如打字错误和本地代码片段之类的小问题，而不关注更大的元素。这就是为什么以小增量实现特性很重要的原因：帮助周围的人消化变化。
*   留下感激的评论很重要。创建一种欣赏优秀代码的文化。只强调不好的地方会让作者的评论过程痛苦不堪。
*   批评应该针对代码，而不是编码者。确保你的审查是文明的。在这一步中，我们希望确保代码具有高质量；作为评论者，你不想让自己看起来高人一等。

Code reviews can be stressful for those who aren't used to them. Some companies are creating principles and ideas to make this process less painful. A good example can be found at [https://www.recurse.com/social-rules](https://www.recurse.com/social-rules). Don't be afraid to define and share your own principles.

*   即使团队中有人在休假或生病时，代码也要始终得到批准，这一点很重要。确保您向团队的多个成员授予批准，以便批准流程本身不会成为瓶颈。

当您开始编写代码评审时，请确保团队领导牢记这些注意事项，并强调评审所有代码的原因。

It is worth emphasizing how code reviews are not a technological solution, but a people-related one. As such, they can suffer from people-related problems such as big egos, adversarial discussions, or non-productive debates.

The microservice architecture is fit for big systems that have multiple people working on them. Teamwork is crucial. Part of that is ensuring that the code doesn't belong to a single person, but to a whole team. Code reviews are a great tool to that end, but be sure to actively look for healthy ones.

Over time, a consensus will develop and a lot of code will be developed consistently. In a healthy team, the amount of time that's spent on reviews should reduce.

随着时间的推移，团队将定期执行代码审查，但在开始时设置这些基础可能会很复杂。确保你有时间介绍他们。正如我们前面提到的，一旦特性准备好，我们需要继续并批准它。批准新特性的代码并将其合并到主分支是特性审查的最后阶段，但仍需要发布。发行版受代码控制，也需要审查。

# 批准发布

使用 GitOps 原则允许我们启用相同的审查和批准方法，以便我们可以对 Kubernetes 基础架构进行更改。正如我们前面提到的，基础设施是由 Kubernetes 中的 YAML 文件定义的，这一事实允许我们控制这些更改。

对 Kubernetes 集群所做的任何更改都可以通过 pull 请求和审阅方法进行。这使得批准集群的发布成为一个简单的过程。

这有助于将问题最小化，因为团队中有更多的成员参与到变更中，并且他们对基础架构的了解更好。这与允许团队控制自己的部署和基础设施的 DevOps 原则很好地配合。

然而，GitOps 中的基础结构更改往往比常规代码检查更容易检查。一般来说，它们是以非常小的增量进行的，而且大多数更改都非常简单，因此引发辩论的可能性很小。

一般来说，尽量减少对基础设施的任何更改。基础架构更改的风险更大，因为错误可能会导致 it 的重要部分停机。变化越小，风险越小，诊断任何问题就越容易。

我们提出的关于代码审查的所有建议也都有作用。最重要的一点是包括一些参考基础设施关键部分的指南。

Some sections of the infrastructure may be under the GitHub code owner's protection. This makes it mandatory for certain engineers to approve changes to critical parts of the infrastructure. Take a look at the documentation for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).

由于基础设施被定义为存储在 GitHub 中的代码，因此复制基础设施也很容易，从而大大简化了多个环境的生成。

# 设置多个环境

Kubernetes 下创建、复制和删除名称空间的方便性大大减轻了以前为复制基础架构而保留多个环境副本的负担。你可以利用这个优势。

基于前面提到的 GitOps 原则，我们可以定义新的名称空间来生成新的集群。我们可以使用另一个分支（例如，生产集群使用`master`分支，演示集群使用`demo`分支），或者复制包含集群定义的文件并更改名称空间。

You can use different physical Kubernetes clusters for different purposes. It's better to leave the production cluster as not being shared with any other environment to reduce risks. However, every other environment could live in the same cluster, which won't affect external customers.

一些特性请求足以证明开发团队确切地知道该做什么，比如 bug 报告。然而，其他人在开发过程中可能需要更多的测试和沟通，以确保他们满足需求。当我们检查一个新特性是否对预期的外部用户有用，或者是一个更具探索性的特性时，可能会出现这种情况。在这种情况下，我们需要调用外部方，即功能的最终批准人：*涉众*。

A stakeholder is a term from project management that specifies a third party, that is, the final user of a product or a user who's impacted by it. Here, we use the term to specify someone who's interested in a feature but external to the team, so they can't define the feature requirements from within. A stakeholder can be, for example, a manager, a customer, the CEO of the company, or a user of an internal tool.

任何必须处理涉众模糊定义请求的开发人员，例如*允许按名称*搜索，都必须调整它：*不，不是按名字，而是按姓氏*。

Ensure that you define a proper end to these kinds of tasks. Stakeholder feedback can be endless if it's allowed to run without limits. Define what is and is not included in it, as well as any deadlines, beforehand.

为了运行测试并确保正在开发的功能朝着正确的方向发展，您可以创建一个或多个演示环境，在将正在进行的工作合并到主分支之前，您将在其中进行部署。这将帮助我们与利益相关者分享这项工作，以便他们能够在功能完成之前向我们提供反馈，而无需我们在生产环境中发布。

正如我们在前几章中所看到的，在 Kubernetes 中生成一个新环境很容易。我们需要创建一个新的名称空间，然后复制集群的生产定义，从而更改名称空间。这将创建环境的副本。

更改正在开发的微服务的特定版本将允许我们创建它的工作版本。新版本可以像往常一样部署在此演示环境中。

This is a simplified version. You may need to make changes between the production environment and demo environments, such as the number of replicas, and database setup. In such cases, a *template environment* could be used as a reference so that it's ready to be copied.

其他环境（如登台）也可以以类似的方式创建，目的是创建测试，以确保部署到生产环境中的代码能够按预期工作。这些测试可以是自动的，但如果我们想检查用户体验是否足够，它们也可以是手动的。

A staging environment is a setup that works as a replica that's as faithful as possible to the production environment, which means we can run tests to provide assurance that the deployment in production will work. Staging normally helps us verify that the deployment process will be correct, as well as any final tests.

Staging environments are typically very expensive to run. After all, they are a copy of a production environment. With Kubernetes, you can replicate the production environment easily and reduce the required physical infrastructure. You can even start and stop it when it is not in use to reduce costs.

您可以使用多个环境以类似的方式创建级联部署结构。这意味着标签需要部署到暂存环境中，并在进入生产环境之前获得批准。

现在让我们从开发人员的角度来看如何处理这种结构。

# 扩展工作流并使其工作

实现这种工作方式的一些挑战包括创建一种提供充分反馈循环的文化，以及在快速查看新代码的同时仔细检查新代码。等待审查是一种阻止状态，阻止开发人员实现正在审查的功能。

虽然这段等待时间可以用于其他目的，但无法继续进行将很快降低生产率。要么开发人员将并行保留一些功能，这从上下文切换的角度来看是非常有问题的，要么他们需要等待并滚动他们的拇指，直到审查完成。

The context switch is probably the most serious killer of productivity. One of the keys to keeping your team's productivity high is being able to start and finish a task. If the task is small enough, it will be finished quickly, so swapping between projects is easier. However, working on two or more tasks at the same time is a very bad practice.

If this happens often, try to divide your tasks into smaller chunks.

为了能够在彻底检查代码和减少阻塞时间之间取得平衡，需要记住一些元素。

# 审核和批准由整个团队完成

任何时候都需要有足够的审查人员。如果只有开发人员有经验，那么评审可能最终只能由团队中最资深的一个人完成，例如团队领导。虽然这个人原则上可能是更好的评审员，但从长远来看，这种结构将危及团队，因为评审员将无法做任何其他事情。如果评审员因任何原因（如生病或休假）不在，开发和发布阶段的进展也将被阻止。

相反，让整个团队都能够审查他们同行的代码。尽管高级贡献者在教团队其他成员如何进行评审时扮演了更积极的角色，但一段时间后，大多数评审都不需要他们的帮助。

最初，虽然实施这一过程需要积极的指导，但通常由团队的高级成员领导。审查代码是一种可培训的能力，目标是在一段时间后，每个人都能够运行审查并允许批准请求。

部署拉取请求遵循相同的过程。最终，团队中的每个人，或者至少相当数量的成员，都应该能够部署一个版本。不过，最初的主要评论者可能是另一个人。

审查发行版的最佳人选可能是 Kubernetes 基础设施配置方面的专家，而不是微服务代码方面的专家。

# 理解并非每个批准都是相同的

请记住，功能的不同阶段并不同等重要。代码评审的早期过程是关于确保代码可读性和保持质量标准。在早期阶段，代码会有相对较多的注释，并且会有更多的内容需要讨论，因为需要调整更多的元素。

A big part of reviews is creating code that is *understandable enough* that other members of the team understand it. Although some people claim that code reviews make everyone aware of the changes that other members of the team are implementing, in my experience, reviewers are not that aware of specific features.

A good review, however, will ensure that nothing cryptic is being introduced into the code base and that the core elements are respected (elements such as introducing tests, keeping documentation up to date, and keeping code readable). As we suggested previously in this chapter, try to create an explicit list of things to check. It will help you make the reviews and code more consistent.

新功能的部署阶段只需要检查微服务的版本是否更改，以及基础设施的其余部分是否完好无损。这些通常非常小；他们中的大多数人都会反复检查是否有打字错误，以及要更改的微服务是否正确。

# 定义发布的清晰路径

拥有一个简单而清晰的流程可以帮助所有相关人员清楚地了解功能从开发到发布到生产环境的过程。例如，根据我们讨论的想法，我们最终可能会得到一个类似于下图所示的部署路径：

![](assets/22480f67-8ebb-41fe-8395-f832aa7b5909.png)

对于这些步骤中的每一步，我们都需要验证该步骤是否正确。正如我们在[第 4 章](04.html)*创建管道和工作流*中看到的，自动测试确保任何合并到主分支中的内容都不会破坏现有的构建。这涵盖了前面的图表，直到**创建标签**步骤。

同样，也可以有一种方法来验证部署在应用之后是否成功。以下是一些与此相关的想法：

*   手动测试，以检查部署的微服务是否按预期工作
*   自动测试，如[第 4 章](04.html)、*创建管道和工作流*中所述
*   检查要部署的映像是否已使用 Kubernetes 工具或版本 API 正确部署

成功完成一个部署阶段后，即可开始下一个部署阶段。

在非生产环境中执行部署可将中断生产的风险降至最低，因为这将确保部署过程是正确的。该过程需要足够快，以允许快速部署，从而使它们尽可能小。

The full process from merging into the main branch until the new version is released into the production environment should take less than a few hours, but ideally less than that.

If more time is required, the process is probably too heavy.

小规模、频繁的部署将使破坏生产环境的风险降至最低。在某些特殊情况下，常规程序可能会很慢，应使用紧急程序。

# 紧急释放

让我们想象一下，生产中存在一个关键的 bug，需要尽快解决它。对于这些例外情况，可以事先定义应急流程。

这一紧急过程可能涉及加快审查，甚至完全跳过审查。这可能包括跳过中间版本（例如，事先不部署到演示环境）。确保明确定义何时需要此过程，并确保仅在紧急情况下使用此过程。

If your regular deployment process is fast enough, then there's no need for an emergency process. This is an excellent reason to try to increase deployment times.

回滚就是这种情况的一个很好的例子。要恢复在上一版本中引入了关键错误的微服务的部署，只在生产中回滚并返回到上一版本，而不影响任何其他内容，这是一个合理的过程。

请注意，在这里，我们如何降低快速更改的风险，同时确保已回滚的版本以前已经部署过。这是一个很好的例子，说明了应急程序如何发挥作用并降低风险。

在发现异常情况时使用您的常识，并事先与您的团队讨论如何处理这些情况。我们将在[第 12 章](12.html)中讨论回顾，*跨团队协作和沟通。*

# 频繁释放和添加功能标志

正如我们刚才看到的，虽然回滚是可能的，但普遍的共识应该是每个新部署都会向前推进。新版本的代码包含上一版本的代码，以及一些小的更改。按照 Git 的操作方式，我们处理向前推进的单个分支（主分支）。

这意味着必须避免几个活动的长寿命分支。这种模式被称为基于主干的*开发*，是实现持续集成的推荐工作方式。在基于主干的开发中，特征分支是短暂的，并且总是与主分支（或主干）合并，在 Git 中通常称为`master`。

Trunk-based development avoids issues when we have long-lived branches that diverge from the main one, thus making the integration of several components complicated. The basis for continuous integration is to be able to always have code that can be released in small increments. This model takes "trunk" as the reference for the releases.

在下图中，我们可以看到**特性 A**如何合并到**主**分支，以及**特性 B**如何仍在进行中。任何释放都将来自**主**分支：

![](assets/2dab7dbb-586a-4dea-a959-14ba5beea981.png)

如果**特性 A**引入了一个 bug，那么一个新的 bug 修复分支将从**主控**分支并合并回来。请注意结构是如何继续前进的。

为了让这个系统工作，功能分支需要是短期的——通常只有几天。这使得合并变得容易，并允许进行小的增量更改，这是持续集成的关键。

# 使用功能标志

有时，有些功能在设计上需要一次性进行重大/剧烈的更改，例如新的 UI 界面。持续集成所提倡的那种缓慢添加小功能的短而快的迭代周期在这些频繁发布的情况下不起作用。新的界面需要一次性包含所有元素，否则看起来会很奇怪。

当您希望以一种小的增量方式继续工作时，您可以使用功能标志，同时延迟功能的激活，直到它准备就绪。

功能标志是启用或禁用特定功能的配置元素。这允许您通过配置更改来更改微服务的行为，配置更改充当开关。

In Kubernetes, we use the `deployment.yaml` file to describe the environment variables, as well as ConfigMaps. We will discuss ConfigMaps in [Chapter 11](11.html), *Handling Change, Dependencies, and Secrets in the System*.

配置绑定到每个单独的环境。这使得我们能够在特定环境中而不是在另一个环境中呈现一个特性，同时代码库保持不变。

例如，一个新的接口可以在功能标志下缓慢开发和保护。某些环境（如演示环境）仍然可以处于活动状态，以便收集内部反馈，但这不会显示在生产环境中。

一旦新的界面准备好，就可以进行小的更改；例如，我们可以更改配置参数以启用它。这在外部看起来可能是一个很大的变化，但如果我们换回参数，它很容易恢复。

Feature flags are useful when we're dealing with externally accessible services. Internal services can add more features without any issue since they'll only be called by other microservices in the system.

Internal microservices are normally okay with adding new features. Here, backward compatibility is respected. Externally accessible features sometimes require us to replace a feature with another for reasons including interface changes or the deprecation of products.

一种相关的方法是将功能滚动到用户子集。这可以是一组预定义的用户，例如已注册 beta 测试计划以提前获得功能访问权的用户，或随机抽样的用户，以便他们能够在全球发布之前提前发现问题。

Some big companies use regional access as well, where some features are enabled in certain countries first.

一旦特性标志被激活，任何不推荐使用的特性都可以被删除和清理，因此不会有不使用的旧代码。

# 处理数据库迁移

数据库迁移是对存储在特定环境（通常是一个或多个数据库）中的持久数据所做的更改。大多数情况下，这意味着更改数据库模式，但也有其他方法。

The data in a production environment is the most important asset in a running system. Extra care is advised for database migrations.

In certain cases, a migration may lock a table for a certain period of time, thereby rendering the system unusable. Ensure that you test your migrations properly in order to avoid or at least prepare for these cases.

虽然数据库迁移在技术上可能是可逆的，但就开发时间而言，这样做是非常昂贵的。例如，添加和删除列可能很简单，但一旦该列运行，该列将包含不应删除的数据。

为了能够在发生数据迁移时无缝地工作，您需要将其与要调用它的代码分离，并遵循以下步骤：

1.  以不干扰当前代码的方式设计数据库迁移。例如，向数据库添加表或列是安全的，因为旧代码将忽略它。
2.  执行数据库迁移。这会在现有代码保持不间断运行的同时进行所需的更改。
3.  现在，可以部署代码了。一旦部署完毕，它将开始使用新数据库定义的优点。如果出现问题，代码可以回滚到以前的版本。

这意味着我们需要创建两个部署：

*   一个是移民
*   使用此迁移的代码的另一个示例

Migration deployment may be similar to code deployment. Maybe there's a microservice running the migrations, or maybe it's a script doing all the work. Most frameworks will have a way of making migrations to ensure that a migration isn't applied twice.

For example, for SQLAlchemy, there's a tool called Alembic ([https://alembic.sqlalchemy.org/en/latest/](https://alembic.sqlalchemy.org/en/latest/)) that we can use to generate and run migrations.

但是，还有另一种操作：尝试将迁移应用到将使用它们的微服务。在处理生产环境时，这是一个坏主意，因为无论迁移是否发生，这都会在所有情况下减慢启动时间。此外，它不会检查代码是否可以安全回滚并与数据库的早期版本一起工作。

与自由更改数据库相比，使用两个独立的部署显然有点限制，但它确保了每一步都是可靠的，并且服务是不间断的。这是深思熟虑的。例如，要重命名列，我们将执行以下步骤：

1.  首先，我们将部署一个迁移，用新列名创建一个新列，从而从旧列复制数据。代码从旧列读取和写入。
2.  然后，我们将部署新代码，从旧列读取数据，并将其写入这两个列。在发布过程中，将正确读取从旧代码到旧列的任何写入。
3.  之后，我们将创建另一个迁移，将数据从旧迁移复制到新迁移。这可确保正确应用任何瞬态副本。此时，任何新数据仍会同时进入两列。
4.  然后，我们将部署读写新列的代码，而忽略旧列。
5.  最后，我们将实现一个迁移来删除旧列。此时，旧列不包含相关数据，可以安全地删除。它不会影响代码。

这是一个经过深思熟虑的长流程示例，但在大多数情况下，不需要这样长的流程。然而，在任何一个步骤中都没有任何不一致之处。如果其中一个阶段出现问题，我们可以返回到前一个阶段–在修复到位之前，它仍然可以工作。

主要目标是避免出现数据库无法使用当前部署的代码的瞬态状态。

# 总结

在本章中，我们讨论了团队的流程，从启动新功能到将其部署到生产环境。

我们首先讨论了在微服务体系结构中工作时功能请求的关键点。我们介绍了影响多个微服务的请求，并学习了如何组织工作，使服务不会中断。

我们讨论了构成良好审查和批准流程的要素，以及 GitHub pull 请求如何帮助我们实现这一点。使用 GitOps 实践来控制基础架构，可以使部署的审查变得简单。

然后，我们讨论了与 Kubernetes 和 GitOps 合作如何帮助我们创建多个环境，以及在处理演示和登台环境时如何利用它们来测试部署，并在受控环境中的功能投入生产之前展示它们。

在这之后，我们讨论了如何使团队对整个生命周期有一个全局视图，从特性请求到部署，并能够快速地遵循完整的路径。我们学习了如何阐明这些步骤，以及如何让团队负责审查和批准自己的代码，从而允许开发人员完全掌握开发周期。

我们还讨论了在处理数据库迁移时可能出现的问题，并解释了如何进行这种不容易回滚的特殊部署。

在下一章中，我们将讨论实时系统以及如何启用度量和日志等元素，以便我们能够检测生产环境中出现的问题和 bug，并获得足够的信息以尽可能快速、主动地对其进行补救。

# 问题

1.  当接收到一个新的业务特性时，我们需要在一个在微服务架构下工作的系统中执行什么分析？
2.  如果一个功能需要更改两个或多个微服务，我们如何决定首先更改哪一个？
3.  Kubernetes 如何帮助我们建立多个环境？
4.  代码评审是如何工作的？
5.  代码审查的主要瓶颈是什么？
6.  在 GitOps 原则下，部署评审与代码评审是否不同？
7.  为什么一旦特性准备好合并到主分支中，就必须有一条清晰的部署路径？
8.  为什么数据库迁移不同于常规代码部署？

# 进一步阅读

要了解有关敏捷实践的更多信息并将其介绍给团队，请阅读以下书籍：

*   *敏捷开发者手册*（[https://www.packtpub.com/eu/web-development/agile-developers-handbook](https://www.packtpub.com/eu/web-development/agile-developers-handbook)
*   *敏捷技术实践提炼*[https://www.packtpub.com/eu/business-other/agile-technical-practices-distilled](https://www.packtpub.com/eu/business-other/agile-technical-practices-distilled)

如果您在组织中使用 JIRA，请阅读*使用 JIRA*（[进行敏捷软件开发的实践 https://www.packtpub.com/eu/application-development/hands-agile-software-development-jira](https://www.packtpub.com/eu/application-development/hands-agile-software-development-jira) ）可以帮助您在使用敏捷实践时更好地使用该工具。