# 评估

# 第一章

1.  **什么是巨石？**

monolith 是在单个块中创建的软件应用程序。此应用程序作为单个进程运行。尽管可以创建多个相同的副本，但它只能同时部署。

2.  **巨石会遇到什么问题？**

随着它们的成长，巨石可能会遇到以下问题：

*   代码变得太大，难以阅读。
*   可伸缩性问题。
*   需要协调部署。
*   资源使用不当。
*   在不同的情况下（例如，同一个库的不同版本或两种编程语言），不可能使用相互冲突的技术。
*   单个 bug 和部署可能会影响整个系统。

3.  **您能描述一下微服务架构吗？**

微服务体系结构是松散耦合的专门服务的集合，这些服务协同工作以提供全面的服务。

4.  **微服务最重要的属性是什么？**

微服务最重要的特性是它们可以独立部署，从而可以独立开发。

5.  **从整体式服务迁移到微服务时，我们需要克服的主要挑战是什么？**

可能的挑战包括：

6.  **我们怎样才能进行这样的迁移？**

我们需要对系统进行分析、测量、制定相应的计划，并执行计划。

7.  **描述如何使用负载平衡器在不中断系统的情况下从旧服务器迁移到新服务器。**

首先，我们必须配置负载平衡器，使其指向旧的 web 服务器，这将使流量通过 web 服务器。然后，我们必须更改 DNS 记录，使其指向负载平衡器。在流量通过负载平衡器之后，我们需要为新服务创建一个新条目，以便负载平衡器在两者之间分割流量。确认一切正常后，我们需要从旧服务中删除该条目。现在，所有流量都将路由到新服务。

# 第二章

1.  **RESTful 应用程序的特点是什么？**

RESTful 应用程序被理解为一个 web 接口，它将 URI 转换为对象表示，并通过 HTTP 方法对其进行操作（通常使用 JSON 格式化请求），REST 体系结构的教科书特征如下：

*   均匀界面
*   客户端服务器
*   无国籍
*   可缓存
*   分层系统
*   按需编码（可选）

有关 REST 体系结构的更多信息，请访问[https://restfulapi.net/](https://restfulapi.net/) 。

2.  **使用 Flask RESTPlus 有什么好处？**

使用 Flask RESTPlus 的一些优点如下：

*   自动招摇过市生成。
*   一个可以定义和解析输入以及封送输出的框架。
*   它允许我们在名称空间中构造代码。

3.  **有哪些替代方案？**

其他替代方案包括 Flask RESTful（这类似于 Flask RESTPlus，但不支持招摇过市）和 Django REST 框架，该框架拥有丰富的生态系统，其中充满了第三方扩展。

4.  命名测试中用于确定时间的 Python 包。

`freezegun`。

5.  **描述认证流程。**

身份验证系统（用户后端）生成编码令牌。此令牌使用只有用户后端拥有的私钥进行编码。该令牌用 JWT 编码，包含用户 ID 以及其他参数，例如，这些参数告诉我们令牌的有效期。此令牌包含在`Authentication`头中。

令牌从报头获取，并使用存储在后端的相应公钥进行解码。这允许我们独立地获取用户 ID，并确保它已由用户后端验证。

6.  **我们为什么选择 SQLAlchemy 作为数据库接口？**

SQLAlchemy 在 Flask 中得到了很好的支持，允许我们定义已有的数据库。它是高度可配置的，允许我们在较低的级别（即接近底层 SQL）上工作，并在更高的级别上工作，这样就不需要任何样板代码。在我们的用例中，我们从遗留系统继承了一个数据库，因此需要与现有模式无缝地工作。

# 第三章

1.  **FROM 关键字在 Dockerfile 中起什么作用？**

它从现有的图像开始，向其中添加更多层。

2.  **如何使用预定义的命令启动容器？**

您将运行以下命令：

```py
docker run image
```

3.  **为什么创建从 Dockerfile 中删除文件的步骤不会创建更小的图像？**

由于 Docker 使用的文件系统的分层结构，Docker 文件中的每个步骤都会创建一个新层。文件系统是所有操作协同工作的结果。最终图像包括所有现有层；添加一层永远不会减小图像的大小。用于删除的新步骤将不会出现在最终图像中，但它将始终作为前一层的一部分提供。

4.  **多级 Dockerfile 如何工作？**

多级 Dockerfile 包含多个阶段，每个阶段都以一个`FROM`命令开始，该命令指定作为起点的图像。数据可以在一个阶段生成，然后复制到另一个阶段。

如果我们希望减小最终图像的大小，多阶段构建是有用的；只有生成的数据才会复制到最终阶段。

5.  **run 和 exec 命令之间有什么区别？**

`run`命令从一个映像启动一个新容器，`exec`命令连接到一个已经存在的正在运行的容器。请注意，如果容器在执行时停止，会话将关闭。

Stopping a container can occur in an `exec` session. The main process that is keeping the container running is the `run` command. If you kill the command or stop it in any other way, the container will stop and the session will be closed.

6.  **我们什么时候应该使用-it 标志？**

例如，当您需要保持终端打开时，以交互方式运行`bash`命令。还记得记忆功能*交互终端*吗。

7.  **使用 uWSGI 为 web Python 应用程序提供服务的替代方案有哪些？**

任何支持 WSGI web 协议的 web 服务器都可以用作替代方案。最流行的替代方案是 Gunicorn，其目的是易于使用和配置，`mod_wsgi`（支持 WSGI Python 模块的流行 Apache web 服务器的扩展）和 CherryPy，后者包括其自己的 web 框架。

8.  **docker compose 的用途是什么？**

`docker-compose`允许轻松编排，也就是说，我们可以协调多个相互连接的 Docker 容器，以便它们协同工作。它还帮助我们配置 Docker 命令，因为我们可以使用`docker-compose.yaml`文件存储所有受影响容器的配置参数。

9.  **你能描述一下码头工人标签是什么吗？**

Docker 标记是一种标记图像的方法，同时保留其根名称。它通常标记同一应用程序或软件的不同版本。默认情况下，`latest`标记将应用于图像构建。

10.  **为什么我们需要将图像推送到远程注册表？**

我们将图像推送到远程注册表，以便我们可以与其他系统和其他开发人员共享图像。Docker 在本地构建图像，除非它们需要推送到另一个存储库，以便其他 Docker 服务可以使用它们。

# 第四章

1.  **增加部署数量是否会降低部署质量？**

不研究表明，部署数量的增加与部署质量的提高密切相关。能够快速部署的系统必须依靠强大的自动化测试，这将提高系统的稳定性和整体质量。

2.  **什么是管道？**

管道是用于执行构建的一系列有序步骤或阶段。如果其中一个步骤失败，构建将停止。步骤的顺序应旨在最大限度地早期发现问题。

3.  **我们如何知道我们的主要分支机构是否可以部署？**

如果我们自动运行管道在每次提交时生成一个构建，那么我们应该在提交后立即检测主分支上的问题。构建应该向我们保证可以部署主分支的顶部提交。应尽快修复主分支中的断裂。

4.  **Travis CI 的主要配置来源是什么？**

`.travis.yml`文件，可在存储库的根目录中找到。

5.  **默认情况下，Travis CI 何时发送通知电子邮件？**

Travis CI 在构建中断时以及以前中断的分支成功通过时发送通知电子邮件。成功生成发生在上一次提交成功但未报告时。

6.  **我们如何避免将一个断裂的分支合并到我们的主分支中？**

我们可以通过在 GitHub 中配置来避免这种情况，这可以确保分支在合并到受保护的分支之前通过构建。为了确保特性分支没有偏离主分支，我们需要强制它与构建合并。要实现这一点，它需要与主要分支机构保持同步。

7.  **我们为什么要避免在 Git 存储库中存储机密？**

由于 Git 的工作方式，任何引入的秘密都可以通过查看提交历史来检索，即使它已被删除。由于提交历史记录可以在任何克隆的存储库中复制，因此我们无法验证它是否正确—我们无法将提交历史记录重写到克隆的存储库中。除非正确加密，否则机密不应存储在 Git 存储库中。任何错误存储的秘密都应该被删除。

# 第五章

1.  **什么是容器编排器？**

容器编排器是一个系统，我们可以在其中部署多个协同工作的容器，并以有序的方式管理资源调配和部署。

2.  **在库伯内特斯，什么是节点？**

节点是属于群集的物理服务器或虚拟机。节点可以从集群中添加或删除，Kubernetes 将相应地迁移或重新启动正在运行的容器。

3.  **豆荚和容器有什么区别？**

一个 pod 可以包含多个共享同一 IP 的容器。要在 Kubernetes 中部署容器，我们需要将其与 pod 关联。

4.  **工作和豆荚有什么区别？**

预计吊舱将持续运行。作业或 cron 作业执行单个操作，然后所有 pod 容器完成其执行。

5.  **什么时候应该添加入口？**

当我们需要能够从集群外部访问服务时，我们应该添加入口。

6.  **什么是名称空间？**

命名空间是虚拟集群。集群中的所有定义都需要具有唯一的名称。

7.  **如何在文件中定义 Kubernetes 元素？**

我们需要以 YAML 格式指定它，并提供有关其 API 版本、元素类型、带有名称和命名空间的元数据部分以及`spec`部分中元素定义的信息。

8.  **kubectl get 和 descripe 命令之间有什么区别？**

`kubectl get`获取多个元素，如服务或吊舱，并显示其基本信息。另一方面，`describe`访问单个元素并提供更多关于它的信息。

9.  **CrashLoopBackOff 错误表示什么？**

此错误表示容器已完成执行定义的启动命令。这个错误只发生在 POD 上，因为它们永远不会停止执行。

# 第六章

1.  **我们正在部署的三种微服务是什么？**

以下是我们正在部署的三种微服务：

*   用户后端，用于控制身份验证和处理用户的方式。
*   思想后端，它存储思想并允许我们创建和搜索它们。
*   前端，它为我们提供了一个用户界面，以便我们可以与系统交互。它通过 RESTful 调用调用其他两个微服务。

2.  **三个微服务中的哪一个要求另外两个微服务可用？**

前端调用另外两个微服务，因此前端需要能够使用它们。

3.  **当微服务在 docker compose 中运行时，为什么我们需要使用外部 IP 连接到它们？**

`docker-compose`为每个微服务创建一个内部网络，因此它们需要使用外部 IP 进行通信，以便正确路由。当我们暴露主机中的端口时，可以使用外部主机 IP。

4.  **每个应用程序所需的主要 Kubernetes 对象是什么？**

对于每个微服务，我们提供一个部署（自动生成一个 pod）、一个服务和一个入口。

5.  **是否有不需要的对象？**

用户后端和 Thinks 后端的入口不是严格要求的，因为它们可以通过节点端口访问，但它确实使访问它们变得更容易。

6.  **如果我们扩展到多个吊舱或任何其他微服务，我们是否可以检测到问题？**

用户后端和 Thinks 后端创建一个包含两个容器的 pod，其中包括数据库。如果我们创建多个 pod，我们将创建多个数据库，在它们之间交替会导致问题。

例如，如果我们在一个 pod 中创建了一个新思想，那么如果请求是在另一个 pod 中提出的，我们将无法搜索它。

另一方面，前端可以毫无问题地扩展。

7.  **我们为什么要使用/etc/hosts 文件？**

我们使用这个文件是为了定义一个路由到本地 Kubernetes 集群的`host`。这避免了我们必须定义 FQDN 和配置 DNS 服务器。

# 第七章

1.  **为什么我们不应该管理我们自己的 Kubernetes 集群？**

由于 Kubernetes 是一个抽象层，因此让云提供商负责维护和管理以及安全最佳实践更为方便。将集群委托给现有的商业云提供商也很便宜。

2.  **您能说出一些拥有托管 Kubernetes 解决方案的商业云提供商吗？**

Amazon Web Services、Google Cloud Services、Microsoft Azure、Digital Ocean 和 IBM Cloud 都是具有托管 Kubernetes 解决方案的商业云提供商。

3.  **您需要执行什么操作才能推送到 AWS Docker 注册表？**

您需要登录到 Docker 守护程序。您可以使用以下代码获取登录命令：

```py
$ aws ecr get-login --no-include-email
```

4.  **我们使用什么工具来建立 EKS 集群？**

`eksctl`允许我们从命令行创建整个集群，并根据需要放大或缩小集群。

5.  **为了使用前几章中的 YAML 文件，我们在本章中做了哪些主要更改？**

我们必须更改图像定义才能使用 AWS 注册表。我们包括了活动性和就绪性探测，以及一个部署策略。

These are only added to the `frontend` deployment. Adding the rest of the deployments is left to you as an exercise.

6.  **该集群中是否存在不需要的 Kubernetes 元素？**

Ingress 元素不是严格要求的，因为 Thinks 后端和 Users 后端不能从外部访问。前端服务能够创建面向外部的 ELB。

Don't feel like you're limited by our configuration. You can manually configure an ELB so that you can access the cluster in different ways, so you can use the Ingress configuration if you wish.

7.  **为什么我们需要控制与 SSL 证书关联的 DNS？**

我们需要证明我们拥有 DNS，以便 SSL 证书可以验证只有 DNS 地址的合法所有者才能访问该 DNS 的证书。这是 HTTPS 的根元素，表示您正在与特定 DNS 的所有者私下通信。

8.  **活跃度和准备度的区别是什么？**

如果就绪探测失败，pod 在再次通过之前不会接受请求。如果活动性探测失败，容器将重新启动。

9.  **为什么滚动更新在生产环境中很重要？**

它们非常重要，因为它们可以避免服务中断。他们一个接一个地增加工人，同时移除旧工人，确保随时可用的工人数量保持不变。

10.  **自动缩放吊舱和节点之间有什么区别？**

由于节点反映在物理实例中，因此缩放它们会影响系统中的资源。同时，scalingpods 使用可用的资源，但不会修改它们。

换句话说，增加节点数量会增加需要在系统上运行的硬件。这有一个与之相关的成本，因为我们需要从我们的云提供商那里租用更多的硬件。增加 POD 的数量在硬件方面没有成本，这就是为什么需要增加一些开销的原因。

这两种策略应该协调一致，以便我们能够对负载增加做出快速反应，同时减少正在使用的硬件数量，从而降低成本。

11.  **在本章中，我们部署了自己的数据库容器。在生产中，这不是必需的。但是，如果您连接到一个已经存在的数据库，您将如何做到这一点？**

第一步是更改`thoughts_backend/deployment.yaml`和`users_backend/deployment.yaml`文件中的环境变量。连接的主要设备是`POSTGRES_HOST`，但用户和密码可能也需要更改。

Instead of connecting to `POSTGRES_HOST` as an IP or DNS address directly, we could create an internal Kubernetes service called `postgres-db` that points toward an external address. This could help us abstract the address of the external database.

这将一次性部署，以确保我们可以连接到外部数据库。

然后，我们可以删除部署中描述的数据库容器，即`thoughts-backend-db`和`users-backend-db`。这些容器的图像仅用于测试和开发。

# 第八章

1.  **使用脚本将新代码推送到服务器和使用配置管理工具（如 Puppet）有什么区别？**

当使用脚本将新代码推送到服务器时，每个服务器都需要单独推送代码。*Puppet*和其他配置管理工具有一个集中式服务器，接收新数据并适当分发。它们还监视服务器是否按预期运行，并可以执行修正任务。

配置管理工具用于大型集群，因为它们减少了需要在自定义脚本中处理的工作量。

2.  **DevOps 背后的核心理念是什么？**

DevOps 背后的核心思想是授权团队，以便他们能够控制自己的部署和基础设施的执行。这需要一个自动化程序形式的安全网络，以确保这些操作容易、安全、快速执行。

3.  **使用 GitOps 有什么好处？**

使用 GitOps 的主要优点如下：

*   Git 是大多数团队已经知道如何使用的常用工具。
*   它保留了基础结构定义的副本，这意味着我们可以将其用作备份并从灾难性故障中恢复，或者根据以前的定义轻松创建新集群。
*   基础设施的更改是版本化的，这意味着我们可以一个接一个地进行小的离散更改，并在出现问题时恢复其中的任何更改。

4.  **Kubernetes 集群中只能使用 GitOps 吗？**

尽管 GitOps 确实与 Kubernetes 有协同作用，但由于 Kubernetes 可以由 YAML 文件控制，因此没有什么可以阻止我们使用 Git 存储库来控制集群。

5.  **通量部署在哪里？**

它生活在自己的 Kubernetes 集群中，因此可以从 Git 中提取数据。

6.  **为了让 Flux 能够访问它，您需要在 GitHub 中配置什么？**

您需要向 GitHub 存储库的部署密钥添加 SSH 密钥。您可以通过调用`fluxctl identity`获取 SSH 密钥。

7.  **当您在生产环境中工作时，GitHub 提供的哪些功能确保我们能够控制部署？**

我们需要在合并到主分支（触发部署）之前进行审查和批准。包含代码所有者以强制特定用户批准可以帮助我们控制微妙的领域。

# 第九章

1.  **当接收到新的业务特性时，在微服务架构下工作的系统中需要做什么分析？**

我们需要确定新业务功能会影响哪些微服务。影响多个微服务的特性使其实现更加困难。

2.  **如果一个功能需要更改两个或多个微服务，我们如何决定先更改哪一个？**

为了保持向后兼容性，这应该以从后到前的方式进行。应在考虑向后兼容性的同时添加新功能，因此可能性有限。一旦后端准备就绪，前端就可以相应地进行更改，以便我们可以利用新功能。

3.  **Kubernetes 如何帮助我们建立多个环境？**

在 Kubernetes 中创建新名称空间非常容易。由于系统的定义封装在 YAML 文件中，因此可以复制和修改它们以创建重复的环境。这可以用作基线，然后进行改进。

4.  **代码评审是如何工作的？**

将一个分支中的代码与主分支中的代码进行比较。另一个开发人员可以查看它们之间的差异并发表评论，要求澄清或更改。然后可以讨论这些问题，然后如果评审员认为代码足够好，就可以批准代码。在获得一个或多个批准之前，可以阻止合并。

5.  **代码审查的主要瓶颈是什么？**

主要的瓶颈是没有评审员提供反馈和批准代码。这就是为什么有足够多的人来扮演审稿人的角色是很重要的。

6.  **在 GitOps 原则下，部署评审是否与代码评审不同？**

不在 GitOps 下，部署被视为代码，因此它们可以像任何其他代码审查一样进行审查。

7.  **为什么一旦某个功能准备好合并到主分支中，就必须有一条清晰的部署路径？**

重要的是要有一个清晰的部署路径，这样每个人都在同一页上。它还提供了部署速度的明确预期。通过这样做，我们可以指定何时需要审查。

8.  **为什么数据库迁移与常规代码部署不同？**

它们是不同的，因为它们不容易回滚。虽然可以回滚代码部署，以便再次部署上一个映像，但数据库迁移会更改数据库或数据的架构，如果恢复，可能会导致数据丢失。通常情况下，数据库迁移只是向前迁移，发生的任何问题都需要通过新的部署进行纠正。

这就是我们必须特别注意数据库迁移并确保它们不向后兼容的主要原因。

# 第十章

1.  **系统的可观测性是什么？**

这是一个系统的容量。它让你知道它的内部状态是什么。

2.  **默认情况下，日志中有哪些不同的严重性级别？**

按照严重程度增加的顺序，不同的严重程度级别为`DEBUG`、`INFO`、`WARNING`、`ERROR`和`CRITICAL`。

3.  **指标的用途是什么？**

度量允许您找出系统上发生的事件的聚合状态，并允许您了解系统的一般状态。

4.  **为什么需要在日志中添加请求 ID？**

您需要将请求 ID 添加到日志中，以便可以对与同一请求相对应的所有日志进行分组。

5.  **普罗米修斯有哪些标准？**

计数器，用于计算特定事件；仪表，用于跟踪可上升或下降的数值；以及直方图（或摘要），用于跟踪具有相关值的事件，例如事件发生的时间或返回请求的状态代码的时间。

6.  **度量标准中的第 75 百分位是什么？它与平均值有什么不同？**

在直方图中，*75<sup>th</sup>*百分位为*25%*的事件高于平均值，而*75%*的事件低于平均值。平均值是通过将所有值相加，然后将该值除以最初相加的值的数量得到的。通常，平均值将接近第 50 个百分位，尽管这取决于值的分布方式。

如果我们希望确定延迟，那么*90<sup>th</sup>*-*95<sup>th</sup>*百分位是好的，因为它提供了请求的上限时间，而不计算异常值。平均值可能会被异常值所扭曲，因此无法为绝大多数请求提供一个实际的数字。

7.  **四个黄金信号是什么？**

四个黄金信号是收集系统健康状况描述的四个测量值。它们是请求的延迟、通信量、返回错误的百分比和资源的饱和。

# 第十一章

1.  **在微服务体系结构系统中发布更改与在整体中发布更改有什么区别？**

发布 monolith 中的更改只涉及一个存储库，因为 monolith 只是一个代码库。在微服务体系结构中进行的一些更改将需要我们更改两个或多个微服务，以便我们可以分配它们。这需要更多的规划和关注，因为我们需要确保这一点得到适当的协调。在适当架构的微服务系统中，此类多存储库更改应该相对较少，因为它们会产生开销。

2.  **为什么在微服务架构中发布的更改应该很小？**

微服务的优点是我们可以并行发布微服务，这比单一发布要快。然而，考虑到微服务中的发布可能会影响其他微服务，它们应该以迭代的方式工作，减少更改的大小并提高部署速度。

如果需要的话，一个小的改变风险更小，更容易回滚。

3.  **语义版本控制是如何工作的？**

在语义版本控制中，版本有三个编号：一个*主要*版本号、一个*次要*版本号和一个*补丁*版本号。这些都用点隔开：

*   补丁版本的增加只能修复 bug 和安全问题。
*   次要版本的增加增加了更多功能，但没有向后不兼容的更改。
*   主版本的增加会产生向后不兼容的更改。

4.  **微服务体系结构系统内部接口的语义版本控制存在哪些问题？**

由于微服务中的部署非常普遍，并且向后兼容性非常重要，因此*主要*版本的意义变得模糊。此外，微服务的大多数消费者都是内部的，所以版本之间的隐式通信就不那么重要了。

当发布变得普遍时，语义版本控制就失去了意义，因为其目标是不断完善和改进产品，而不是标记大型发布。

5.  **添加版本端点有什么好处？**

任何使用微服务的消费者都可以使用与其他任何请求相同的方式请求其版本：使用 RESTful 调用。

6.  **如何解决本章代码中的依赖性问题？**

本章中的代码之间存在一个要填充的依赖关系问题。

7.  **我们应该在共享配置映射中存储哪些配置变量？**

我们应该存储由多个微服务访问的配置变量。我们应该先发制人地存储大多数配置变量，以便可以重用它们。

8.  **描述将所有配置变量放入单个共享配置映射的优缺点。**

单个共享 ConfigMap 使配置变量非常明确。它鼓励每个人重用它们，并告诉其他人该配置在其他微服务中的用途。

更改微服务的依赖关系将触发重新启动，因此更改作为所有内容的依赖关系的 ConfigMap 将导致群集中的所有微服务重新启动，这非常耗时。

此外，单个 ConfigMap 文件可能会非常大，将其拆分为几个较小的文件可以帮助我们更高效地组织数据。

9.  **Kubernetes 配置图和 Kubernetes 秘密有什么区别？**

Kubernetes 的秘密得到更好的保护，以防意外访问。直接访问工具不会以纯文本显示机密。还需要以更明确的方式配置对机密的访问。另一方面，ConfigMaps 可以批量配置，因此 pod 将能够访问 ConfigMap 中存储的所有值。

10.  **我们怎样才能改变库伯尼特斯的秘密？**

我们可以使用`kubectl edit`更改机密，但它需要以 Base64 格式编码。

例如，要将`postgres-password`秘密替换为`someotherpassword`值，我们可以使用以下代码：

```py
$ echo someotherpassword | base64
c29tZW90aGVycGFzc3dvcmQK
$ kubectl edit secrets -n example thoughts-secrets
# Please edit the object below. Lines beginning with a '#' will be ignored,
# and an empty file will abort the edit. If an error occurs while saving this file will be
# reopened with the relevant failures.
#
apiVersion: v1
data:
 postgres-password: c29tZW90aGVycGFzc3dvcmQK
...
secret/thoughts-secrets edited
```

一旦重启，我们的吊舱将能够使用新的秘密。

11.  **想象一下，根据我们的配置，我们决定将 public_key.pub 从 Secret 更改为 ConfigMap。我们必须做出哪些改变？**

我们需要更改 ConfigMap，使其包含`configuration.yaml`中的文件：

```py
THOUGHTS_BACKEND_URL: http://thoughts-service
public_key.pub: |
  -----BEGIN PUBLIC KEY-----
  <public key>
  -----END PUBLIC KEY-----
USER_BACKEND_URL: http://users-service
```

请注意用于分隔文件的缩进。`|`字符标记多行字符串。

然后，在`deployment.yaml`文件中，我们需要将挂载源从一个 Secret 更改为一个 ConfigMap：

```py
volumes:
    - name: public-key
      configMap:
          name: shared-config
          items:
              - key: public_key.pub
                path: public_key.pub
```

请记住首先将这些更改应用于 ConfigMap，以便在应用部署文件时这些更改可用。

Note that this method creates an environment variable called `public_key.pub`, along with the content of the file, since it is applied as part of the `shared-config` ConfigMap. An alternative is to create an independent ConfigMap.

重新启动所有 POD 后，可以删除该秘密。

# 第十二章

1.  **为什么领先的架构师能够方便地使用微服务体系结构系统？**

在微服务体系结构中构建系统允许我们创建可以并行处理的独立服务。这些服务仍然需要相互沟通和合作。

独立团队通常不了解全局，往往专注于自己的项目。为了帮助系统作为一个整体进行协调和发展，独立团队需要一个对系统有高层次概述的领先架构师。

2.  **康威定律是什么？**

康威定律是一句格言，它说软件结构复制了编写软件的组织的通信结构。

这意味着，要改变软件的结构方式，组织需要改变，这是一项更加困难的任务。

为了成功地设计和发展大型系统，需要对组织进行相应的考虑和规划。

3.  **技术债务是如何引入的？**

有很多方法可以产生技术债务。

通常情况下，技术债务分为以下四类之一或它们的组合：

*   在没有花时间分析其他选项的情况下快速开发
*   通过折衷缩短开发时间，同时知道以后需要修复组件
*   对当前系统或工具没有足够的了解，或缺乏培训或专业知识
*   通过对外部问题做出错误的假设，从而设计不一定需要修复的东西

4.  **为什么重要的是创造一种文化，以便我们能够持续努力减少技术债务？**

创建一种文化非常重要，这样我们可以避免*软件腐烂*，这是由于增加了现有软件的复杂性而导致的性能和可靠性的持续衰退。除非解决技术债务成为一个持续的过程，否则发布新版本的日常压力意味着我们将无法进行维护。

5.  **为什么在发布中记录问题并与团队其他成员共享这些问题很重要？**

这一点很重要，因为每个团队都可以从其他团队的经验和解决方案中学习，并改进其流程。这也可以创造一种开放的文化，人们不怕为自己的错误承担责任。

6.  **验尸会议的主要目的是什么？**

验尸会议的主要目的是制定后续任务，以确定事件的原因。为此，我们需要尽可能确信根本原因已被成功检测到（这也是次要目标）。