# 测试和调试

在本章中，我们将讨论以下主题：

*   TDD
*   写作测试的注意事项
*   嘲笑
*   调试
*   登录中

至少，每个程序员都必须考虑跳过编写测试。在 Django 中，默认的应用程序布局有一个带有一些占位符内容的`tests.py`模块。它提醒我们需要进行测试。然而，我们经常被诱惑跳过它。

在 Django 中，编写测试与编写代码非常相似。事实上，它实际上是代码。因此，编写测试的过程似乎是编码工作的两倍（甚至更多）。有时，我们面临着巨大的时间压力，以至于当我们只是想让事情顺利进行时，花时间编写测试似乎很可笑。

然而，最终，如果您希望其他人使用您的代码，那么跳过测试是毫无意义的。想象一下，你发明了一种电动剃须刀，并试图把它卖给你的朋友，说它对你很有效，但你没有对它进行适当的测试。作为你的好朋友，他们可能会同意，但是如果你把这件事告诉一个陌生人，想象一下他们的恐惧。

# 为什么要编写测试？

软件中的测试检查它是否按预期工作。如果没有测试，您可能会说您的代码工作正常，但您将无法证明它工作正常。

此外，重要的是要记住，在 Python 中忽略单元测试可能是危险的，因为它具有 duck 类型的特性。与 Haskell 等语言不同，类型检查不能在编译时严格执行（尽管类型提示有帮助）。单元测试在运行时运行（尽管是在单独的执行中），在 Python 开发中是必不可少的。

编写测试可能是一种令人谦卑的经历。考试将指出你的错误，你将有机会尽早改正错误。事实上，有些人主张在代码本身之前编写测试。

# TDD

TDD 是软件开发的一种形式，首先编写测试，运行测试（首先会失败），然后编写使测试通过所需的最少代码。这听起来可能违反直觉。当我们知道我们没有编写任何代码并且我们确信它会因此失败时，为什么我们需要编写测试呢？

不过，再看看。我们最终编写的代码只满足这些测试。这意味着这些测试不是普通测试，它们更像规范。他们告诉你会发生什么。这些测试或规范将直接来自客户的用户故事。您编写的代码刚好足以使其正常工作。

TDD 过程与作为现代科学基础的科学方法有许多相似之处。在科学方法中，重要的是首先构建假设，收集数据，然后进行可重复和可验证的实验来证明或反驳你的假设。

我的建议是，一旦您对为您的项目编写测试感到满意，就尝试 TDD。初学者可能会发现很难构建一个测试用例来检查代码的行为。出于同样的原因，我不建议将 TDD 用于探索性编程。

# 编写测试用例

有不同种类的测试。然而，作为最低要求，程序员需要知道单元测试，因为他们必须能够编写单元测试。单元测试检查应用程序的最小可测试部分。集成测试检查这些部件是否彼此工作良好。

“单位”一词是这里的关键术语。一次只测试一个单元。让我们来看一个测试用例的简单例子：

```
# tests.py 
from django.test import TestCase 
from django.core.urlresolvers import resolve 
from .views import HomeView 
class HomePageOpenTestCase(TestCase): 
    def test_home_page_resolves(self): 
        view = resolve('/') 
        self.assertEqual(view.func.__name__, 
                         HomeView.as_view().__name__) 
```

这是一个简单的测试，检查用户在访问我们网站的根域时是否正确地进入了主页视图。像大多数好的测试一样，它有一个很长的自描述性名称。该测试只是使用 Django 的`resolve()`函数将映射到`/`根位置的视图可调用项与已知的视图函数按名称进行匹配。

更重要的是要注意本测试中未完成的操作。我们没有尝试检索页面的 HTML 内容或检查其状态代码。我们限制自己只测试一个单元，即`resolve()`函数，它将 URL 路径映射到视图函数。

假设此测试驻留在项目的`app1`中，可以使用以下命令运行测试：

```
$ ./manage.py test app1 
Creating test database for alias 'default'... 
. 
----------------------------------------------------------------- 
Ran 1 test in 0.088s 

OK 
Destroying test database for alias 'default'... 
```

此命令运行`app1`应用程序或包中的所有测试。默认测试运行程序将在该包中的所有模块中查找与`test*.py`模式匹配的测试。

Django 现在使用 Python 提供的标准`unittest`模块，而不是捆绑自己的模块。您可以通过从`django.test.TestCase`子类化来编写`testcase`类。

此类通常具有具有以下命名约定的方法：

*   `test*`：任何名称以`test`开头的方法都将作为测试方法执行。它不接受任何参数，也不返回任何值。测试将按
    字母顺序进行。
*   `setUp`（可选）：此方法将在每个测试方法之前运行。它可用于创建共享对象或执行其他初始化任务，从而使测试用例处于已知状态。
*   `tearDown`（可选）：该方法将在测试方法之后运行，无论测试是否通过。清理任务通常在这里执行。

测试用例是对测试方法进行逻辑分组的一种方法，所有这些方法都测试一个场景。当所有测试方法都通过时（即，不引发任何异常），测试用例被认为通过了。如果其中任何一个失败，测试用例就会失败。

# 断言方法

每个测试方法通常调用一个`assert*()`方法来检查测试的一些预期结果。在第一个示例中，我们使用`assertEqual()`检查函数名是否与预期函数匹配。

与`assertEqual()`类似，Python 3`unittest`库提供了 32 种以上的断言方法。Django 通过超过 19 种特定于框架的断言方法对其进行了进一步扩展。您必须根据预期的最终结果选择最合适的方法，以便获得最有用的错误消息。

让我们来看看为什么，通过看一个例子，有下面的方法：

```
def setUp(self): 
    self.l1 = [1, 2] 
    self.l2 = [1, 0] 
```

我们的测试是断言`l1`和`l2`是相等的（考虑到它们的值，它应该失败）。让我们来看看几种实现这一点的等效方法：

| **测试断言语句** | **测试输出是什么样子的（不重要的行省略）** |
| 

```
assert self.l1 == self.l2
```

 | 

```
assert self.l1 == self.l2
 AssertionError
```

 |
| 

```
self.assertEqual(self.l1, self.l2)
```

 | 

```
AssertionError: Lists differ: [1, 2] != [1, 0]
 First differing element 1:
 2
 0
```

 |
| 

```
self.assertListEqual(self.l1,
    self.l2)
```

 | 

```
AssertionError: Lists differ: [1, 2] != [1, 0]
First differing element 1:
 2
 0
```

 |
| 

```
self.assertListEqual(self.l1, None)
```

 | 

```
AssertionError: Second sequence is not a list: None
```

 |

第一条语句使用 Python 的内置`assert`关键字。请注意，它抛出的是最没有帮助的错误。无法推断`self.l1`和`self.l2`变量中的值或类型。这就是我们需要使用`assert*()`方法的主要原因。

接下来，`assertEqual()`抛出的异常非常有用地告诉您，您正在比较两个列表，甚至告诉您它们在哪个位置开始不同。这与更专业的`assertListEqual()`函数引发的异常非常相似。这是因为，文档会告诉您，如果给`assertEqual()`两个列表进行比较，它会将其交给`assertListEqual()`。

尽管如此，正如最后一个例子所证明的，在测试中最好使用最具体的`assert*`方法。因为第二个参数不是列表，所以错误清楚地告诉您应该有一个列表。

在测试中使用最具体的`assert*`方法。

因此，您需要熟悉所有的`assert`方法，并选择最具体的方法来评估您期望的结果。当您正在检查您的应用程序是否没有做它不应该做的事情时，也就是说，一个否定的测试用例。您可以分别使用`assertRaises`和`assertWarns`检查异常或警告。

# 编写更好的测试用例

我们已经看到，最好的测试用例一次只测试一小部分代码。他们也需要快一点。程序员需要在每次提交源代码管理之前至少运行一次测试。即使是几秒钟的延迟也会诱使程序员跳过运行测试（这不是一件好事）。

以下是一个好的测试用例（当然这是一个主观术语）的一些特性，其形式为易于记忆的记忆**快速**、**独立**、**可重复**、**小**、**透明**（**第一**类测试用例：

*   **快速**：测试速度越快，运行频率越高。理想情况下，您的测试应该在几秒钟内完成。
*   **独立**：每个测试用例必须独立于其他测试用例，并且可以以任何顺序运行。
*   **可重复**：每次运行测试的结果必须相同。理想情况下，在运行测试之前，必须控制所有随机和变化因素或将其设置为已知值。
*   **小**：测试用例必须尽可能短，以提高速度和易于理解。
*   **透明**：避免棘手的实现或模棱两可的测试用例。

此外，确保您的测试是自动的。消除任何手动步骤，无论多么小。自动化测试更有可能成为团队工作流程的一部分，并且更易于用于工具目的。

也许，更重要的是编写测试用例时要记住的注意事项：

*   **不（重新）测试框架**：Django 测试良好。不要检查 URL 查找、模板呈现和其他与框架相关的功能。
*   **不测试实现细节**：测试接口，留下次要的实现细节。这使得以后在不破坏测试的情况下重构它变得更容易。
*   **测试模型最多，模板最少**：模板应该具有最少的业务逻辑，并且它们的变化更频繁。
*   **避免 HTML 输出验证**：测试视图使用其上下文变量的输出，而不是其 HTML 呈现的输出。
*   **避免在单元测试中使用 web 测试客户端**：web 测试客户端调用多个组件，因此更适合集成测试。
*   **避免与外部系统交互**：如果可能，模仿它们。数据库是一个例外，因为测试数据库在内存中，速度非常快。

当然，您可以（也应该）在有充分理由的情况下违反规则（就像我在第一个示例中所做的那样）。最终，您在编写测试方面越有创意，就越早发现 bug，应用程序就会越好。

# 嘲笑

大多数实际项目在组件之间都有各种相互依赖关系。测试一个组件时，结果不得受其他组件行为的影响。例如，您的应用程序可能调用服务可用性不可靠或响应缓慢的外部 web 服务。

模拟对象通过具有相同的接口来模拟这种依赖关系，但它们以固定的响应响应方法调用。在测试中使用模拟对象后，您可以断言是否调用了某个方法，并验证是否发生了预期的交互。

以*模式中提到的超级英雄档案合格性测试为例：服务对象*（参见[第 3 章](03.html)、*车型*）。我们将在使用 Python 3`unittest.mock`库的测试中模拟对服务对象方法的调用：

```
# profiles/tests.py 
from django.test import TestCase 
from unittest.mock import patch 
from django.contrib.auth.models import User 

class TestSuperHeroCheck(TestCase): 
    def test_checks_superhero_service_obj(self): 
        with patch("profiles.models.SuperHeroWebAPI") as ws: 
            ws.is_hero.return_value = True 
            u = User.objects.create_user(username="t") 
            r = u.profile.is_superhero() 
        ws.is_hero.assert_called_with('t') 
        self.assertTrue(r) 
```

在这里，我们使用`patch()`作为`with`语句中的上下文管理器。由于概要文件模型的`is_superhero()`方法将调用`SuperHeroWebAPI.is_hero()`类方法（查询外部 web 服务），因此我们需要在`models`模块中模拟它。我们还将此方法的返回值硬编码为`True`。

最后两个断言分别检查是否使用正确的参数调用了该方法，以及`is_hero()`是否返回了`True`。由于`SuperHeroWebAPI`类的所有方法都已被模拟，因此两个断言都将通过。

模拟对象来自一个名为**test doubles**的家族，其中包括存根、赝品等。就像电影替身是真实演员的替身一样，这些测试替身在测试时用来代替真实对象。尽管它们之间没有明确的界限，模拟对象是可以测试行为的对象，存根只是占位符实现。

# 模式-测试夹具和工厂

**问题**：测试组件需要在测试之前创建各种先决条件对象。在每个测试方法中显式地创建它们是重复的。

**解决方案**：利用工厂或夹具创建测试数据对象。

# 问题详情

在运行每个测试之前，Django 将数据库重置为其初始状态，就像运行迁移之后一样。大多数测试都需要创建一些初始对象来设置状态。通常会创建一组公共的初始对象，而不是为不同的场景创建不同的初始对象。

在大型测试套件中，这可能很快变得难以管理。这些最初的对象种类繁多，很难阅读，以后也很难理解。这导致在测试数据本身中很难找到 bug。

作为这样一个常见的问题，有几种方法可以减少混乱并编写更清晰的测试用例。

# 解决方案详细信息

我们要看的第一个解决方案是 Django 文档本身中给出的，即测试夹具。在这里，测试夹具是一个包含一组数据的文件，这些数据可以导入到数据库中以使其处于已知状态。通常，它们是 YAML 或 JSON 文件，以前在同一数据库中有一些数据时从该数据库导出。

例如，考虑下面的测试用例，它使用测试夹具：

```
from django.test import TestCase 

class PostTestCase(TestCase): 
    fixtures = ['posts'] 

    def setUp(self): 
        # Create additional common objects 
        pass 

    def test_some_post_functionality(self): 
        # By now fixtures and setUp() objects are loaded 
        pass 
```

在每个测试用例中调用`setUp()`之前，将加载指定的夹具`'posts'`。粗略地说，将在 fixtures 目录中搜索 fixture，其中包含某些已知的扩展名，例如，`app/fixtures/posts.json`。

但是，固定装置存在许多问题。fixture 是数据库的静态快照。它们依赖于模式，必须在每次模型更改时进行更改。当您的测试用例断言更改时，它们也可能需要更新。手动更新包含多个相关对象的大型夹具文件绝非易事。

由于所有这些原因，许多人认为使用夹具作为反模式。建议您改用工厂。factory 类创建可在测试中使用的特定类的对象。这是创建初始测试对象的一种干燥方式。

让我们使用模型的`objects.create`方法创建一个简单的工厂：

```
from django.test import TestCase 
from .models import Post 

class PostFactory: 
    def make_post(self): 
        return Post.objects.create(message="") 

class PostTestCase(TestCase): 

    def setUp(self): 
        self.blank_message = PostFactory().makePost() 

    def test_some_post_functionality(self): 
        pass 
```

与使用 fixture 相比，初始对象创建和测试用例都在一个地方。夹具将静态数据按原样加载到数据库中，而不调用模型定义的`save()`方法。由于工厂对象是动态生成的，因此它们更有可能通过应用程序的自定义验证运行。

然而，自己编写这样的工厂类有很多样板。基于 thoughtbot 的`factory_girl`的`factory_boy`包为创建对象工厂提供了声明性语法。

当您将前面的代码重写为使用`factory_boy`时，我们得到以下结果：

```
import factory 
from django.test import TestCase 
from .models import Post 

class PostFactory(factory.Factory): 
    class Meta: 
        model = Post 
    message = "" 

class PostTestCase(TestCase): 

    def setUp(self): 
        self.blank_message = PostFactory.create() 
        self.silly_message = PostFactory.create(message="silly") 

    def test_post_title_was_set(self): 
        self.assertEqual(self.blank_message.message, "") 
        self.assertEqual(self.silly_message.message, "silly") 
```

请注意，`factory`类在以声明方式编写时变得多么清晰。属性的值不必是静态的。可以有顺序、随机或计算属性值。如果您希望有更真实的占位符数据，如美国地址，请使用`django-faker`包。

总之，对于大多数需要初始测试对象的项目，我会推荐工厂，尤其是`factory_boy`。您可能仍然希望对静态数据使用 fixture，例如国家列表或 t 恤尺寸，因为它们很少会更改。

可怕的预测

在宣布不可能的最后期限后，整个团队似乎突然失去了时间。他们从 4 周的 scrum 冲刺到 1 周的冲刺。史蒂夫从他们的日程表上抹去了每一次会议，除了“今天 30 分钟与史蒂夫的会面”。如果他需要与他们桌上的人交谈，他更愿意进行一对一的讨论。
在 O 女士的坚持下，30 分钟的会议在 SHIM 总部下方 20 层的隔音大厅举行。周一，研究小组站在一张与房间其他部分一样的灰色金属表面的大圆桌周围。史蒂夫尴尬地站在它面前，张开手掌做了一个僵硬的挥手动作。

尽管之前每个人都看到全息图活了下来，但每次都让他们大吃一惊。这个圆盘几乎将自己分割成数百个金属正方形，在一个未来模型城市中像玫瑰一样矗立着微型摩天大楼。他们花了一秒钟才意识到他们在看一个 3D 条形图。

“我们的燃尽图表似乎显示出放缓的迹象。我猜这是我们最近用户测试的结果，这是一件好事。但是……”史蒂夫的脸似乎显示出试图抑制喷嚏的紧张。他小心翼翼地将食指向上弹向空中，图表平稳地向右延伸。

“按照这种速度，预测显示我们最多会错过几天的上线时间。我做了一些分析，在我们的开发后期发现了几个关键的 bug。如果我们能及早发现它们，我们可以节省大量的时间和精力。我想让大家集思广益，想出一些 I…”

史蒂夫紧闭嘴，打了一个响亮的喷嚏。全息图将此解释为放大图像中特别无趣部分的标志。史蒂夫低声咒骂并关掉了它。他借了一张餐巾，开始用一支普通的钢笔记下每个人的建议。

Steve 最喜欢的建议之一是列出最常见错误的编码清单，例如忘记应用迁移。他还喜欢让用户更早地参与开发过程以获得反馈的想法。他还记下了一些不寻常的想法，例如用于在推特上显示持续集成服务器状态的推特手柄。

会议结束时，史蒂夫注意到埃文失踪。“埃文在哪里？”他问。“不知道，”布拉德看起来很困惑地说，“他一分钟前还在这里。”

# 了解更多关于测试的信息

Django 的默认测试运行程序在过去几年中有了很大的改进。然而，像`py.test`和`nose`这样的测试运行程序在功能上仍然是优越的。它们使您的测试更易于编写和运行。更好的是，它们与您现有的测试用例兼容。

您可能还想知道测试覆盖了多少代码。这被称为**代码覆盖率**，而`coverage.py`是一个非常流行的工具，用于发现这一点。

今天的大多数项目倾向于使用大量 JavaScript 功能。为它们编写测试通常需要一个类似浏览器的环境来执行。Selenium 是执行此类测试的优秀浏览器自动化工具。

虽然在 Django 中对测试的详细处理超出了本书的范围，但我强烈建议您了解更多。

如果没有别的，我想通过本节传达的两个主要要点是：第一，编写测试；第二，一旦你对编写测试有信心，就练习 TDD。

# 调试

尽管进行了最严格的测试，但可悲的现实是我们仍然必须处理 bug。Django 在报告错误以帮助您进行调试时，会尽力提供帮助。然而，识别问题的根本原因需要很多技巧。

谢天谢地，有了一套正确的工具和技术，我们不仅可以识别 bug，还可以深入了解代码的运行时行为。让我们看看这些工具中的一些。

# Django 调试页面

如果您在开发过程中遇到任何异常，即当`DEBUG=True`时，您可能已经看到类似于以下屏幕截图的错误页面：

![](assets/70628010-00a3-4027-bd8a-fb0be1e64003.png)

打开调试设置时的典型 Django 错误页

由于它出现得如此频繁，大多数开发人员往往会错过此页面中丰富的信息。以下是一些值得一看的地方：

*   **异常详细信息**：显然，您需要非常仔细地阅读异常告诉您的内容。
*   **异常位置**：这是 Python 认为错误发生的地方。在 Django 中，这可能是错误的根本原因所在，也可能不是。
*   **回溯**：这是发生错误时的调用堆栈。导致错误的行将位于末尾。导致它的嵌套调用将位于其上方。不要忘了单击 localvars 箭头，检查异常时变量的值。
*   **请求信息**：这是一个表格（屏幕截图中未显示），显示上下文变量、元信息和项目设置；在此处检查请求中是否存在格式错误的输入。

# 更好的调试页面

通常，您可能希望在默认的 Django 错误页面中具有更多的交互性。`django-extensions`包附带了神奇的 Werkzeug 调试器，该调试器正好提供了此功能。在同一异常的以下屏幕截图中，请注意在调用堆栈的每个级别都提供了完全交互式的 Python 解释器：

![](assets/c76aa391-6691-49ff-9ab2-fc8f0a9fd7c7.png)

Werkzeug 增强的错误页面，带有嵌入式交互式提示

要启用此功能，除了将`django_extensions`添加到您的`INSTALLED_APPS`之外，您还需要按如下方式运行测试服务器：

```
$ python manage.py runserver_plus 
```

尽管调试信息有所减少，但我发现 Werkzeug 调试器比默认错误页面更有用。

# 打印功能

将`print()`函数洒在整个代码中进行调试可能听起来很原始，但这已成为许多程序员的首选技术。

通常，`print()`函数添加在发生异常的行之前。它可以用于打印导致异常的各行中变量的状态。当到达某一行时，可以通过打印某些内容来跟踪执行路径。

在开发中，打印输出通常出现在测试服务器运行的控制台窗口中，而在生产中，这些打印输出可能会出现在服务器日志文件中，从而增加运行时开销。

在任何情况下，在生产中使用它都不是一种好的调试技术。即使这样，为调试而添加的打印函数也应该从提交到源代码管理中删除。

# 登录中

包含上一节的主要原因是，您应该在 Python 的`logging`模块中使用对日志函数的调用来替换`print()`函数。与打印相比，日志记录有几个优点：它有一个时间戳，一个明确标记的紧急级别（例如，INFO、DEBUG），并且您不必在以后从代码中删除它们。

日志记录是专业 web 开发的基础。生产堆栈中的多个应用程序（如 web 服务器和数据库）已经在使用日志。调试可能会将您带到所有这些日志，以追溯导致错误的事件。您的应用程序遵循相同的最佳实践，并对错误、警告和信息性消息采用日志记录，这才是合适的。

与通常的看法不同，使用记录器不会涉及太多工作。当然，设置稍微有点复杂，但这只是整个项目的一次性工作。更重要的是，大多数项目模板（例如，`edge`模板）已经为您完成了这项工作。

在`settings.py`中配置`LOGGING`变量后，将记录器添加到现有代码中非常简单，如下所示：

```
# views.py 
import logging 
logger = logging.getLogger(__name__)
```

```
def complicated_view(): 
    logger.debug("Entered the complicated_view()!") 
```

`logging`模块提供不同级别的日志消息，以便您可以轻松过滤不太紧急的消息。日志输出也可以以各种方式格式化，并路由到许多地方，例如标准输出或日志文件。阅读 Python`logging`模块的文档了解更多信息。

# Django 调试工具栏

Django 调试工具栏是一个不可或缺的工具，不仅用于调试，还用于跟踪每个请求和响应的详细信息。工具栏始终显示在呈现的页面中，而不是仅在异常期间显示。

最初，它在浏览器窗口的右侧显示为可单击的图形。单击时，工具栏将显示为一个黑色半透明侧边栏，其中包含多个部分：

![](assets/fe137c0c-fc63-4d04-87ff-4e83b5aa4102.png)

Django 调试工具栏中节的展开视图

每个部分都包含有关页面的详细信息，从执行的 SQL 查询数到我们用于呈现页面的模板。由于工具栏在`DEBUG`设置为 False 时消失，因此它几乎被限制为一个开发工具。

# Python 调试器 pdb

在调试时，可能需要在执行过程中停止 Django 应用程序来检查其状态。实现这一点的一个简单方法是在所需位置用一个简单的`assert False`行引发异常。

如果您想从该行一步一步地继续执行，该怎么办？这可以通过使用交互式调试器（如 Python 的`pdb`）实现。只要在希望停止执行的任何位置插入以下行并切换到`pdb`：

```
import pdb; pdb.set_trace() 
```

输入`pdb`后，您将在控制台窗口中看到一个命令行界面，并显示`(Pdb)`提示。同时，您的浏览器窗口将不会显示任何内容，因为请求尚未完成处理。

`pdb`命令行界面非常强大。它允许您逐行检查代码，通过打印变量来检查变量，或者执行甚至可以更改运行状态的任意代码。该接口与 GNU 调试器 GDB 非常相似。

# 其他调试器

`pdb`有几个替换品。它们通常有更好的界面。一些基于控制台的调试器如下所示：

*   `ipdb`：与 IPython 一样，它有自动完成、语法彩色代码等功能。
*   `pudb`：与旧的 Turbo C IDE 一样，这将并排显示代码和变量。
*   `IPython`：这不是调试器。通过添加`from IPython import embed; embed()`行，您可以在代码中的任何地方
    获得完整的 IPython shell。

`pudb`是我首选的`pdb`替代品。它非常直观，即使是初学者也可以轻松使用此界面。就像`pdb`一样，只需插入以下代码即可中断程序的执行：

```
import pudb; pudb.set_trace() 
```

执行前一行时，将启动全屏调试器，如下所示：

![](assets/df8adf00-9097-4b0b-aa0c-6dfe14f5681f.jpg)

一个典型的 pudb 调试会话

按`?`键可获得有关可使用的完整键列表的帮助。

此外，还有一些图形调试器，其中一些是独立的，如`winpdb`，还有一些集成到 IDE 中，如 PyCharm、PyDev 和 Komodo。我建议您尝试几种方法，直到找到适合您工作流程的方法。

# 调试 Django 模板

项目的模板中可能包含非常复杂的逻辑。创建模板时的细微错误可能导致难以发现的 bug。我们需要在`settings.py`中将`TEMPLATE_DEBUG`设置为`True`（除了`DEBUG`），这样当您的模板中出现错误时，Django 会显示一个更好的错误页面。

调试模板有几种粗略的方法，例如插入感兴趣的变量，例如`{{ variable }}`，或者如果您想转储所有变量，请使用内置的`debug`标记，如下所示（在方便单击的文本区域内）：

```
<textarea onclick="this.focus();this.select()" style="width: 100%;">  
  {% filter force_escape %}  
    {% debug %}  
  {% endfilter %} 
</textarea> 
```

更好的选择是使用前面提到的 Django 调试工具栏。它不仅告诉您上下文变量的值，还显示模板的继承树。

但是，您可能希望在模板中间暂停以检查状态（例如，在循环内）。调试器将非常适合此类情况。事实上，可以使用上述任何一个 Python 调试器，使用自定义模板标记为模板进行调试。

下面是这样一个模板标记的简单实现。在`templatetag`包目录中创建以下文件：

```
# templatetags/debug.py 
import pudb as dbg              # Change to any *db 
from django.template import Library, Node 

register = Library() 

class PdbNode(Node): 

    def render(self, context): 
        dbg.set_trace()         # Debugger will stop here 
        return '' 

@register.tag 
def pdb(parser, token): 
    return PdbNode() 
```

在模板中，加载模板标记库，在需要暂停执行的任何位置插入`pdb`标记，然后进入调试器：

```
{% load debug %} 

{% for item in items %} 
    {# Some place you want to break #} 
    {% pdb %} 
{% endfor %} 
```

在调试器中，您可以使用`context`字典检查任何内容，包括上下文变量：

```
    >>> print(context["item"])
    Item0

```

如果您需要更多这样的模板标签进行调试和自省，我建议您查看`django-template-debug`包。

# 总结

在本章中，我们研究了 Django 测试背后的动机和概念。我们还发现在编写测试用例时要遵循各种最佳实践。在调试部分，我们熟悉了各种调试工具和技术，以发现 Django 代码和模板中的 bug。

在下一章中，我们将通过了解各种安全问题以及如何减少各种恶意攻击的威胁，更进一步了解生产代码。