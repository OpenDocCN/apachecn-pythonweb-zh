# 第三章形式与观点

在本章中，我们将介绍以下主题：

*   将 HttpRequest 传递给表单
*   使用表单的保存方法
*   上传图像
*   使用 django crispy 表单创建表单布局
*   下载授权文件
*   筛选对象列表
*   管理分页列表
*   组合基于类的视图
*   生成 PDF 文档
*   用 Haystack 实现多语言搜索

# 导言

当在模型中定义数据库结构时，我们需要一些视图来让用户输入数据或向人们显示数据。在本章中，我们将重点介绍管理表单的视图、列表视图以及生成 HTML 以外的其他输出的视图。对于最简单的示例，我们将把 URL 规则和模板的创建留给您。

# 将 HttpRequest 传递给表单

每个 Django 视图的第一个参数是通常命名为`request`的`HttpRequest`对象。它包含关于请求的元数据。例如，当前语言代码、当前用户、当前 cookie 和当前会话。默认情况下，视图中使用的表单接受`GET`或`POST`参数、文件、初始数据和其他参数；但是，不是`HttpRequest`对象。在某些情况下，将`HttpRequest`额外传递给表单是很有用的，尤其是当您希望使用请求数据过滤掉表单字段的选择或处理在表单中保存诸如当前用户或 IP 之类的内容时。

在这个配方中，我们将看到一个表单示例，其中一个人可以选择一个用户并向他们发送消息。我们将`HttpRequest`对象传递给表单，以便将当前用户排除在接收者选择之外；我们不希望任何人给自己写信息。

## 准备好了吗

让我们创建一个名为`email_messages`的新应用程序，并将其放入设置中的`INSTALLED_APPS`。此应用程序将没有模型，只有窗体和视图。

## 怎么做…

要完成此配方，请执行以下步骤：

1.  添加一个新的`forms.py`文件，消息表单包含两个字段：收件人选择和消息文本。此外，此表单将有一个初始化方法，该方法将接受请求对象，然后为收件人的选择字段修改`QuerySet`：

    ```
    # email_messages/forms.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django import forms
    from django.utils.translation import ugettext_lazy as _
    from django.contrib.auth.models import User

    class MessageForm(forms.Form):
        recipient = forms.ModelChoiceField(
            label=_("Recipient"),
            queryset=User.objects.all(),
            required=True,
        )
        message = forms.CharField(
            label=_("Message"),
            widget=forms.Textarea,
            required=True,
        )

        def __init__(self, request, *args, **kwargs):
            super(MessageForm, self).__init__(*args, **kwargs)
     self.request = request
            self.fields["recipient"].queryset = \
                self.fields["recipient"].queryset.\
                exclude(pk=request.user.pk)
    ```

2.  然后，使用`message_to_user()`视图创建`views.py`，以处理表单。如您所见，request对象作为第一个参数传递给表单，如下所示：

    ```
    # email_messages/views.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.contrib.auth.decorators import login_required
    from django.shortcuts import render, redirect

    from .forms import MessageForm

    @login_required
    def message_to_user(request):
        if request.method == "POST":
            form = MessageForm(request, data=request.POST)
            if form.is_valid():
                # do something with the form
                return redirect("message_to_user_done")
        else:
            form = MessageForm(request)

        return render(request,
            "email_messages/message_to_user.html",
            {"form": form}
        )
    ```

## 它是如何工作的…

在初始化方法中，我们有表示表单本身实例的`self`变量，我们还有新添加的`request`变量，然后还有其余的位置参数（`*args`和命名参数（`**kwargs`。我们调用`super()`初始化方法，将所有位置参数和命名参数传递给它，以便表单正确启动。然后，我们将把`request`变量分配给表单的一个新`request`属性，以便以后在表单的其他方法中访问。然后，我们修改接收者选择字段的`queryset`属性，将当前用户排除在请求之外。

在视图中，我们将在两种情况下传递`HttpRequest`对象作为第一个参数：发布表单时，以及首次加载表单时。

## 另见

*   *使用*配方表的保存方法

# 使用表单的保存方式

为了使您的视图简洁明了，最好的做法是尽可能将表单数据的处理移到表单本身，并且尽可能合理。通常的做法是使用`save()`方法保存数据、执行搜索或执行其他智能操作。我们将使用`save()`方法扩展前面配方中定义的表单，该方法将向所选收件人发送电子邮件。

## 准备好了吗

我们将以*中定义的示例为基础，将 HttpRequest 传递给*表单。

## 怎么做…

要完成此配方，请执行以下两个步骤：

1.  从 Django 导入函数以发送电子邮件。然后，将`save()`方法添加到`MessageForm`。它将尝试向所选收件人发送电子邮件，如果出现任何错误，它将自动失败：

    ```
    # email_messages/forms.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django import forms
    from django.utils.translation import ugettext,\
        ugettext_lazy as _
    from django.core.mail import send_mail
    from django.contrib.auth.models import User

    class MessageForm(forms.Form):
        recipient = forms.ModelChoiceField(
            label=_("Recipient"),
            queryset=User.objects.all(),
            required=True,
        )
        message = forms.CharField(
            label=_("Message"),
            widget=forms.Textarea,
            required=True,
        )

        def __init__(self, request, *args, **kwargs):
            super(MessageForm, self).__init__(*args, **kwargs)
            self.request = request
            self.fields["recipient"].queryset = \
                self.fields["recipient"].queryset.\
                exclude(pk=request.user.pk)

     def save(self):
     cleaned_data = self.cleaned_data
     send_mail(
     subject=ugettext("A message from %s") % \
     self.request.user,
     message=cleaned_data["message"],
     from_email=self.request.user.email,
     recipient_list=[
     cleaned_data["recipient"].email
     ],
     fail_silently=True,
     )

    ```

2.  然后，如果发布的数据有效，则在视图中的表单中调用的`save()`方法：

    ```
    # email_messages/views.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.contrib.auth.decorators import login_required
    from django.shortcuts import render, redirect

    from .forms import MessageForm

    @login_required
    def message_to_user(request):
        if request.method == "POST":
            form = MessageForm(request, data=request.POST)
            if form.is_valid():
     form.save()
                return redirect("message_to_user_done")
        else:
            form = MessageForm(request)

        return render(request,
            "email_messages/message_to_user.html",
            {"form": form}
        )
    ```

## 它是如何工作的…

让我们看一下表格。`save()`方法使用表单中已清理的数据读取收件人的电子邮件地址和消息。电子邮件的发件人是请求中的当前用户。如果由于邮件服务器配置不正确或其他原因导致邮件无法发送，则会自动失败；也就是说，不会出现错误。

现在，让我们看一看风景。当发布的表单有效时，将调用表单的`save()`方法，并将用户重定向到成功页面。

## 另见

*   *传递 HttpRequest 到*配方表单
*   *下载授权文件*配方

# 上传图片

在本食谱中，我们将了解处理图像上传的最简单方法。您将看到一个应用程序的示例，在该应用程序中，访问者可以上传带有鼓舞人心的引用的图像。

## 准备好了吗

确保在您的虚拟环境或全球范围内安装枕头或 PIL。

然后，让我们创建一个`quotes`应用程序，并将其放入`INSTALLED_APPS`的设置中。然后，我们将添加一个带有三个字段的`InspirationalQuote`模型：`author`、`quote`文本和`picture`，如下所示：

```
# quotes/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import os
from django.db import models
from django.utils.timezone import now as timezone_now
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible

def upload_to(instance, filename):
 now = timezone_now()
 filename_base, filename_ext = os.path.splitext(filename)
 return "quotes/%s%s" % (
 now.strftime("%Y/%m/%Y%m%d%H%M%S"),
 filename_ext.lower(),
 )

@python_2_unicode_compatible
class InspirationalQuote(models.Model):
    author = models.CharField(_("Author"), max_length=200)
    quote = models.TextField(_("Quote"))
    picture = models.ImageField(_("Picture"),
 upload_to=upload_to,
        blank=True,
        null=True,
    )

    class Meta:
        verbose_name = _("Inspirational Quote")
        verbose_name_plural = _("Inspirational Quotes")

    def __str__(self):
        return self.quote
```

另外，我们创建了`upload_to()`函数，将上传图片的路径设置为类似`quotes/2015/04/20150424140000.png`的路径。如您所见，我们使用日期时间戳作为文件名以确保其唯一性。我们将此函数传递到`picture`图像字段。

## 怎么做…

执行以下步骤以完成配方：

1.  创建`forms.py`文件并在那里放置一个简单的模型表单：

    ```
    # quotes/forms.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django import forms
    from .models import InspirationalQuote

    class InspirationalQuoteForm(forms.ModelForm):
        class Meta:
            model = InspirationalQuote
            fields = ["author", "quote", "picture", "language"]
    ```

2.  在`views.py`文件中，放置一个处理表单的视图。不要忘记将类似于`FILES`字典的对象传递给表单。当表单有效时，按如下方式触发保存方法：

    ```
    # quotes/views.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.shortcuts import redirect
    from django.shortcuts import render
    from .forms import InspirationalQuoteForm

    def add_quote(request):
        if request.method == "POST":
            form = InspirationalQuoteForm(
                data=request.POST,
                files=request.FILES,
            )
            if form.is_valid():
                quote = form.save()
                return redirect("add_quote_done")
        else:
            form = InspirationalQuoteForm()
        return render(request,
            "quotes/change_quote.html",
            {"form": form}
        )
    ```

3.  最后，为`templates/quotes/change_quote.html`中的视图创建一个模板。对于 HTML 表单，将`enctype`属性设置为`multipart/form-data`非常重要，否则文件上传不起作用：

    ```
    {# templates/quotes/change_quote.html #}
    {% extends "base.html" %}
    {% load i18n %}

    {% block content %}
        <form method="post" action="" enctype="multipart/form-data">
            {% csrf_token %}
            {{ form.as_p }}
            <button type="submit">{% trans "Save" %}</button>
        </form>
    {% endblock %}
    ```

## 它是如何工作的…

Django 模型表单是从模型创建的表单。它们提供了模型中的所有字段，因此您无需再次定义它们。在前面的示例中，我们为`InspirationalQuote`模型创建了一个模型表单。当我们保存表单时，表单知道如何保存数据库中的每个字段，以及如何上传文件并将其保存在媒体目录中。

## 还有更多

作为奖励，我们将看到一个如何从上传的图像生成缩略图的示例。使用此技术，您还可以生成图像的其他几个特定版本，如列表版本、移动版本和台式机版本。

我们将在`InspirationalQuote`模型（`quotes/models.py`中添加三种方法。它们是`save()`、`create_thumbnail()`和`get_thumbnail_picture_url()`。保存模型时，我们将触发缩略图的创建。当我们需要在模板中显示缩略图时，我们可以使用`{{ quote.get_thumbnail_picture_url }}`获取其 URL。方法定义如下：

```
# quotes/models.py
# …
from PIL import Image
from django.conf import settings
from django.core.files.storage import default_storage as storage
THUMBNAIL_SIZE = getattr(
    settings,
    "QUOTES_THUMBNAIL_SIZE",
    (50, 50)
)

class InspirationalQuote(models.Model):
    # …
    def save(self, *args, **kwargs):
        super(InspirationalQuote, self).save(*args, **kwargs)
        # generate thumbnail picture version
        self.create_thumbnail()

    def create_thumbnail(self):
        if not self.picture:
            return ""
        file_path = self.picture.name
        filename_base, filename_ext = os.path.splitext(file_path)
        thumbnail_file_path = "%s_thumbnail.jpg" % filename_base
        if storage.exists(thumbnail_file_path):
            # if thumbnail version exists, return its url path
            return "exists"
        try:
            # resize the original image and
            # return URL path of the thumbnail version
            f = storage.open(file_path, 'r')
            image = Image.open(f)
            width, height = image.size

            if width > height:
                delta = width - height
                left = int(delta/2)
                upper = 0
                right = height + left
                lower = height
            else:
                delta = height - width
                left = 0
                upper = int(delta/2)
                right = width
                lower = width + upper

            image = image.crop((left, upper, right, lower))
            image = image.resize(THUMBNAIL_SIZE, Image.ANTIALIAS)

            f_mob = storage.open(thumbnail_file_path, "w")
            image.save(f_mob, "JPEG")
            f_mob.close()
            return "success"
        except:
            return "error"

    def get_thumbnail_picture_url(self):
        if not self.picture:
            return ""
        file_path = self.picture.name
        filename_base, filename_ext = os.path.splitext(file_path)
        thumbnail_file_path = "%s_thumbnail.jpg" % filename_base
        if storage.exists(thumbnail_file_path):
            # if thumbnail version exists, return its URL path
            return storage.url(thumbnail_file_path)
        # return original as a fallback
        return self.picture.url
```

在前面的方法中，我们使用的是文件存储 API，而不是直接处理文件系统，因为我们可以用 Amazon S3 bucket 或其他存储服务交换默认存储，这些方法仍然有效。

如何创建缩略图？如果我们将原始文件保存为`quotes/2014/04/20140424140000.png`，我们将检查`quotes/2014/04/20140424140000_thumbnail.jpg`文件是否不存在，在这种情况下，我们将打开原始图像，从中心裁剪，将其大小调整为 50 x 50 像素，并将其保存到存储器中。

`get_thumbnail_picture_url()`方法检查存储器中是否存在缩略图版本，并返回其 URL。如果缩略图版本不存在，则返回原始图像的 URL 作为回退。

## 另见

*   *使用 django crispy forms*配方创建表单布局

# 使用 django crispy 表单创建表单布局

Doango 应用程序允许您使用以下 CSS 框架的一个 Type T3T 构建、定制和重用表单：UNI 窗体、Bootstrap 或基础。`django-crispy-forms`的用法类似于 Django 贡献的管理中的字段集；然而，它更先进，更可定制。您可以在 Python 代码中定义表单布局，而不必担心每个字段在 HTML 中的显示方式。但是，如果您需要添加特定的 HTML 属性或包装，也可以轻松地进行添加。此外，`django-crispy-forms`使用的所有标记都位于模板中，可以根据特定需要覆盖这些模板。

在这个配方中，我们将看到一个如何将`django-crispy-forms`与 Bootstrap 3 结合使用的示例，Bootstrap 3 是开发响应性、移动优先 web 项目的最流行的前端框架。

## 准备好了吗

首先，逐个执行以下任务：

从[下载引导前端框架 http://getbootstrap.com/](http://getbootstrap.com/) 并在模板中集成 CSS 和 JavaScript。在[第 4 章](04.html "Chapter 4. Templates and JavaScript")*模板和 JavaScript*中的*安排 base.html 模板*配方中了解更多信息。

使用以下命令在您的虚拟环境中安装`django-crispy-forms`：

```
(myproject_env)$ pip install django-crispy-forms

```

确认`INSTALLED_APPS`中增加了`crispy_forms`，然后将`bootstrap3`设置为本项目使用的模板包：

```
# conf/base.py or settings.py
INSTALLED_APPS = (
    # …
    "crispy_forms",
)
# …
CRISPY_TEMPLATE_PACK = "bootstrap3"
```

让我们创建一个`bulletin_board`应用来说明`django-crispy-forms`的用法，并将其放在`INSTALLED_APPS`的设置中。我们将有一个带有以下字段的`Bulletin`模型：`bulletin_type`、`title`、`description`、`contact_person`、`phone`、`email`和`image`，如下所示：

```
# bulletin_board/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible

TYPE_CHOICES = (
    ('searching', _("Searching")),
    ('offering', _("Offering")),
)

@python_2_unicode_compatible
class Bulletin(models.Model):
    bulletin_type = models.CharField(_("Type"), max_length=20, choices=TYPE_CHOICES)

    title = models.CharField(_("Title"), max_length=255)
    description = models.TextField(_("Description"),
        max_length=300)

    contact_person = models.CharField(_("Contact person"),
        max_length=255)
    phone = models.CharField(_("Phone"), max_length=200,
blank=True)
    email = models.EmailField(_("Email"), blank=True)

    image = models.ImageField(_("Image"), max_length=255,
        upload_to="bulletin_board/", blank=True)

    class Meta:
        verbose_name = _("Bulletin")
        verbose_name_plural = _("Bulletins")
        ordering = ("title",)

    def __str__(self):
        return self.title
```

## 怎么做…

遵循以下步骤：

1.  让我们为新创建的应用程序中的公告添加一个模型表单。我们将在初始化方法本身中将表单帮助器附加到表单。表单帮助器将具有 layout 属性，该属性将定义表单的布局，如下所示：

    ```
    # bulletin_board/forms.py
    # -*- coding: UTF-8 -*-
    from django import forms
    from django.utils.translation import ugettext_lazy as _,\
        ugettext
    from crispy_forms.helper import FormHelper
    from crispy_forms import layout, bootstrap
    from .models import Bulletin

    class BulletinForm(forms.ModelForm):
      class Meta:
        model = Bulletin
        fields = ["bulletin_type", "title", "description", 
        "contact_person", "phone", "email", "image"]

        def __init__(self, *args, **kwargs):
          super(BulletinForm, self).__init__(*args, **kwargs)

          self.helper = FormHelper()
          self.helper.form_action = ""
          self.helper.form_method = "POST"

          self.fields["bulletin_type"].widget = \
            forms.RadioSelect()
          # delete empty choice for the type
          del self.fields["bulletin_type"].choices[0]

          self.helper.layout = layout.Layout(
            layout.Fieldset(
              _("Main data"),
              layout.Field("bulletin_type"),
              layout.Field("title", 
                css_class="input-block-level"),
                layout.Field("description", 
                css_class="input-blocklevel",
                rows="3"),
              ),
              layout.Fieldset(
                _("Image"),
                layout.Field("image", 
                  css_class="input-block-level"),
                layout.HTML(u"""{% load i18n %}
                  <p class="help-block">{% trans "Available formats are JPG, GIF, and PNG. Minimal size is 800 × 800 px." %}</p>
                """),
                title=_("Image upload"),
                css_id="image_fieldset",
              ),
              layout.Fieldset(
                _("Contact"),
                layout.Field("contact_person",
                  css_class="input-blocklevel"),
                layout.Div(
                  bootstrap.PrependedText("phone",
                  """<span class="glyphicon glyphicon-earphone">
                  </span>""", 
                    css_class="inputblock-level"),
                  bootstrap.PrependedText("email", "@",
                    css_class="input-block-level",
                    placeholder="contact@example.com"),
                  css_id="contact_info",
                ),
              ),
              bootstrap.FormActions(
                layout.Submit("submit", _("Save")),
              )
            )
    ```

2.  要在模板中呈现表单，只需加载`crispy_forms_tags`模板标签库，使用`{% crispy %}`模板标签，如下图：

    ```
    {# templates/bulletin_board/change_form.html #}
    {% extends "base.html" %}
    {% load crispy_forms_tags %}

    {% block content %}
        {% crispy form %}
    {% endblock %}
    ```

3.  创建`base.html`模板。您可以根据[第 4 章](04.html "Chapter 4. Templates and JavaScript")中*排列 base.html 模板*配方中的示例、*模板和 JavaScript*来完成。

## 它是如何工作的…

带有公告表的页面将类似于以下内容：

![How it works…](graphics/B04912_03_01.jpg)

正如您所看到的，字段由字段集分组。`Fieldset`对象的第一个参数定义图例，其他位置参数定义字段。您还可以传递命名参数来定义字段集的 HTML 属性；例如，对于第二个字段集，我们传递`title`和`css_id`来设置`title`和`id`HTML 属性。

字段还可以具有由命名参数传递的附加属性；例如，对于`description`字段，我们传递`css_class`和`rows`来设置`class`和`rows`HTML 属性。

除了普通字段外，您还可以传递 HTML 片段，因为这是通过图像字段的帮助块完成的。布局中还可以有带前缀的文本字段。例如，我们在**电话**字段中添加了一个电话图标，在**电子邮件**字段中添加了一个`@`符号。从 contact 字段的示例中可以看到，我们可以使用`Div`对象轻松地将字段包装到 HTML`<div>`元素中。当需要将特定 JavaScript 应用于某些表单字段时，这非常有用。

HTML 表单的`action`属性由表单帮助器的`form_action`属性定义。如果将空字符串用作操作，则表单将提交到包含表单的同一视图。HTML 表单的`method`属性由表单帮助器的`form_method`属性定义。如您所知，HTML 表单允许 GET 和 POST 方法。最后，有一个`Submit`对象来呈现提交按钮，它将按钮的名称作为第一个位置参数，将按钮的值作为第二个参数。

## 还有更多…

对于基本用法，给出的示例是非常必要的。但是，如果您需要项目中表单的特定标记，您仍然可以覆盖和修改`django-crispy-forms`应用程序的模板，因为 Python 文件中没有硬编码的标记，而是通过模板呈现所有生成的标记。只需将模板从`django-crispy-forms`应用程序复制到项目的模板目录中，并根据需要进行更改。

## 另见

*   *过滤对象列出*配方
*   *管理分页列表*配方
*   *下载授权文件*配方

# 下载授权文件

有时，您可能需要只允许特定的人从您的网站下载知识产权。例如，音乐、视频、文学或其他艺术作品应该只对付费会员开放。在本教程中，您将了解如何使用提供的 Django auth 应用程序将图像下载仅限于经过身份验证的用户。

## 准备好了吗

开始时，按照*上传图片*配方创建`quotes`应用程序。

## 怎么做…

逐一执行以下步骤：

1.  创建需要验证才能下载文件的视图，如下所示：

    ```
    # quotes/views.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    import os
    from django.shortcuts import get_object_or_404
    from django.http import FileResponse
    from django.utils.text import slugify
    from django.contrib.auth.decorators import login_required
    from .models import InspirationalQuote

    @login_required(login_url="my_login_page")
    def download_quote_picture(request, quote_id):
        quote = get_object_or_404(InspirationalQuote,
            pk=quote_id)
        file_name, file_extension = os.path.splitext(
            quote.picture.file.name)
        file_extension = file_extension[1:]  # remove the dot
        response = FileResponse(
            quote.picture.file,
            content_type="image/%s" % file_extension
        )
        response["Content-Disposition"] = "attachment;" \
            " filename=%s---%s.%s" % (
            slugify(quote.author)[:100],
            slugify(quote.quote)[:100],
            file_extension
        )
        return response
    ```

2.  将视图添加到 URL 配置中：

    ```
    # quotes/urls.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.conf.urls import patterns, url

    urlpatterns = patterns("",
        # …
        url(r'^(?P<quote_id>\d+)/download/$',
            "quotes.views.download_quote_picture",
            name="download_quote_picture"
        ),
    )
    ```

3.  然后，我们需要在项目 URL 配置中设置登录视图。请注意，我们也在中为`django-crispy-forms`添加了`login_helper`：

    ```
    # myproject/urls.py
    # -*- coding: UTF-8 -*-
    from django.conf.urls import patterns, include, url
    from django.conf import settings
    from django.contrib import admin
    from django.core.urlresolvers import reverse_lazy
    from django.utils.translation import string_concat
    from django.utils.translation import ugettext_lazy as _
    from django.conf.urls.i18n import i18n_patterns
    from crispy_forms.helper import FormHelper
    from crispy_forms import layout, bootstrap

    login_helper = FormHelper()
    login_helper.form_action = reverse_lazy("my_login_page")
    login_helper.form_method = "POST"
    login_helper.form_class = "form-signin"
    login_helper.html5_required = True
    login_helper.layout = layout.Layout(
     layout.HTML(string_concat("""<h2 class="form-signin-heading">""", _("Please Sign In"), """</h2>""")),
     layout.Field("username", placeholder=_("username")),
     layout.Field("password", placeholder=_("password")),
     layout.HTML("""<input type="hidden" name="next" value="{{ next }}" />"""),
     layout.Submit("submit", _("Login"), css_class="btn-lg"),
    )

    urlpatterns = i18n_patterns("",
        # …
        url(r'login/$', "django.contrib.auth.views.login",
            {"extra_context": {"login_helper": login_helper}},
            name="my_login_page"
        ),
        url(r'^quotes/', include("quotes.urls")),
    )
    ```

4.  让我们为登录表单创建一个模板，如下所示：

    ```
    {# templates/registration/login.html #}
    {% extends "base.html" %}
    {% load crispy_forms_tags %}

    {% block stylesheet %}
        {{ block.super }}<link rel="stylesheet" href="{{ STATIC_URL }}site/css/login.css">
    {% endblock %}

    {% block content %}
        <div class="container">
            {% crispy form login_helper %}
        </div>
    {% endblock %}
    ```

5.  Create the `login.css` file to add some style to the login form. Lastly, you should restrict the users from bypassing Django and downloading restricted files directly. To do so on an Apache web server, you can put the `.htaccess` file in the `media/quotes` directory with the following content if you are using Apache 2.2:

    ```
    # media/quotes/.htaccess
    Order deny,allow
    Deny from all
    ```

    如果您使用的是 Apache 2.4，则可以放置以下内容：

    ```
    # media/quotes/.htaccess
    Require all denied
    ```

## 它是如何工作的…

`download_quote_picture()`视图将图片从一段特定的鼓舞人心的引语中流出来。设置为`attachment`的`Content-Disposition`头使文件可以下载，而不是立即显示在浏览器中。该文件的文件名类似于`walt-disney---if-you-can-dream-it-you-can-do-it.png`。如果访问者试图在未登录的情况下访问可下载文件，`@login_required`装饰程序会将其重定向到登录页面。

由于我们希望有一个很好的引导式登录表单，我们再次使用了`django-crispy-forms`，并为`login_helper`表单定义了一个助手。helper 作为一个额外的上下文变量传递给授权表单，然后用作`{% crispy %}`模板标记中的第二个参数。

根据应用的 CSS，登录表单可能类似于以下内容：

![How it works…](graphics/B04912_03_02.jpg)

## 另见

*   *上传图片*配方
*   *使用 django crispy forms*配方创建表单布局

# 过滤对象列表

在 web 开发中，除了带有表单的视图外，通常还有对象列表视图和详细视图。列表视图可以简单地列出按字母顺序或按创建日期排序的对象；然而，对于大量数据来说，这并不是非常方便用户的。为了获得最佳的可访问性和便利性，您应该能够按所有可能的类别筛选内容。在这个配方中，我们将看到用于按任意类别过滤列表视图的模式。

我们将创建一个电影列表视图，可以按类型、导演、演员或评级进行筛选。应用引导程序 3 后，其外观将类似于以下内容：

![Filtering object lists](graphics/B04912_03_03.jpg)

## 准备好了吗

对于过滤示例，我们将使用与类型、导演和演员相关的`Movie`模型进行过滤。它还可以根据评级进行过滤，即`PositiveIntegerField`选项。让我们创建`movies`应用程序，将其放入【设置】中的`INSTALLED_APPS`中，并在新应用程序中定义所提到的模型，如下所示：

```
# movies/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible

RATING_CHOICES = (
    (1, ""),
    (2, ""),
    (3, ""),
    (4, ""),
    (5, ""),
)

@python_2_unicode_compatible
class Genre(models.Model):
    title = models.CharField(_("Title"), max_length=100)

    def __str__(self):
        return self.title

@python_2_unicode_compatible
class Director(models.Model):
    first_name = models.CharField(_("First name"), max_length=40)
    last_name = models.CharField(_("Last name"), max_length=40)

    def __str__(self):
        return self.first_name + " " + self.last_name

@python_2_unicode_compatible
class Actor(models.Model):
    first_name = models.CharField(_("First name"), max_length=40)
    last_name = models.CharField(_("Last name"), max_length=40)

    def __str__(self):
        return self.first_name + " " + self.last_name

@python_2_unicode_compatible
class Movie(models.Model):
    title = models.CharField(_("Title"), max_length=255)
    genres = models.ManyToManyField(Genre, blank=True)
    directors = models.ManyToManyField(Director, blank=True)
    actors = models.ManyToManyField(Actor, blank=True)
    rating = models.PositiveIntegerField(choices=RATING_CHOICES)

    def __str__(self):
        return self.title
```

## 怎么做…

要完成配方，请执行以下步骤：

1.  首先，我们使用所有可能的类别创建`MovieFilterForm`以供筛选：

    ```
    # movies/forms.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django import forms
    from django.utils.translation import ugettext_lazy as _

    from .models import Genre, Director, Actor, RATING_CHOICES

    class MovieFilterForm(forms.Form):
        genre = forms.ModelChoiceField(
            label=_("Genre"),
            required=False,
            queryset=Genre.objects.all(),
        )
        director = forms.ModelChoiceField(
            label=_("Director"),
            required=False,
            queryset=Director.objects.all(),
        )
        actor = forms.ModelChoiceField(
            label=_("Actor"),
            required=False,
            queryset=Actor.objects.all(),
        )
        rating = forms.ChoiceField(
            label=_("Rating"),
            required=False,
            choices=RATING_CHOICES,
        )
    ```

2.  然后，我们创建一个`movie_list`视图，该视图将使用`MovieFilterForm`验证请求查询参数，并对所选类别执行过滤。请注意此处用于列出类别和当前所选选项的`facets`字典：

    ```
    # movies/views.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.shortcuts import render
    from .models import Genre, Director, Actor
    from .models import Movie, RATING_CHOICES
    from .forms import MovieFilterForm

    def movie_list(request):
        qs = Movie.objects.order_by("title")

        form = MovieFilterForm(data=request.GET)

     facets = {
     "selected": {},
     "categories": {
     "genres": Genre.objects.all(),
     "directors": Director.objects.all(),
     "actors": Actor.objects.all(),
     "ratings": RATING_CHOICES,
     },
     }

        if form.is_valid():
            genre = form.cleaned_data["genre"]
            if genre:
                facets["selected"]["genre"] = genre
                qs = qs.filter(genres=genre).distinct()

            director = form.cleaned_data["director"]
            if director:
                facets["selected"]["director"] = director
                qs = qs.filter(directors=director).distinct()

            actor = form.cleaned_data["actor"]
            if actor:
                facets["selected"]["actor"] = actor
                qs = qs.filter(actors=actor).distinct()

            rating = form.cleaned_data["rating"]
            if rating:
                rating = int(rating)
                facets["selected"]["rating"] = (rating, dict(RATING_CHOICES)[rating])
                qs = qs.filter(rating=rating).distinct()

        # Let's inspect the facets in the console
        if settings.DEBUG:
            from pprint import pprint
            pprint(facets)

        context = {
            "form": form,
            "facets": facets,
            "object_list": qs,
        }
        return render(request, "movies/movie_list.html",
            context)
    ```

3.  最后，我们为列表视图创建模板。我们将在此处使用`facets`字典列出类别，并知道当前选择的类别。为了生成过滤器的 URL，我们将使用`{% modify_query %}`模板标签，这将在[第 5 章](05.html "Chapter 5. Custom Template Filters and Tags")*自定义模板过滤器和标签*中的*创建模板标签来修改请求查询参数*配方中描述。在`templates/movies/movie_list.html`目录中复制以下代码：

    ```
    {# templates/movies/movie_list.html #}
    {% extends "base_two_columns.html" %}
    {% load i18n utility_tags %}

    {% block sidebar %}
    <div class="filters panel-group" id="accordion">
        <div class="panel panel-default">
            <div class="panel-heading">
                <h6 class="panel-title">
                    <a data-toggle="collapse" data-parent="#accordion" href="#collapseGenres">
                        {% trans "Filter by Genre" %}
                    </a>
                </h6>
            </div>
            <div id="collapseGenres" class="panel-collapse collapse in">
                <div class="panel-body">
                    <div class="list-group">
                        <a class="list-group-item{% if not facets.selected.genre %} active{% endif %}" href="{% modify_query "genre" "page" %}">{% trans "All" %}</a>
                        {% for cat in facets.categories.genres %}
                            <a class="list-group-item{% if facets.selected.genre == cat %} active{% endif %}" href="{% modify_query "page" genre=cat.pk %}">{{ cat }}</a>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <div class="panel panel-default">
            <div class="panel-heading">
                <h6 class="panel-title">
                    <a data-toggle="collapse" data-parent="#accordion" href="#collapseDirectors">
                        {% trans "Filter by Director" %}
                    </a>
                </h6>
            </div>
            <div id="collapseDirectors" class="panel-collapse collapse">
                <div class="panel-body">
                    <div class="list-group">
                        <a class="list-group-item{% if not facets.selected.director %} active{% endif %}" href="{% modify_query "director" "page" %}">{% trans "All" %}</a>
                        {% for cat in facets.categories.directors %}
                            <a class="list-group-item{% if facets.selected.director == cat %} active{% endif %}" href="{% modify_query "page" director=cat.pk %}">{{ cat }}</a>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        {# Analogously by the examples of genres and directors above, add a filter for actors here… #}

        <div class="panel panel-default">
            <div class="panel-heading">
                <h6 class="panel-title">
                    <a data-toggle="collapse" data-parent="#accordion" href="#collapseRatings">
                        {% trans "Filter by Rating" %}
                    </a>
                </h6>
            </div>
            <div id="collapseRatings" class="panel-collapse collapse">
                <div class="panel-body">
                    <div class="list-group">
                        <a class="list-group-item{% if not facets.selected.rating %} active{% endif %}" href="{% modify_query "rating" "page" %}">{% trans "All" %}</a>
                        {% for r_val, r_display in facets.categories.ratings %}
                            <a class="list-group-item{% if facets.selected.rating.0 == r_val %} active{% endif %}" href="{% modify_query "page" rating=r_val %}">{{ r_display }}</a>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
    {% endblock %}

    {% block content %}
    <div class="movie_list">
        {% for movie in object_list %}
            <div class="movie alert alert-info">
                <p>{{ movie.title }}</p>
            </div>
        {% endfor %}
    </div>
    {% endblock %}
    ```

4.  增加一个双柱布局的简易基础模板，如下图：

    ```
    {# base_two_columns.html #}
    {% extends "base.html" %}

    {% block container %}
        <div class="container">
            <div class="row">
                <div id="sidebar" class="col-md-4">
                    {% block sidebar %}
                    {% endblock %}
                </div>
                <div id="content" class="col-md-8">
                    {% block content %}
                    {% endblock %}
                </div>
            </div>
        </div>
    {% endblock %}
    ```

5.  创建`base.html`模板。您可以根据[第 4 章](04.html "Chapter 4. Templates and JavaScript")*排列 base.html 模板*配方、*模板和 JavaScript*中提供的示例进行操作。

## 它是如何工作的…

我们正在使用facets 字典，该字典被传递到模板上下文，以了解我们拥有哪些过滤器以及选择了哪些过滤器。更深入地看，`facets`字典由两部分组成：`categories`字典和`selected`字典。`categories`字典包含`QuerySets`或所有可过滤类别的选择。`selected`字典包含每个类别当前选择的值。

在视图中，我们检查表单中的查询参数是否有效，然后从所选类别中向下钻取`QuerySet`个对象。此外，我们将所选值设置到`facets`字典，该字典将被传递到模板。

在模板中，对于`facets`字典中的每个分类，我们列出所有类别，并将当前选择的类别标记为活动类别。

就这么简单。

## 另见

*   *管理分页列表*配方
*   *组合基于类的视图*配方
*   *创建模板标签修改[第 5 章](05.html "Chapter 5. Custom Template Filters and Tags")中的请求查询参数*配方*自定义模板过滤器和标签*

# 管理分页列表

如果您有动态变化的对象列表，或者对象的数量大于 30，那么您肯定需要对列表进行分页。使用分页，而不是完整的`QuerySet`，您可以提供数据集的一小部分，该数据集限制在每页的特定数量，并且您还可以显示链接以访问列表的其他页面。Django 拥有管理分页数据的类，我们将在本配方中看到如何在前面配方中提供的示例中实现这一点。

## 准备好了吗

让我们从*过滤对象列表*配方中的`movies`应用程序的表单和视图开始。

## 怎么做…

要将分页添加到电影列表视图，请执行以下步骤：

1.  首先，从 Django 导入必要的分页类。过滤之后，我们将在`movie_list`视图中添加分页管理。此外，我们将通过将`page`而不是电影查询集分配给对象列表键

    ```
    # movies/views.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.shortcuts import render
    from django.core.paginator import Paginator, EmptyPage,\
        PageNotAnInteger

    from .models import Movie
    from .forms import MovieFilterForm

    def movie_list(request):
     paginate_by = 15
        qs = Movie.objects.order_by("title")
        # … filtering goes here…

     paginator = Paginator(qs, paginate_by)

     page_number = request.GET.get("page")
     try:
     page = paginator.page(page_number)
     except PageNotAnInteger:
     # If page is not an integer, show first page.
     page = paginator.page(1)
     except EmptyPage:
     # If page is out of range, show last existing page.
     page = paginator.page(paginator.num_pages)

        context = {
            # …
            "object_list": page,
        }
        return render(request, "movies/movie_list.html", context)
    ```

    来稍微修改上下文字典
2.  在模板中，我们将在电影列表后添加分页控件，如下所示：

    ```
    {# templates/movies/movie_list.html #}
    {% extends "base.html" %}
    {% load i18n utility_tags %}

    {% block sidebar %}
        {# … filters go here… #}
    {% endblock %}

    {% block content %}
    <div class="movie_list">
        {% for movie in object_list %}
            <div class="movie alert alert-info">
                <p>{{ movie.title }}</p>
            </div>
        {% endfor %}
    </div>

    {% if object_list.has_other_pages %}
        <ul class="pagination">
            {% if object_list.has_previous %}
                <li><a href="{% modify_query page=object_list.previous_page_number %}">&laquo;</a></li>
            {% else %}
                <li class="disabled"><span>&laquo;</span></li>
            {% endif %}
            {% for page_number in object_list.paginator.page_range %}
                {% if page_number == object_list.number %}
                    <li class="active">
                        <span>{{ page_number }} <span class="sr-only">(current)</span></span>
                    </li>
                {% else %}
                    <li>
                        <a href="{% modify_query page=page_number %}">{{ page_number }}</a>
                    </li>
                {% endif %}
            {% endfor %}
            {% if object_list.has_next %}
                <li><a href="{% modify_query page=object_list.next_page_number %}">&raquo;</a></li>
            {% else %}
                <li class="disabled"><span>&raquo;</span></li>
            {% endif %}
        </ul>
    {% endif %}
    {% endblock %}
    ```

## 它是如何工作的…

在浏览器中查看结果时，您将看到类似于以下内容的分页控件，添加在电影列表之后：

![How it works…](graphics/B04912_03_04.jpg)

我们如何实现这一点？当`QuerySet`被过滤掉后，我们将创建一个通过`QuerySet`的`paginator`对象，以及我们希望每页显示的最大项目数，这里是 15。然后，我们将从查询参数`page`中读取当前页码。下一步是从`paginator`中检索当前页面对象。如果页码不是整数，我们得到第一页。如果数量超过可能的页数，则检索最后一页。页面对象具有前面屏幕截图中显示的分页小部件所需的方法和属性。此外，page 对象的行为类似于`QuerySet`，因此我们可以对其进行迭代，并从页面的分数中获取项目。

模板中标记的代码段为 Bootstrap 3 前端框架创建了一个带有标记的分页小部件。仅当页面数大于当前页面数时，才会显示分页控件。我们有上一页和下一页的链接，以及小部件中所有页码的列表。当前页码标记为活动。为了生成链接的 URL，我们使用`{% modify_query %}`模板标签，这将在[第 5 章](05.html "Chapter 5. Custom Template Filters and Tags")中的*创建模板标签来修改请求查询参数*配方、*自定义模板过滤器和标签*中描述。

## 另见

*   *过滤对象列出*配方
*   *组合基于类的视图*配方
*   *创建模板标签修改[第 5 章](05.html "Chapter 5. Custom Template Filters and Tags")中的请求查询参数*配方*自定义模板过滤器和标签*

# 构建基于类的视图

Django 视图是接受请求并返回响应的可调用对象。除了基于函数的视图外，Django 还提供了一种将视图定义为类的替代方法。当您想要创建可重用的模块化视图或组合通用混合视图时，这种方法非常有用。在此配方中，我们将把前面显示的基于函数的`movie_list`视图转换为基于类的`MovieListView`视图。

## 准备好了吗

创建与前面的配方类似的模型、表单和模板，*过滤对象列表*和*管理分页列表*。

## 怎么做…

1.  我们需要在 URL 配置中创建一个 URL 规则，并添加一个基于类的视图。为了在 URL 规则中包含基于类的视图，使用了`as_view()`方法，如下所示：

    ```
    # movies/urls.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.conf.urls import patterns, url
    from .views import MovieListView
    urlpatterns = patterns("",
        url(r'^$', MovieListView.as_view(), name="movie_list"),
    )
    ```

2.  我们基于类的视图`MovieListView`将继承 Django`View`类并覆盖`get()`和`post()`方法，这两个方法用于区分 GET 和 POST 的请求。我们还将添加`get_queryset_and_facets()`和`get_page()`方法，使类更加模块化：

    ```
    # movies/views.py
    # -*- coding: UTF-8 -*-
    from django.shortcuts import render
    from django.core.paginator import Paginator, EmptyPage,\
        PageNotAnInteger
    from django.views.generic import View

    from .models import Genre
    from .models import Director
    from .models import Actor
    from .models import Movie, RATING_CHOICES
    from .forms import MovieFilterForm

    class MovieListView(View):
        form_class = MovieFilterForm
        template_name = "movies/movie_list.html"
        paginate_by = 15

        def get(self, request, *args, **kwargs):
            form = self.form_class(data=request.GET)
            qs, facets = self.get_queryset_and_facets(form)
            page = self.get_page(request, qs)
            context = {
                "form": form,
                "facets": facets,
                "object_list": page,
            }
            return render(request, self.template_name, context)

        def post(self, request, *args, **kwargs):
            return self.get(request, *args, **kwargs)

        def get_queryset_and_facets(self, form):
            qs = Movie.objects.order_by("title")

            facets = {
                "selected": {},
                "categories": {
                    "genres": Genre.objects.all(),
                    "directors": Director.objects.all(),
                    "actors": Actor.objects.all(),
                    "ratings": RATING_CHOICES,
                },
            }
            if form.is_valid():
                genre = form.cleaned_data["genre"]
                if genre:
                    facets["selected"]["genre"] = genre
                    qs = qs.filter(genres=genre).distinct()

                director = form.cleaned_data["director"]
                if director:
                    facets["selected"]["director"] = director
                    qs = qs.filter(
                        directors=director,
                    ).distinct()

                actor = form.cleaned_data["actor"]
                if actor:
                    facets["selected"]["actor"] = actor
                    qs = qs.filter(actors=actor).distinct()

                rating = form.cleaned_data["rating"]
                if rating:
                    facets["selected"]["rating"] = (
                        int(rating),
                        dict(RATING_CHOICES)[int(rating)]
                    )
                    qs = qs.filter(rating=rating).distinct()
            return qs, facets

        def get_page(self, request, qs):
            paginator = Paginator(qs, self.paginate_by)

            page_number = request.GET.get("page")
            try:
                page = paginator.page(page_number)
            except PageNotAnInteger:
                # If page is not an integer, show first page.
                page = paginator.page(1)
            except EmptyPage:
                # If page is out of range,
                # show last existing page.
                page = paginator.page(paginator.num_pages)
            return page
    ```

## 它是如何工作的…

以下是`get()`方法中发生的事情：

首先，我们创建`form`对象，将类似于`GET`字典的对象传递给它。`GET`对象包含使用`GET`方法传递的所有查询变量。

然后，`form`被传递给`get_queryset_and_facets()`方法，该方法返回以下两个元素的元组：`QuerySet`和`facets`字典。

然后，将当前的`request`对象和`QuerySet`传递给`get_page()`方法，该方法返回当前页面对象。

最后，我们创建一个上下文字典并呈现响应。

## 还有更多…

如您所见，`get()`、`post()`和`get_page()`方法是泛型的，因此我们可以在`utils`应用程序中使用这些方法创建泛型`FilterableListView`类。然后，在任何需要可过滤列表的应用程序中，我们可以创建一个基于类的视图，该视图扩展`FilterableListView`并仅定义`form_class`和`template_name`属性以及`get_queryset_and_facets()`方法。这就是基于类的视图的工作方式。

## 另见

*   *过滤对象列出*配方
*   *管理分页列表*配方

# 生成 PDF 文档

Django 视图允许您创建的不仅仅是 HTML 页面。您可以生成任何类型的文件。例如，您可以为发票、票据、预订确认等创建 PDF 文档。在本食谱中，我们将向您展示如何从数据库的数据中生成 PDF 格式的简历（简历）。我们将使用 Pisa xhtml2pdf 库，它非常实用，因为它允许您使用 HTML 模板制作 PDF 文档。

## 准备好了吗

首先，我们需要在您的虚拟环境中安装 xhtml2pdf Python 库：

```
(myproject_env)$ pip install xhtml2pdf

```

然后，让我们创建一个`cv`应用程序，其中包含一个简单的`CV`模型和`Experience`模型，该模型通过外键连接到它。`CV`模型将包含以下字段：名字、姓氏和电子邮件。`Experience`模型将包含以下字段：工作开始日期、工作结束日期、公司、该公司的职位以及获得的技能：

```
# cv/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible

@python_2_unicode_compatible
class CV(models.Model):
    first_name = models.CharField(_("First name"), max_length=40)
    last_name = models.CharField(_("Last name"), max_length=40)
    email = models.EmailField(_("Email"))

    def __str__(self):
        return self.first_name + " " + self.last_name

@python_2_unicode_compatible
class Experience(models.Model):
    cv = models.ForeignKey(CV)
    from_date = models.DateField(_("From"))
    till_date = models.DateField(_("Till"), null=True, blank=True)
    company = models.CharField(_("Company"), max_length=100)
    position = models.CharField(_("Position"), max_length=100)
    skills = models.TextField(_("Skills gained"), blank=True)

    def __str__(self):
        till = _("present")
        if self.till_date:
            till = self.till_date.strftime("%m/%Y")
        return _("%(from)s-%(till)s %(pos)s at %(company)s") % {
            "from": self.from_date.strftime("%m/%Y"),
            "till": till,
            "pos": self.position,
            "company": self.company,
        }
    class Meta:
        ordering = ("-from_date",)
```

## 怎么做…

执行以下步骤完成配方：

1.  在 URL 规则中，让我们为视图创建一个规则，该视图将根据`CV`模型的 ID 下载简历的 PDF 文档，如下所示：

    ```
    # cv/urls.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.conf.urls import patterns, url

    urlpatterns = patterns('cv.views',
        url(r'^(?P<cv_id>\d+)/pdf/$', "download_cv_pdf", name="download_cv_pdf"),
    )
    ```

2.  现在，让我们创建`download_cv_pdf()`视图。此视图呈现 HTML 模板，然后将呈现的字符串传递给`pisaDocument`PDF 创建者：

    ```
    # cv/views.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    try:
        from cStringIO import StringIO
    except ImportError:
        from StringIO import StringIO
    from xhtml2pdf import pisa

    from django.conf import settings
    from django.shortcuts import get_object_or_404
    from django.template.loader import render_to_string
    from django.http import HttpResponse

    from .models import CV

    def download_cv_pdf(request, cv_id):
        cv = get_object_or_404(CV, pk=cv_id)

        response = HttpResponse(content_type="application/pdf")
        response["Content-Disposition"] = "attachment; "\
            "filename=%s_%s.pdf" % (
                cv.first_name,
                cv.last_name
            )

        html = render_to_string("cv/cv_pdf.html", {
            "cv": cv,
            "MEDIA_ROOT": settings.MEDIA_ROOT,
            "STATIC_ROOT": settings.STATIC_ROOT,
        })
        pdf = pisa.pisaDocument(
            StringIO(html.encode("UTF-8")),
            response,
            encoding="UTF-8",
        )
        return response
    ```

3.  最后，我们将创建用于呈现文档的模板，如下所示：

    ```
    {# templates/cv/cv_pdf.html #}
    <!DOCTYPE HTML>
    <html>
      <head>
        <meta charset="utf-8" />
        <title>My Title</title>
        <style type="text/css">
          @page {
            size: "A4";
            margin: 2.5cm 1.5cm 2.5cm 1.5cm;
            @frame footer {
              -pdf-frame-content: footerContent;
              bottom: 0cm;
              margin-left: 0cm;
              margin-right: 0cm;
              height: 1cm;
            }
          }
          #footerContent {
            color: #666;
            font-size: 10pt;
            text-align: center;
          }
          /* … Other CSS Rules go here … */

        </style>
      </head>
      <body>
        <div>
          <h1>Curriculum Vitae</h1>
          <table>
            <tr>
              <td><p><b>{{ cv.first_name }} {{ cv.last_name }}</b><br />
                Contact: {{ cv.email }}</p>
              </td>
              <td align="right">
                <img src="{{ STATIC_ROOT }}/site/img/smiley.jpg" width="100" height="100" />
              </td>
            </tr>
          </table>

          <h2>Experience</h2>
            <table>
              {% for experience in cv.experience_set.all %}
                <tr>
                  <td valign="top"><p>{{ experience.from_date|date:"F Y" }} -
                    {% if experience.till_date %}
                    {{ experience.till_date|date:"F Y" }}
                    {% else %}
                    present
                    {% endif %}<br />
                    {{ experience.position }} at {{ experience.company }}</p>
                  </td>
                  <td valign="top"><p><b>Skills gained</b><br>
                    {{ experience.skills|linebreaksbr }}
                    <br>
                    <br>
                  </p>
                  </td>
                </tr>
              {% endfor %}
            </table>
        </div>
        <pdf:nextpage>
          <div>
            This is an empty page to make a paper plane.
          </div>
          <div id="footerContent">
            Document generated at {% now "Y-m-d" %} |
            Page <pdf:pagenumber> of <pdf:pagecount>
          </div>
      </body>
    </html>
    ```

## 它是如何工作的…

转到模型管理并输入简历文档。然后，如果您在`http://127.0.0.1:8000/en/cv/1/pdf/`访问文档的 URL，您将被要求下载一个类似以下内容的 PDF 文档：

![How it works…](graphics/B04912_03_05.jpg)

视图是如何工作的？首先，我们根据简历 ID 加载它（如果它存在），或者引发页面未找到错误（如果它不存在）。然后，我们使用 PDF 文档的内容类型创建响应对象。我们使用指定的文件名将`Content-Disposition`头设置为`attachment`。这将迫使浏览器打开一个对话框，提示我们保存 PDF 文档并建议文件的指定名称。然后，我们将 HTML 模板呈现为一个字符串，传递简历对象和`MEDIA_ROOT`和`STATIC_ROOT`路径。

### 注

请注意，用于创建 PDF 的`<img>`标记的`src`属性需要指向文件系统中的文件或在线图像的完整 URL。Pisa xhtml2pdf 将下载图像并将其包含在 PDF 文档中。

然后，我们以 UTF-8 编码的 HTML 作为源，响应对象作为目标，创建一个`pisaDocument`文件。响应对象是一个类似文件的对象，`pisaDocument`将文档内容写入其中。响应对象按预期由视图返回。

让我们来看看用于创建这个文档的 HTML 模板。该模板有一些不寻常的标记和 CSS 规则。如果我们想在文档的每个页面上都有一些元素，我们可以为此创建 CSS 框架。在前面的示例中，带有`footerContent`ID 的`<div>`标记被标记为一个框架，该框架将在每页的底部重复。以类似的方式，我们可以为每个页面设置标题或背景图像。

以下是本文档中使用的特定标记：

*   `<pdf:nextpage>`标记设置手动分页符
*   `<pdf:pagenumber>`标记返回当前页面的编号
*   `<pdf:pagecount>`标记返回总页数

Pisa xhtml2pdf 库的当前版本 0.0.6 并不完全支持所有 HTML 标记和 CSS 规则。没有可公开访问的基准来查看究竟支持什么以及在什么级别上支持什么。因此，您需要进行实验，以使 PDF 文档看起来像设计要求中的文档。然而，这个库对于定制的布局仍然足够强大，基本上只需要了解 HTML 和 CSS 就可以创建定制的布局。

## 另见

*   *管理分页列表*配方
*   *下载授权文件*配方

# 用 Haystack 实现多语种搜索

内容驱动网站的主要功能之一是全文搜索。Haystack 是一个模块化搜索 API，支持Solr、Elasticsearch、Whoosh 和 Xapian 搜索引擎。对于项目中必须在搜索中查找的每个模型，您需要定义一个索引，该索引将从模型中读取文本信息并将其放入后端。在本教程中，您将学习如何使用 Haystack 和基于 Python 的 Whoosh 搜索引擎为多语言网站设置搜索。

## 准备好了吗

首先，让我们创建几个应用程序，其中的模型将在搜索中被索引。让我们创建一个包含`Category`和`Idea`模型的`ideas`应用程序，如下所示：

```
# ideas/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.core.urlresolvers import reverse
from django.core.urlresolvers import NoReverseMatch
from django.utils.encoding import python_2_unicode_compatible
from utils.models import UrlMixin
from utils.fields import MultilingualCharField, MultilingualTextField

@python_2_unicode_compatible
class Category(models.Model):
    title = MultilingualCharField(_("Title"), max_length=200)

    class Meta:
        verbose_name = _("Idea Category")
        verbose_name_plural = _("Idea Categories")

    def __str__(self):
        return self.title

@python_2_unicode_compatible
class Idea(UrlMixin):
    title = MultilingualCharField(_("Title"), max_length=200)
    subtitle = MultilingualCharField(_("Subtitle"), max_length=200, blank=True)
    description = MultilingualTextField(_("Description"),
        blank=True)
    is_original = models.BooleanField(_("Original"))
    categories = models.ManyToManyField(Category,
        verbose_name=_("Categories"), blank=True,
        related_name="ideas")

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title

    def get_url_path(self):
        try:
            return reverse("idea_detail", kwargs={"id": self.pk})
        except NoReverseMatch:
            return ""
```

`Idea`模型有多语言字段，这意味着每种语言都应该有内容的翻译。

另一个应用程序将是中的*上传图片*配方中的`quotes`和`InspirationalQuote`模型，其中每个引用只能使用`settings.LANGUAGES`中定义的语言中的任意一种语言，并且每个引用不必有翻译：

```
# quotes/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import os
from django.db import models
from django.utils.timezone import now as timezone_now
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible
from django.conf import settings
from django.core.urlresolvers import reverse
from django.core.urlresolvers import NoReverseMatch

from utils.models import UrlMixin

def upload_to(instance, filename):
    now = timezone_now()
    filename_base, filename_ext = os.path.splitext(filename)
    return 'quotes/%s%s' % (
        now.strftime("%Y/%m/%Y%m%d%H%M%S"),
        filename_ext.lower(),
    )

@python_2_unicode_compatible
class InspirationalQuote(UrlMixin):
    author = models.CharField(_("Author"), max_length=200)
    quote = models.TextField(_("Quote"))
    picture = models.ImageField(_("Picture"), upload_to=upload_to,
        blank=True, null=True)
    language = models.CharField(_("Language"), max_length=2,
        blank=True, choices=settings.LANGUAGES)

    class Meta:
        verbose_name = _("Inspirational Quote")
        verbose_name_plural = _("Inspirational Quotes")

    def __str__(self):
        return self.quote

    def get_url_path(self):
        try:
            return reverse("quote_detail", kwargs={"id": self.pk})
        except NoReverseMatch:
            return ""
    # …
    def title(self):
        return self.quote
```

在【设置】中将这两个应用放在`INSTALLED_APPS`中，创建并应用数据库迁移，并为这些模型创建模型管理，以添加一些数据。另外，为这些模型创建列表和详细视图，并将它们插入 URL 规则。如果您在这些任务中遇到任何困难，请再次熟悉官方 Django 教程中的概念：[https://docs.djangoproject.com/en/1.8/intro/tutorial01/](https://docs.djangoproject.com/en/1.8/intro/tutorial01/) 。

确保在虚拟环境中安装了 django haystack、whoosh 和 django crispy 表单：

```
(myproject_env)$ pip install django-crispy-forms
(myproject_env)$ pip install django-haystack
(myproject_env)$ pip install whoosh

```

## 怎么做…

让我们通过执行以下步骤，使用 Haystack 和 Whoosh 设置多语言搜索：

1.  创建一个`search`应用程序，其中将包含`MultilingualWhooshEngine`和我们的想法和引用的搜索索引。搜索引擎将驻留在`multilingual_whoosh_backend.py`文件中：

    ```
    # search/multilingual_whoosh_backend.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.conf import settings
    from django.utils import translation
    from haystack.backends.whoosh_backend import \
        WhooshSearchBackend, WhooshSearchQuery, WhooshEngine
    from haystack import connections
    from haystack.constants import DEFAULT_ALIAS

    class MultilingualWhooshSearchBackend(WhooshSearchBackend):
        def update(self, index, iterable, commit=True,
            language_specific=False):
            if not language_specific and \
            self.connection_alias == "default":
                current_language = (translation.get_language()
                    or settings.LANGUAGE_CODE)[:2]
                for lang_code, lang_name in settings.LANGUAGES:
                    using = "default_%s" % lang_code
                    translation.activate(lang_code)
                    backend = connections[using].get_backend()
                    backend.update(index, iterable, commit,
                        language_specific=True)
                translation.activate(current_language)
            elif language_specific:
                super(MultilingualWhooshSearchBackend, self).\
                    update(index, iterable, commit)

    class MultilingualWhooshSearchQuery(WhooshSearchQuery):
        def __init__(self, using=DEFAULT_ALIAS):
            lang_code = translation.get_language()[:2]
            using = "default_%s" % lang_code
            super(MultilingualWhooshSearchQuery, self).\
                __init__(using)

    class MultilingualWhooshEngine(WhooshEngine):
        backend = MultilingualWhooshSearchBackend
        query = MultilingualWhooshSearchQuery
    ```

2.  然后，让我们创建搜索索引，如下所示：

    ```
    # search/search_indexes.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.conf import settings
    from django.utils.translation import get_language
    from haystack import indexes
    from ideas.models import Idea
    from quotes.models import InspirationalQuote

    class IdeaIndex(indexes.SearchIndex, indexes.Indexable):
        text = indexes.CharField(document=True)

        def get_model(self):
            return Idea

        def index_queryset(self, using=None):
            """Used when the entire index for model
                is updated."""
            return self.get_model().objects.all()

        def prepare_text(self, obj):
            # this will be called for each language / backend
            return "\n".join((
                obj.title,
                obj.subtitle,
                obj.description,
                "\n".join([cat.title
                    for cat in obj.categories.all()
                ]),
            ))

    class InspirationalQuoteIndex(indexes.SearchIndex,
        indexes.Indexable):
        text = indexes.CharField(document=True)

        def get_model(self):
            return InspirationalQuote

        def index_queryset(self, using=None):
            """Used when the entire index for model
                is updated."""
            if using and using != "default":
                lang_code = using.replace("default_", "")
            else:
                lang_code = settings.LANGUAGE_CODE[:2]
            return self.get_model().objects.filter(language=lang_code)

        def prepare_text(self, obj):
            # this will be called for each language / backend
            return "\n".join((
                obj.author,
                obj.quote,
            ))
    ```

3.  稍后，将设置配置为使用我们的`MultilingualWhooshEngine`：

    ```
    INSTALLED_APPS = (
        # …
        # third party
        "crispy_forms",
        "haystack",
        # project-specific
        "quotes",
        "utils",
        "ideas",
        "search",
    )
    LANGUAGE_CODE = "en"
    LANGUAGES = (
        ("en", "English"),
        ("de", "Deutsch"),
        ("fr", "Français"),
        ("lt", "Lietuvių kalba"),
    )
    CRISPY_TEMPLATE_PACK = "bootstrap3"
    HAYSTACK_CONNECTIONS = {
        "default": {
            "ENGINE": "search.multilingual_whoosh_backend."\
                "MultilingualWhooshEngine",
            "PATH": os.path.join(PROJECT_PATH, "myproject",
                "tmp", "whoosh_index_en"),
        },
        "default_en": {
            "ENGINE": "search.multilingual_whoosh_backend."\
                "MultilingualWhooshEngine",
            "PATH": os.path.join(PROJECT_PATH, "myproject",
                "tmp", "whoosh_index_en"),
        },
        "default_de": {
            "ENGINE": "search.multilingual_whoosh_backend."\
                "MultilingualWhooshEngine",
            "PATH": os.path.join(PROJECT_PATH, "myproject",
                "tmp", "whoosh_index_de"),
        },
        "default_fr": {
            "ENGINE": "search.multilingual_whoosh_backend."\
                "MultilingualWhooshEngine",
            "PATH": os.path.join(PROJECT_PATH, "myproject",
                "tmp", "whoosh_index_fr"),
        },
        "default_lt": {
            "ENGINE": "search.multilingual_whoosh_backend."\
                "MultilingualWhooshEngine",
            "PATH": os.path.join(PROJECT_PATH, "myproject",
                "tmp", "whoosh_index_lt"),
        },
    }
    ```

4.  现在我们需要定义搜索视图的 URL 规则：

    ```
    # myproject/urls.py
    # -*- coding: UTF-8 -*-
    from django.conf.urls import patterns, include, url
    from django.core.urlresolvers import reverse_lazy
    from django.utils.translation import string_concat
    from django.utils.translation import ugettext_lazy as _
    from django.conf.urls.i18n import i18n_patterns

    from crispy_forms.helper import FormHelper
    from crispy_forms import layout, bootstrap
    from haystack.views import SearchView

    class CrispySearchView(SearchView):
        def extra_context(self):
            helper = FormHelper()
            helper.form_tag = False
            helper.disable_csrf = True
            return {"search_helper": helper}

    urlpatterns = i18n_patterns('',
        # …
        url(r'^search/$', CrispySearchView(),
            name='haystack_search'),
        # …
    )
    ```

5.  然后这里是搜索表单和搜索结果的模板，如下图所示：

    ```
    {# templates/search/search.html #}
    {% extends "base.html" %}
    {% load i18n crispy_forms_tags utility_tags %}

    {% block content %}
        <h2>{% trans "Search" %}</h2>
        <form method="get" action="{{ request.path }}">
            <div class="well clearfix">
                {% crispy form search_helper %}
                <p class="pull-right">
                    <input class="btn btn-primary" type="submit" value="Search">
                </p>
            </div>
        </form>

        {% if query %}
            <h3>{% trans "Results" %}</h3>

            {% for result in page.object_list %}
                <p>
                    <a href="{{ result.object.get_url_path }}">
                        {{ result.object.title }}
                    </a>
                </p>
            {% empty %}
                <p>{% trans "No results found." %}</p>
            {% endfor %}

            {% if page.has_previous or page.has_next %}
                <nav>
                    <ul class="pager">
                        <li class="previous">
                            {% if page.has_previous %}<a href="{% modify_query page=page.previous_page_number %}">{% endif %}
                                <span aria-hidden="true">&laquo;</span>
                            {% if page.has_previous %}</a>{% endif %}
                        </li>
                        <li class="next">
                            {% if page.has_next %}<a href="{% modify_query page=page.next_page_number %}">{% endif %}
                                <span aria-hidden="true">&raquo;</span>
                            {% if page.has_next %}</a>{% endif %}
                        </li>
                    </ul>
                </nav>
            {% endif %}
        {% endif %}
    {% endblock %}
    ```

6.  调用`rebuild_index`管理命令，对数据库数据进行索引，并准备要使用的全文搜索：

    ```
    (myproject_env)$ python manage.py rebuild_index --noinput

    ```

## 它是如何工作的…

`MultilingualWhooshEngine`指定了两个自定义属性：后端和查询。自定义的`MultilingualWhooshSearchBackend`后端确保，对于每种语言，项将仅以该语言进行索引，并置于`HAYSTACK_CONNECTIONS`设置中定义的特定`Haystack`索引位置下。`MultilingualWhooshSearchQuery`自定义查询确保搜索关键字时使用当前语言的特定 Haystack 连接。

每个索引都有一个字段`text`，其中将存储来自模型特定语言的全文。索引的模型由`get_model()`方法定义，`QuerySet`到索引由`index_queryset()`方法定义，要搜索的文本由`prepare_text()`方法收集。

因为我们想要一个好的 bootstrap3 表单，所以我们将把`FormHelper`从`django-crispy-forms`传递到搜索视图。我们可以通过覆盖`SearchView`的`extra_context()`方法来实现这一点。最终搜索表单将类似于以下内容：

![How it works…](graphics/B04912_03_06.jpg)

定期更新搜索索引的最简单方法是每晚通过 cron 作业调用`rebuild_index`管理命令。要了解它，请查看[第 11 章](11.html "Chapter 11. Testing and Deployment")、*测试和部署*中的*为常规任务设置 cron 作业*配方。

## 另见

*   *用 django crispy forms*配方创建表单布局
*   *下载授权文件*配方
*   [第 11 章](11.html "Chapter 11. Testing and Deployment")*测试和部署*中的*为常规任务设置 cron 作业*配方