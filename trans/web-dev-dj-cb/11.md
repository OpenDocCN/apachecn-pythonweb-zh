# 第 11 章测试和部署

在本章中，我们将介绍以下配方：

*   使用 Selenium 测试页面
*   使用 mock 测试视图
*   测试使用 Django REST 框架创建的 API
*   发布可重用的 Django 应用程序
*   通过电子邮件获取详细的错误报告
*   使用 mod_wsgi 在 Apache 上部署
*   为常规任务设置 cron 作业
*   创建和使用结构部署脚本

# 导言

在这一点上，我希望你有一个或多个 Django 项目或可重用的应用程序开发，并准备向公众展示。对于开发周期的最后步骤，我们将了解如何测试您的项目、向其他人分发可重用的应用程序以及在远程服务器上发布您的网站。请继续关注最后的片段！

# 硒测试页面

Django 提供为您的网站编写测试套件的可能性。测试套件会自动检查您的网站或其组件，以查看是否一切正常。当您修改代码时，可以运行测试来检查更改是否以错误的方式影响应用程序的行为。自动化软件测试的世界可以分为五个层次：单元测试、集成测试、组件接口测试、系统测试和操作验收测试。验收测试检查业务逻辑，以了解项目是否按预期方式工作。在本教程中，您将学习如何使用 Selenium 编写验收测试，它允许您模拟填写表单或在浏览器中单击特定 DOM 元素等活动。

## 准备好了吗

让我们从*的`locations`和`likes`应用程序开始，实现[第 4 章](04.html "Chapter 4. Templates and JavaScript")中类似的小部件*配方、*模板和 JavaScript*。

如果您还没有，请从[安装Firefox 浏览器 http://getfirefox.com](http://getfirefox.com) 。

然后，在虚拟环境中安装 Selenium，如下所示：

```py
(myproject_env)$ pip install selenium

```

## 怎么做。。。

我们将通过执行以下步骤，使用 Selenium 测试基于 Ajax 的*liking*功能：

1.  在您的`locations`应用程序中创建`tests.py`文件，内容如下：

    ```py
    # locations/tests.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from time import sleep
    from django.test import LiveServerTestCase
    from django.contrib.contenttypes.models import ContentType
    from django.contrib.auth.models import User
    from selenium import webdriver
    from selenium.webdriver.support.ui import WebDriverWait
    from likes.models import Like
    from .models import Location

    class LiveLocationTest(LiveServerTestCase):
        @classmethod
        def setUpClass(cls):
            super(LiveLocationTest, cls).setUpClass()
            cls.browser = webdriver.Firefox()
            cls.browser.delete_all_cookies()
            cls.location = Location.objects.create(
                title="Haus der Kulturen der Welt",
                slug="hkw",
                small_image="locations/2015/11/"
                    "20151116013056_small.jpg",
                medium_image="locations/2015/11/"
                    "20151116013056_medium.jpg",
                large_image="locations/2015/11/"
                    "20151116013056_large.jpg",
            )
            cls.username = "test-admin"
            cls.password = "test-admin"
            cls.superuser = User.objects.create_superuser(
                username=cls.username,
                password=cls.password,
                email="",
            )

        @classmethod
        def tearDownClass(cls):
            super(LiveLocationTest, cls).tearDownClass()
            cls.browser.quit()
            cls.location.delete()
            cls.superuser.delete()

        def test_login_and_like(self):
            # login
            self.browser.get("%(website)s/admin/login/"
                "?next=/locations/%(slug)s/" % {
                "website": self.live_server_url,
                "slug": self.location.slug,
            })
            username_field = \
                self.browser.find_element_by_id("id_username")
            username_field.send_keys(self.username)
            password_field = \
                self.browser.find_element_by_id("id_password")
            password_field.send_keys(self.password)
            self.browser.find_element_by_css_selector(
                'input[type="submit"]'
            ).click()
            WebDriverWait(self.browser, 10).until(
                lambda x: self.browser.\
                    find_element_by_css_selector(
                        ".like-button"
                    )
            )
            # click on the "like" button
            like_button = self.browser.\
                find_element_by_css_selector('.like-button')
            is_initially_active = \
                "active" in like_button.get_attribute("class")
            initial_likes = int(self.browser.\
                find_element_by_css_selector(
                    ".like-badge"
                ).text)

            sleep(2) # remove this after the first run

            like_button.click()
            WebDriverWait(self.browser, 10).until(
                lambda x: int(
                    self.browser.find_element_by_css_selector(
                        ".like-badge"
                    ).text
                ) != initial_likes
            )
            likes_in_html = int(
                self.browser.find_element_by_css_selector(
                    ".like-badge"
                ).text
            )
            likes_in_db = Like.objects.filter(
                content_type=ContentType.objects.\
                    get_for_model(Location),
                object_id=self.location.pk,
            ).count()

            sleep(2) # remove this after the first run

            self.assertEqual(likes_in_html, likes_in_db)
            if is_initially_active:
                self.assertLess(likes_in_html, initial_likes)
            else:
                self.assertGreater(
                    likes_in_html, initial_likes
                )

            # click on the "like" button again to switch back
            # to the previous state
            like_button.click()
            WebDriverWait(self.browser, 10).until(
                lambda x: int(
                    self.browser.find_element_by_css_selector(
                        ".like-badge"
                    ).text
                ) == initial_likes
            )

            sleep(2) # remove this after the first run
    ```

2.  测试将在`DEBUG = False`模式下运行；因此，您必须确保在开发环境中可以访问所有静态文件。确保在项目的 URL 配置中添加以下行：

    ```py
    # myproject/urls.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.conf.urls import patterns, include, url
    from django.conf import settings
    from django.conf.urls.static import static
    from django.contrib.staticfiles.urls import \
        staticfiles_urlpatterns

    urlpatterns = patterns("",# …
    )

    urlpatterns += staticfiles_urlpatterns()
    urlpatterns += static(
     settings.STATIC_URL,
     document_root=settings.STATIC_ROOT
    )
    urlpatterns += static(
        settings.MEDIA_URL,
        document_root=settings.MEDIA_ROOT
    )
    ```

3.  收集静态文件以使测试服务器能够访问它们，如下所示：

    ```py
    (myproject_env)$ python manage.py collectstatic --noinput

    ```

4.  运行`locations`应用程序的测试，如下所示：

    ```py
    (myproject_env)$ python manage.py test locations
    Creating test database for alias 'default'...
    .
    --------------------------------------------------------
    Ran 1 test in 19.158s

    OK
    Destroying test database for alias 'default'...

    ```

## 它是如何工作的。。。

当我们运行这些测试时，Firefox 浏览器将打开并转到位于`http://localhost:8081/admin/login/?next=/locations/hkw/`的管理登录页面。

然后，用户名和密码字段将被填入`test-admin`，您将被重定向到`Haus der Kulturen der Welt`位置的详细页面，如下所示：`http://localhost:8081/locations/hkw/`。

在那里你会看到**Like**按钮被点击两次，导致喜欢和不喜欢的动作。

让我们看看这在测试套件中是如何工作的。我们定义了一个扩展`LiveServerTestCase`的类。这将创建一个测试套件，该套件将在`8081`端口下运行本地服务器。`setUpClass()`类方法将在所有测试开始时执行，`tearDownClass()`类方法将在测试运行后执行。在中间，测试将执行所有的方法，其名称从 OutT4 开始。对于每个通过的测试，您将在命令行工具中看到一个点（`.`），对于每个失败的测试，您将看到字母`F`，对于测试中的每个错误，您将看到字母`E`。最后，您将看到关于失败和错误测试的提示。由于`locations`应用程序套件中目前只有一个测试，因此您只能看到一个点。

当我们开始测试时，会创建一个新的测试数据库。在`setUpClass()`中，我们创建了一个浏览器对象、一个位置和一个超级用户。然后，执行`test_login_and_like()`方法，打开管理登录页面，找到**用户名**字段，输入管理员用户名，找到**密码**字段，输入管理员密码，找到**提交**按钮，然后点击。然后，它最多等待十秒钟，直到在页面上找到带有`.like-button`CSS 类的 DOM 元素。

您可能还记得在[第 4 章](04.html "Chapter 4. Templates and JavaScript")、*模板和 JavaScript*中的*实现 Like 小部件*配方，我们的小部件由两个元素组成：一个**Like**按钮和一个显示 Like 总数的徽章。如果单击一个按钮，您的`Like`将通过 Ajax 调用从数据库中添加或删除。此外，将更新徽章计数以反映数据库中的喜欢数量，如下图所示：

![How it works...](img/B04912_11_01.jpg)

在进一步的测试中，我们检查按钮的初始状态是什么（是否有`.active`CSS 类），检查喜欢的初始数量，并模拟点击按钮。我们最多等待 10 秒，直到徽章中的计数发生变化。然后，我们检查徽章中的计数是否与数据库中该位置的总喜好相匹配。我们还将检查徽章中的计数如何变化（增加或减少）。最后，我们将再次模拟点击按钮切换回之前的状态。

`sleep()`功能正在测试中，只是为了让您能够看到整个工作流程。您可以安全地删除它们，以使测试运行得更快。

最后，调用`tearDownClass()`方法，关闭浏览器并从测试数据库中删除位置和超级用户。

## 另见

*   *实现了[第 4 章](04.html "Chapter 4. Templates and JavaScript")中类似的小部件*配方、*模板和 JavaScript*
*   模拟配方的*测试视图*
*   使用 Django REST 框架配方创建的*测试 API*

# 模拟测试视图

在本食谱中，我们将了解如何编写单元测试。单元测试是检查函数或方法是否返回正确结果的测试。我们再次使用`likes`应用程序，编写测试，检查未经身份验证的用户在`json_set_like()`视图中发布是否会返回`{"success"; false}`，而经过身份验证的用户返回`{"action": "added", "count": 1, "obj": "Haus der Kulturen der Welt", "success": true}`。我们将使用`Mock`对象来模拟`HttpRequest`和`AnonymousUser`对象。

## 准备好了吗

让我们从实现[第 4 章](04.html "Chapter 4. Templates and JavaScript")中类似小部件配方的*中的`locations`和`likes`应用程序开始，*模板和 JavaScript*。*

在您的虚拟环境中安装`mock`模块，如下所示：

```py
(myproject_env)$ pip install mock

```

## 怎么做。。。

我们将通过执行以下步骤，使用 mock 测试*liking*动作：

1.  在您的`likes`应用程序中创建`tests.py`文件，内容如下：

    ```py
    # likes/tests.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    import mock
    import json
    from django.contrib.contenttypes.models import ContentType
    from django.contrib.auth.models import User
    from django.test import SimpleTestCase
    from locations.models import Location

    class JSSetLikeViewTest(SimpleTestCase):
        @classmethod
        def setUpClass(cls):
            super(JSSetLikeViewTest, cls).setUpClass()
            cls.location = Location.objects.create(
                title="Haus der Kulturen der Welt",
                slug="hkw",
                small_image="locations/2015/11/"
                    "20151116013056_small.jpg",
                medium_image="locations/2015/11/"
                    "20151116013056_medium.jpg",
                large_image="locations/2015/11/"
                    "20151116013056_large.jpg",
            )
            cls.content_type = \
                ContentType.objects.get_for_model(Location)
            cls.username = "test-admin"
            cls.password = "test-admin"
            cls.superuser = User.objects.create_superuser(
                username=cls.username,
                password=cls.password,
                email="",
            )

        @classmethod
        def tearDownClass(cls):
            super(JSSetLikeViewTest, cls).tearDownClass()
            cls.location.delete()
            cls.superuser.delete()

        def test_authenticated_json_set_like(self):
            from .views import json_set_like
            mock_request = mock.Mock()
            mock_request.user = self.superuser
            mock_request.method = "POST"
            response = json_set_like(
                mock_request,
                self.content_type.pk,
                self.location.pk
            )
            expected_result = json.dumps({
                "success": True,
                "action": "added",
                "obj": self.location.title,
                "count": Location.objects.count(),
            })
            self.assertJSONEqual(
                response.content,
                expected_result
            )

        def test_anonymous_json_set_like(self):
            from .views import json_set_like
            mock_request = mock.Mock()
            mock_request.user.is_authenticated.return_value = \
                False
            mock_request.method = "POST"
            response = json_set_like(
                mock_request,
                self.content_type.pk,
                self.location.pk
            )
            expected_result = json.dumps({
                "success": False,
            })
            self.assertJSONEqual(
                response.content,
                expected_result
            )
    ```

2.  为`likes`应用程序运行测试，如下所示：

    ```py
    (myproject_env)$ python manage.py test likes
    Creating test database for alias 'default'...
    ..
    --------------------------------------------------------
    Ran 2 tests in 0.093s

    OK
    Destroying test database for alias 'default'...

    ```

## 它是如何工作的。。。

就像前面的配方一样，当您为`likes`应用程序运行测试时，首先会创建一个临时测试数据库。然后，调用`setUpClass()`方法。之后执行名称以`test`开头的方法，最后调用方法`tearDownClass()`。

单元测试继承自`SimpleTestCase`类。在`setUpClass()`中，我们创建了一个位置和一个超级用户。此外，我们还找到了`Location`模型的`ContentType`对象，我们需要它来为不同的对象设置或删除喜欢的视图。作为提醒，该视图看起来类似于以下内容，并返回 JSON 字符串作为结果：

```py
def json_set_like(request, content_type_id, object_id):
    # ...all the view logic goes here...
    return HttpResponse(
        json_str,
        content_type="text/javascript; charset=utf-8"
    )
```

在`test_authenticated_json_set_like()`和`test_anonymous_json_set_like()`方法中，我们使用`Mock`对象。它们是具有任何属性或方法的对象。`Mock`对象的每个未定义属性或方法都是另一个`Mock`对象。因此，在 shell 中，可以尝试按如下方式链接属性：

```py
>>> import mock
>>> m = mock.Mock()
>>> m.whatever.anything().whatsoever
<Mock name='mock.whatever.anything().whatsoever' id='4464778896'>

```

在我们的测试中，我们使用`Mock`对象来模拟`HttpRequest`和`AnonymousUser`对象。对于经过身份验证的用户，我们仍然需要真实的`User`对象，因为视图需要将用户 ID 保存在`Like`对象的数据库中。

因此，我们调用`json_set_like()`函数，查看返回的 JSON 响应是否正确：如果访问者未经身份验证，则在响应中返回`{"success": false}`；并为经过身份验证的用户返回类似于`{"action": "added", "count": 1, "obj": "Haus der Kulturen der Welt", "success": true}`的内容。

最后调用`tearDownClass()`类方法，从测试数据库中删除位置和超级用户。

## 另见

*   *实现了[第 4 章](04.html "Chapter 4. Templates and JavaScript")中类似的小部件*配方、*模板和 JavaScript*
*   含硒配方的*测试页面*
*   使用 Django REST 框架配方创建的*测试 API*

# 测试使用 Django REST 框架创建的 API

我们已经了解了如何编写操作验收和单元测试。在此配方中，我们将对本书前面创建的 RESTAPI 进行组件接口测试。

### 提示

如果您不熟悉 RESTAPI 是什么以及如何使用它，您可以在[了解它http://www.restapitutorial.com/](http://www.restapitutorial.com/) 。

## 准备好了吗

让我们从*中的`bulletin_board`应用开始，使用 Django REST 框架在[第 9 章](09.html "Chapter 9. Data Import and Export")、*数据导入和导出*中创建 API*配方。

## 怎么做。。。

要测试 REST API，请执行以下步骤：

1.  在你的`bulletin_board`应用程序中创建一个`tests.py`文件，如下所示：

    ```py
    # bulletin_board/tests.py
    # -*- coding: UTF-8 -*-
    from __future__ import unicode_literals
    from django.contrib.auth.models import User
    from django.core.urlresolvers import reverse
    from rest_framework import status
    from rest_framework.test import APITestCase
    from .models import Category, Bulletin

    class BulletinTests(APITestCase):
        @classmethod
        def setUpClass(cls):
            super(BulletinTests, cls).setUpClass()
            cls.superuser, created = User.objects.\
                get_or_create(
                    username="test-admin",
                )
            cls.superuser.is_active = True
            cls.superuser.is_superuser = True
            cls.superuser.save()

            cls.category = Category.objects.create(
                title="Movies"
            )

            cls.bulletin = Bulletin.objects.create(
                bulletin_type="searching",
                category=cls.category,
                title="The Matrix",
                description="There is no Spoon.",
                contact_person="Aidas Bendoraitis",
            )
            cls.bulletin_to_delete = Bulletin.objects.create(
                bulletin_type="searching",
                category=cls.category,
                title="Animatrix",
                description="Trinity: "
                    "There's a difference, Mr. Ash, "
                    "between a trap and a test.",
                contact_person="Aidas Bendoraitis",
            )

        @classmethod
        def tearDownClass(cls):
            super(BulletinTests, cls).tearDownClass()
            cls.category.delete()
            cls.bulletin.delete()
            cls.superuser.delete()
    ```

2.  添加一个方法来测试列出公告的 API调用，如下所示：

    ```py
    def test_list_bulletins(self):
        url = reverse("rest_bulletin_list")
        data = {}
        response = self.client.get(url, data, format="json")
        self.assertEqual(
            response.status_code, status.HTTP_200_OK
        )
        self.assertEqual(
            response.data["count"], Bulletin.objects.count()
        )
    ```

3.  添加一个方法来测试 API 调用，显示一个公告如下：

    ```py
    def test_get_bulletin(self):
        url = reverse("rest_bulletin_detail", kwargs={
            "pk": self.bulletin.pk
        })
        data = {}
        response = self.client.get(url, data, format="json")
        self.assertEqual(
            response.status_code, status.HTTP_200_OK
        )
        self.assertEqual(response.data["id"], self.bulletin.pk)
        self.assertEqual(
            response.data["bulletin_type"],
            self.bulletin.bulletin_type
        )
        self.assertEqual(
            response.data["category"]["id"],
            self.category.pk
        )
        self.assertEqual(
            response.data["title"],
            self.bulletin.title
        )
        self.assertEqual(
            response.data["description"],
            self.bulletin.description
        )
        self.assertEqual(
            response.data["contact_person"],
            self.bulletin.contact_person
        )
    ```

4.  如果当前用户已通过身份验证，则添加一个方法来测试创建公告的 API 调用，如下所示：

    ```py
    def test_create_bulletin_allowed(self):
        # login
        self.client.force_authenticate(user=self.superuser)

        url = reverse("rest_bulletin_list")
        data = {
            "bulletin_type": "offering",
            "category": {"title": self.category.title},
            "title": "Back to the Future",
            "description": "Roads? Where we're going, "
                "we don't need roads.",
            "contact_person": "Aidas Bendoraitis",
        }
        response = self.client.post(url, data, format="json")
        self.assertEqual(
            response.status_code, status.HTTP_201_CREATED
        )
        self.assertTrue(Bulletin.objects.filter(
            pk=response.data["id"]
        ).count() == 1)

        # logout
        self.client.force_authenticate(user=None)
    ```

5.  添加一个方法来测试试图创建公告的 API 调用；但是，由于当前访问者是匿名的，所以失败，如下所示：

    ```py
    def test_create_bulletin_restricted(self):
        # make sure the user is logged out
        self.client.force_authenticate(user=None)

        url = reverse("rest_bulletin_list")
        data = {
            "bulletin_type": "offering",
            "category": {"title": self.category.title},
            "title": "Back to the Future",
            "description": "Roads? Where we're going, "
                "we don't need roads.",
            "contact_person": "Aidas Bendoraitis",
        }
        response = self.client.post(url, data, format="json")
        self.assertEqual(
            response.status_code, status.HTTP_403_FORBIDDEN
        )
    ```

6.  添加一个方法来测试 API 调用，如果当前用户已通过身份验证，则更改公告，如下所示：

    ```py
    def test_change_bulletin_allowed(self):
        # login
        self.client.force_authenticate(user=self.superuser)

        url = reverse("rest_bulletin_detail", kwargs={
            "pk": self.bulletin.pk
        })

        # change only title
        data = {
            "bulletin_type": self.bulletin.bulletin_type,
            "category": {
                "title": self.bulletin.category.title
            },
            "title": "Matrix Resurrection",
            "description": self.bulletin.description,
            "contact_person": self.bulletin.contact_person,
        }
        response = self.client.put(url, data, format="json")
        self.assertEqual(
            response.status_code, status.HTTP_200_OK
        )
        self.assertEqual(response.data["id"], self.bulletin.pk)
        self.assertEqual(
            response.data["bulletin_type"], "searching"
        )

        # logout
        self.client.force_authenticate(user=None)
    ```

7.  添加一个方法测试试图更改公告的 API 调用；但是，由于当前访问者是匿名的，所以失败：

    ```py
    def test_change_bulletin_restricted(self):
        # make sure the user is logged out
        self.client.force_authenticate(user=None)

        url = reverse("rest_bulletin_detail", kwargs={
            "pk": self.bulletin.pk
        })
        # change only title
        data = {
            "bulletin_type": self.bulletin.bulletin_type,
            "category": {
                "title": self.bulletin.category.title
            },
            "title": "Matrix Resurrection",
            "description": self.bulletin.description,
            "contact_person": self.bulletin.contact_person,
        }
        response = self.client.put(url, data, format="json")
        self.assertEqual(
            response.status_code, status.HTTP_403_FORBIDDEN
        )
    ```

8.  添加一个方法，测试 API 调用在当前用户已认证的情况下删除公告，如下图：

    ```py
    def test_delete_bulletin_allowed(self):
        # login
        self.client.force_authenticate(user=self.superuser)

        url = reverse("rest_bulletin_detail", kwargs={
            "pk": self.bulletin_to_delete.pk
        })
        data = {}
        response = self.client.delete(url, data, format="json")
        self.assertEqual(
            response.status_code, status.HTTP_204_NO_CONTENT
        )

        # logout
        self.client.force_authenticate(user=None)
    ```

9.  添加一个方法来测试试图删除公告的 API 调用；但是，由于当前访问者是匿名的，所以失败：

    ```py
    def test_delete_bulletin_restricted(self):
        # make sure the user is logged out
        self.client.force_authenticate(user=None)

        url = reverse("rest_bulletin_detail", kwargs={
            "pk": self.bulletin_to_delete.pk
        })
        data = {}
        response = self.client.delete(url, data, format="json")
        self.assertEqual(
            response.status_code, status.HTTP_403_FORBIDDEN
        )
    ```

10.  运行`bulletin_board`应用程序的测试，如下所示：

    ```py
    (myproject_env)$ python manage.py test bulletin_board
    Creating test database for alias 'default'...
    ........
    --------------------------------------------------------
    Ran 8 tests in 0.081s

    OK
    Destroying test database for alias 'default'...

    ```

## 它是如何工作的。。。

RESTAPI 测试套件扩展了`APITestCase`类。再一次，我们有`setUpClass()`和`tearDownClass()`类方法，它们将在不同测试之前和之后执行。此外，测试套件具有一个`APIClient`类型的`client`属性，可用于模拟 API 调用。所有标准 HTTP 调用都有方法：`get()`、`post()`、`put()`、`patch()`、`delete()`、`head()`、`options()`；然而，在我们的测试中，我们使用了`GET`、`POST`和`DELETE`请求。此外，`client`还具有通过登录凭据、令牌或仅通过`User`对象对用户进行身份验证的方法。在我们的测试中，我们通过第三种方式进行身份验证，只是将用户直接传递给`force_authenticate()`方法。

代码的其余部分是不言自明的。

## 另见

*   *在[第 9 章](09.html "Chapter 9. Data Import and Export")、*数据导入导出*中使用 Django REST 框架创建 API*配方
*   含硒配方的*测试页面*
*   模拟配方的*测试视图*

# 发布可重用的 Django 应用程序

Django文档提供了一个关于如何打包您的可重用应用程序的教程，以便以后可以在任何虚拟环境中使用`pip`安装这些应用程序：

[https://docs.djangoproject.com/en/1.8/intro/reusable-apps/](https://docs.djangoproject.com/en/1.8/intro/reusable-apps/)

然而，有更好的方法可以使用**Cookiecutter**工具打包和发布可重用的 Django 应用程序，该工具为不同的编码项目创建模板，如新的 Django CMS 网站、Flask 网站或 jQuery 插件。可用的项目模板之一是`cookiecutter-djangopackage`。在本食谱中，您将学习如何使用它分发可重用的`likes`应用程序。

## 准备好了吗

在您的虚拟环境中安装`Cookiecutter`：

```py
(myproject_env)$ pip install cookiecutter

```

## 怎么做。。。

要发布您的`likes`应用程序，请执行以下步骤：

1.  启动一个新的 Django 应用程序项目，如下所示：

    ```py
    (myapp_env)$ cookiecutter \
    https://github.com/pydanny/cookiecutter-djangopackage.git

    ```

2.  回答问题以创建应用程序模板：

    ```py
    full_name [Your full name here]: Aidas Bendoraitis
    email [you@example.com]: aidas@bendoraitis.lt
    github_username [yourname]: archatas
    project_name [dj-package]: django-likes
    repo_name [dj-package]: django-likes
    app_name [djpackage]: likes
    project_short_description [Your project description goes here]: Django-likes allows your website users to like any object.
    release_date [2015-10-02]:
    year [2015]:
    version [0.1.0]:

    ```

3.  This will create a file structure, as shown in the following image:

    ![How to do it...](img/B04912_11_02.jpg)

4.  将您正在使用的 Django 项目中的应用程序文件复制到`django-likes/likes`目录。
5.  将可重用应用程序项目添加到 GitHub 下的 Git 存储库中。
6.  浏览不同的文件并完成许可证、自述、文档、配置和其他文件。
7.  确保应用程序通过测试：

    ```py
    (myapp_env)$ pip install -r requirements-test.txt
    (myapp_env)$ python runtests.py

    ```

8.  If your package is closed source, create a shareable release as a ZIP archive:

    ```py
    (myapp_env)$ python setup.py sdist

    ```

    这将创建一个可使用 pip 安装或卸载的`django-likes/dist/django-likes-0.1.0.tar.gz`文件，如下所示：

    ```py
    (myproject_env)$ pip install django-likes-0.1.0.tar.gz
    (myproject_env)$ pip uninstall django-likes

    ```

9.  如果您的软件包是开源的，请在**Python 软件包索引**（**PyPI**：

    ```py
    (myapp_env)$ python setup.py register
    (myapp_env)$ python setup.py publish

    ```

    上注册并发布您的应用程序
10.  此外，为了传播信息，通过在[提交表格，将您的应用程序添加到 Django 软件包中 https://www.djangopackages.com/packages/add/](https://www.djangopackages.com/packages/add/) 。

## 它是如何工作的。。。

Cookiecutter 在 Django 应用程序项目模板的不同部分填写输入的请求数据。因此，您可以将`setup.py`文件分发到 Python 包索引、Sphinx 文档、BSD 作为默认许可证、项目的通用文本编辑器配置、应用程序中包含的静态文件和模板，以及其他好东西。

## 另见

*   [第 1 章](01.html "Chapter 1. Getting Started with Django 1.8")*Django 1.8*入门中的*创建项目文件结构*配方
*   [第 1 章](01.html "Chapter 1. Getting Started with Django 1.8")*中的*使用 pip*配方处理项目依赖关系*开始使用 Django 1.8**
*   *实现了[第 4 章](04.html "Chapter 4. Templates and JavaScript")中类似的小部件*配方、*模板和 JavaScript*

# 通过电子邮件获取详细的错误报告

为了执行系统日志记录，Django 使用 Python 的内置日志记录模块。默认的 Django 配置似乎相当复杂。在本教程中，您将学习如何调整它以发送带有完整 HTML 的错误电子邮件，类似于 Django 在发生错误时在调试模式下提供的内容。

## 准备好了吗

在虚拟环境中找到 Django 项目。

## 怎么做。。。

以下程序将帮助您发送有关错误的详细电子邮件：

1.  在文本编辑器中打开`myproject_env/lib/python2.7/site-packages/django/utils/log.py`文件，并将`DEFAULT_LOGGING`字典作为`LOGGING`字典复制到项目的设置中。
2.  将`include_html`设置添加到`mail_admins`处理程序中，如下所示：

    ```py
    # myproject/conf/base.py or myproject/settings.py
    LOGGING = {
        "version": 1,
        "disable_existing_loggers": False,
        "filters": {
            "require_debug_false": {
                "()": "django.utils.log.RequireDebugFalse",
            },
            "require_debug_true": {
                "()": "django.utils.log.RequireDebugTrue",
            },
        },
        "handlers": {
            "console": {
                "level": "INFO",
                "filters": ["require_debug_true"],
                "class": "logging.StreamHandler",
            },
            "null": {
                "class": "django.utils.log.NullHandler",
            },
            "mail_admins": {
                "level": "ERROR",
                "filters": ["require_debug_false"],
                "class": "django.utils.log.AdminEmailHandler",
     "include_html": True,
            }
        },
        "loggers": {
            "django": {
                "handlers": ["console"],
            },
            "django.request": {
                "handlers": ["mail_admins"],
                "level": "ERROR",
                "propagate": False,
            },
            "django.security": {
                "handlers": ["mail_admins"],
                "level": "ERROR",
                "propagate": False,
            },
            "py.warnings": {
                "handlers": ["console"],
            },
        }
    }
    ```

## 它是如何工作的。。。

日志配置由四部分组成：记录器、处理程序、过滤器和格式化程序。以下是如何对其进行描述：

*   记录器是记录系统中的入口点。每个记录器可以有一个日志级别：`DEBUG`、`INFO`、`WARNING`、`ERROR`或`CRITICAL`。将消息写入记录器时，会将消息的日志级别与记录器的级别进行比较。如果它达到或超过记录器的日志级别，将由处理程序进一步处理。否则，该消息将被忽略。
*   处理程序是定义记录器中每条消息发生了什么的引擎。它们可以写入控制台，通过电子邮件发送给管理员，保存到日志文件，发送到 Sentry 错误日志服务，等等。在我们的例子中，我们为`mail_admins`处理程序设置了`include_html`参数，因为我们希望完整的 HTML 带有回溯和局部变量，用于 Django 项目中发生的错误消息。
*   过滤器提供了对从记录器传递到处理程序的消息的额外控制。例如，在我们的例子中，只有当调试模式设置为`False`时，才会发送电子邮件。
*   格式化程序用于定义如何将日志消息呈现为字符串。本例中未使用它们；但是，有关日志记录的更多信息，您可以参考[上的官方文档 https://docs.djangoproject.com/en/1.8/topics/logging/](https://docs.djangoproject.com/en/1.8/topics/logging/) 。

## 另见

*   使用 mod_wsgi 配方在 Apache 上部署的

 *# 使用 mod_wsgi 在 Apache 上部署

关于如何部署您的Django 项目，有多种选择。在本教程中，我将指导您使用 Virtualmin 在专用 Linux 服务器上部署 Django 项目。

专用服务器是一种 Internet 托管类型，您可以租用不与任何其他人共享的整个服务器。Virtualmin是一个 web 主机控制面板，允许您管理虚拟域、邮箱、数据库和整个服务器，而无需深入了解服务器管理的命令行例程。

为了运行 Django 项目，我们将使用带有`mod_wsgi`模块和 MySQL 数据库的 ApacheWeb 服务器。

## 准备好了吗

确保在专用 Linux 服务器上安装了 Virtualmin。有关说明，请参阅[http://www.virtualmin.com/download.html](http://www.virtualmin.com/download.html) 。

## 怎么做。。。

按照以下步骤在使用 Virtualmin 的 Linux 服务器上部署 Django 项目：

1.  Log in to Virtualmin as the root user and set `bash` instead of `sh` as the default shell for the server's users. This can be done by navigating to **Virtualmin** | **System Customization** | **Custom Shells**, as shown in the following screenshot:

    ![How to do it...](img/B04912_11_03.jpg)

2.  Create a virtual server for your project by navigating to **Virtualmin** | **Create Virtual Server**. Enable the following features: **Setup website for domain?** and **Create MySQL database?**. The username and password that you set for the domain will also be used for the SSH connections, FTP, and MySQL database access, as follows:

    ![How to do it...](img/B04912_11_04.jpg)

3.  登录您的域管理面板，将您域的`A`记录设置为专用服务器的 IP 地址。
4.  以 root 用户身份通过 Secure Shell 连接到专用服务器，并在系统范围内安装 Python 库、`pip`、`virtualenv`、`MySQLdb`和`Pillow`。
5.  确保默认 MySQL 数据库编码为 UTF-8：
    1.  Edit MySQL configuration file on the remote server, for example, using the nano editor:

        ```py
        $ ssh root@myproject.com
        root@myproject.com's password:

        $ nano /etc/mysql/my.cnf

        ```

        添加或编辑以下配置：

        ```py
        [client]
        default-character-set=utf8

        [mysql]
        default-character-set=utf8

        [mysqld]
        collation-server=utf8_unicode_ci
        init-connect='SET NAMES utf8'
        character-set-server=utf8

        ```

    2.  按*Ctrl*+*O*保存更改，按*Ctrl*+*X*退出 nano 编辑器。
    3.  然后重启 MySQL 服务器，如下所示：

        ```py
        $ /etc/init.d/mysql restart

        ```

    4.  按*Ctrl*+*D*退出安全壳。
6.  When you create a domain with Virtualmin, the user for that domain is created automatically. Connect to the dedicated server via Secure Shell as a user of your Django project and create a virtual environment for your project, as follows:

    ```py
    $ ssh myproject@myproject.com
    myproject@myproject.com's password:

    $ virtualenv . --system-site-packages
    $ echo source ~/bin/activate >> .bashrc
    $ source ~/bin/activate
    (myproject)myproject@server$

    ```

    ### 提示

    每次您作为域相关用户通过 Secure Shell 连接到 Django 项目时，`.bashrc`脚本都会被调用。`.bashrc`脚本将自动激活此项目的虚拟环境。

7.  如果您将项目代码托管在 Bitbucket 上，则需要设置 SSH 密钥，以避免在从 Git 存储库拉出或推送到 Git 存储库时出现密码提示：
    1.  依次执行以下命令：

        ```py
        (myproject)myproject@server$ ssh-keygen
        (myproject)myproject@server$ ssh-agent /bin/bash
        (myproject)myproject@server$ ssh-add ~/.ssh/id_rsa
        (myproject)myproject@server$ cat ~/.ssh/id_rsa.pub

        ```

    2.  最后一个命令打印您需要复制并粘贴到 Bitbucket 网站上的**管理帐户****SSH 密钥****添加密钥**的 SSH 公钥。
8.  Create a `project` directory, go to it, and clone your project's code as follows:

    ```py
    (myproject)myproject@server$ git clone \
    git@bitbucket.org:somebitbucketuser/myproject.git myproject

    ```

    ### 提示

    现在，您的项目路径应该类似于以下内容：`/home/myproject/project/myproject`

9.  为您的项目安装Python 需求，包括指定版本的 Django，如下所示：

    ```py
    (myproject)myproject@server$ pip install -r requirements.txt

    ```

10.  在项目目录下创建`media`、`tmp`和`static`目录。
11.  另外，创建具有类似以下设置的`local_settings.py`：

    ```py
    # /home/myproject/project/myproject/myproject/local_settings.py
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.mysql",
            "NAME": "myproject",
            "USER": "myproject",
            "PASSWORD": "mypassword",
        }
    }
    PREPEND_WWW = True
    DEBUG = False
    ALLOWED_HOSTS = ["myproject.com"]
    ```

12.  导入您在本地创建的数据库转储。如果您使用的是 Mac 电脑，您可以通过应用程序**Sequel Pro**（[来实现 http://www.sequelpro.com/](http://www.sequelpro.com/) ），使用 SSH 连接。您还可以通过 FTP 将数据库转储上传到服务器，然后在 Secure Shell 中运行以下操作：

    ```py
    (myproject)myproject@server$ python manage.py dbshell < \
    ~/db_backups/db.sql

    ```

13.  收集静态文件，如下所示：

    ```py
    (myproject)myproject@server$ python manage.py collectstatic \
    --noinput

    ```

14.  进入`~/public_html`目录，使用 nano 编辑器（或您选择的编辑器）：

    ```py
    # /home/myproject/public_html/my.wsgi
    #!/home/myproject/bin/python
    # -*- coding: utf-8 -*-
    import os, sys, site
    django_path = os.path.abspath(
        os.path.join(os.path.dirname(__file__),
        "../lib/python2.6/site-packages/"),
    )
    site.addsitedir(django_path)
    project_path = os.path.abspath(
        os.path.join(os.path.dirname(__file__),
        "../project/myproject"),
    )
    sys.path += [project_path]
    os.environ["DJANGO_SETTINGS_MODULE"] = "myproject.settings"
    from django.core.wsgi import get_wsgi_application
    application = get_wsgi_application()
    ```

    创建`wsgi`文件
15.  然后，在相同目录中创建该`.htaccess`文件。`.htaccess`文件将所有请求重定向到`wsgi`文件中设置的 Django 项目，如下所示：

    ```py
    # /home/myproject/public_html/.htaccess
    AddHandler wsgi-script .wsgi
    DirectoryIndex index.html
    RewriteEngine On
    RewriteBase /
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME}/index.html !-f
    RewriteCond %{REQUEST_URI} !^/media/
    RewriteCond %{REQUEST_URI} !^/static/
    RewriteRule ^(.*)$ /my.wsgi/$1 [QSA,L]
    ```

16.  将`.htaccess`复制为`.htaccess_live`。
17.  Then, also create `.htaccess_maintenace` for maintenance cases. This new Apache configuration file will show `temporarily-offline.html` for all the users except you, recognized by the IP address of your LAN or computer. You can check your IP by googling `what's my ip`. The following is how the `.htaccess_maintenance` will look:

    ```py
    # /home/myproject/public_html/.htaccess_maintenance
    AddHandler wsgi-script .wsgi
    DirectoryIndex index.html
    RewriteEngine On
    RewriteBase /
    RewriteCond %{REMOTE_HOST} !^1\.2\.3\.4$
    RewriteCond %{REQUEST_URI} !/temporarily-offline\.html
    RewriteCond %{REQUEST_URI} !^/media/
    RewriteCond %{REQUEST_URI} !^/static/
    RewriteRule .* /temporarily-offline.html [R=302,L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME}/index.html !-f
    RewriteCond %{REQUEST_URI} !^/media/
    RewriteCond %{REQUEST_URI} !^/static/
    RewriteRule ^(.*)$ /my.wsgi/$1 [QSA,L]
    ```

    ### 提示

    将此文件中的 IP 数字替换为您自己的 IP。

18.  然后，创建一个 HTML 文件，该文件将在网站关闭时显示：

    ```py
    <!-- /home/myproject/public_html/temporarily-offline.html -->
    The site is being updated... Please come back later.
    ```

19.  通过Secure Shell 以 root 用户身份登录服务器，编辑 Apache 配置：
    1.  打开域配置文件，如下所示：

        ```py
        $ nano /etc/apache2/sites-available/myproject.mydomain.conf

        ```

    2.  在`</VirtualHost>`之前添加以下行：

        ```py
        Options -Indexes
        AliasMatch ^/static/\d+/(.*) \
            "/home/myproject/project/myproject/static/$1"
        AliasMatch ^/media/(.*) \
            "/home/myproject/project/myproject/media/$1"
        <FilesMatch "\.(ico|pdf|flv|jpe?g|png|gif|js|css|swf)$">
            ExpiresActive On
            ExpiresDefault "access plus 1 year"
        </FilesMatch>
        ```

    3.  重新启动 Apache 以使更改生效：

        ```py
        $ /etc/init.d/apache2 restart

        ```

20.  设置默认的定时 cron 作业。有关如何执行此操作的更多信息，请参阅*为常规任务设置 cron 作业*配方。

## 它是如何工作的。。。

通过这种配置，`media`和`static`目录中的文件直接从 Apache 提供服务；然而，所有其他 URL 都由 Django 项目通过`my.wsgi`文件处理。

使用 Apache 站点配置中的`<FilesMatch>`指令，将所有媒体文件设置为缓存一年。静态 URL 路径有一个编号为的前缀，每当您从 Git 存储库更新代码时，该前缀都会更改。

当您需要更新网站并将其设置为维护时，您必须将`.htaccess_maintenance`复制到`.htaccess`。当您想重新设置网站时，您必须将`.htaccess_live`复制到`.htaccess`。

## 还有更多。。。

要查找托管 Django 项目的其他选项，请参阅：[http://djangofriendly.com/hosts/](http://djangofriendly.com/hosts/) 。

## 另见

*   [第 1 章](01.html "Chapter 1. Getting Started with Django 1.8")*Django 1.8*入门中的*创建项目文件结构*配方
*   [第 1 章](01.html "Chapter 1. Getting Started with Django 1.8")*中的*使用 pip*配方处理项目依赖关系*开始使用 Django 1.8**
*   [第一章](01.html "Chapter 1. Getting Started with Django 1.8")*Django 1.8*入门中的*动态设置 Git 用户*静态 URL 配方
*   [第一章](01.html "Chapter 1. Getting Started with Django 1.8")*Django 1.8 入门*中*将 UTF-8 设置为 MySQL 配置*配方的默认编码
*   *创建和使用结构部署脚本*配方
*   *为常规任务设置 cron 作业*配方

# 为常规任务设置 cron 作业

通常网站每周、每天或每小时都要在后台执行一些管理任务。这可以通过使用 cron 作业（也称为计划任务）来实现。这些是在服务器上运行指定时间段的脚本。在这个配方中，我们将创建两个 cron 作业：一个用于清除数据库中的会话，另一个用于备份数据库数据。两者都将每晚运行。

## 准备好了吗

首先，将 Django 项目部署到远程服务器上。然后，通过 SSH 连接到服务器。

## 怎么做。。。

让我们创建这两个脚本，并通过以下步骤使它们定期运行：

1.  在项目的主目录

    ```py
    (myproject)myproject@server$ mkdir commands
    (myproject)myproject@server$ mkdir db_backups
    (myproject)myproject@server$ mkdir logs

    ```

    中创建`commands`、`db_backups`和`logs`目录
2.  在`commands`目录中，创建一个包含以下内容的`cleanup.sh`文件：

    ```py
    # /home/myproject/commands/cleanup.sh
    #! /usr/bin/env bash
    PROJECT_PATH=/home/myproject
    CRON_LOG_FILE=${PROJECT_PATH}/logs/cleanup.log

    echo "Cleaning up the database" > ${CRON_LOG_FILE}
    date >> ${CRON_LOG_FILE}

    cd ${PROJECT_PATH}
    . bin/activate
    cd project/myproject
    python manage.py cleanup --traceback >> \
    ${CRON_LOG_FILE}  2>&1
    ```

3.  使以下文件可执行：

    ```py
    (myproject)myproject@server$ chmod +x cleanup.sh

    ```

4.  然后，在同一目录中创建一个具有以下内容的`backup_db.sh`文件：

    ```py
    # /home/myproject/commands/cleanup.sh
    #! /usr/bin/env bash
    PROJECT_PATH=/home/myproject
    CRON_LOG_FILE=${PROJECT_PATH}/logs/backup_db.log
    WEEK_DATE=$(LC_ALL=en_US.UTF-8 date +"%w-%A")
    BACKUP_PATH=${PROJECT_PATH}/db_backups/${WEEK_DATE}.sql
    DATABASE=myproject
    USER=my_db_user
    PASS=my_db_password

    EXCLUDED_TABLES=(
    django_session
    )

    IGNORED_TABLES_STRING=''
    for TABLE in "${EXCLUDED_TABLES[@]}"
    do :
        IGNORED_TABLES_STRING+=\
        " --ignore-table=${DATABASE}.${TABLE}"
    done

    echo "Creating DB Backup" > ${CRON_LOG_FILE}
    date >> ${CRON_LOG_FILE}

    cd ${PROJECT_PATH}
    mkdir -p db_backups

    echo "Dump structure" >> ${CRON_LOG_FILE}
    mysqldump -u ${USER} -p${PASS} --single-transaction \
    --no-data ${DATABASE} > ${BACKUP_PATH} 2>> ${CRON_LOG_FILE}

    echo "Dump content" >> ${CRON_LOG_FILE}
    mysqldump -u ${USER} -p${PASS} ${DATABASE} \
    ${IGNORED_TABLES_STRING} >> ${BACKUP_PATH} 2>> \
    ${CRON_LOG_FILE}
    ```

5.  使以下文件也可执行：

    ```py
    (myproject)myproject@server$ chmod +x backup_db.sh

    ```

6.  通过运行脚本，然后检查`logs`目录中的`*.log`文件，测试脚本是否正确执行，如下所示：

    ```py
    (myproject)myproject@server$ ./cleanup.sh
    (myproject)myproject@server$ ./backup_db.sh

    ```

7.  在项目的主目录中创建一个包含以下任务的`crontab.txt`文件：

    ```py
    00 01 * * * /home/myproject/commands/cleanup.sh
    00 02 * * * /home/myproject/commands/backup_db.sh

    ```

8.  安装 crontab 任务，如下所示：

    ```py
    (myproject)myproject@server$ crontab -e crontab.txt

    ```

## 它是如何工作的。。。

在当前设置下，每晚凌晨 1 点执行`cleanup.sh`，凌晨 2 点执行`backup_db.sh`，执行日志保存在`cleanup.log`和`backup_db.log`中。如果您得到任何错误，您应该检查这些文件以进行回溯。

数据库备份脚本稍微复杂一些。每周的每一天，它都会为当天创建一个名为`0-Sunday.sql`、`1-Monday.sql`等的备份文件。因此，您将能够恢复七天前或以后备份的数据。备份脚本首先转储所有表的数据库模式，然后转储所有表的数据，除了在`EXCLUDED_TABLES`（当前为`django_session`）中列出的表之外。

crontab 语法是这样的：每一行都包含一个特定的时间段，然后是一个要运行的任务。时间由五部分组成，由空格分隔，如下所示：

*   从 0 到 59 分钟
*   从 0 到 23 小时
*   从 1 日到 31 日的月份天数
*   从 1 月到 12 月
*   从 0 到 7 的一周天数，其中 0 是星期日，1 是星期一，依此类推。又是星期天了。

星号（`*`表示将使用每个时间帧。因此，以下任务定义了`cleanup.sh`在每月、每月和每周每天的凌晨 1:00 执行：

```py
00 01 * * * /home/myproject/commands/cleanup.sh

```

您可以在[了解更多关于 crontab 的细节 https://en.wikipedia.org/wiki/Cron](https://en.wikipedia.org/wiki/Cron) 。

## 另见

*   使用 mod_wsgi 配方在 Apache 上部署的
**   *创建和使用结构部署脚本*配方*

 *# 创建和使用结构部署脚本

通常，要更新您的站点，您必须执行重复性任务，例如设置维护页面、停止 cron 作业、创建数据库备份、从存储库中提取新代码、迁移数据库、收集静态文件、测试、再次启动 cron 作业以及取消维护页面。那是一项相当乏味的工作，可能会出错。此外，您不必忘记临时站点（可以测试新功能的站点）和生产站点（向公众展示）的不同例程。幸运的是，有一个名为**Fabric**的 Python 库，允许您自动化这些任务。在本教程中，您将学习如何创建`fabfile.py`，Fabric 脚本，以及如何在登台和生产环境中部署项目。

结构脚本可以从包含它的目录中调用，如下所示：

```py
(myproject_env)$ fab staging deploy

```

这将在临时服务器上部署项目。

## 准备好了吗

使用 mod_wsgi 配方在 Apache 上部署*中的说明，建立类似的登台和制作网站。在全局计算机上或在项目的虚拟环境中安装 Fabric，如下所示：*

```py
$ pip install fabric

```

## 怎么做。。。

首先，我们将在 Django 项目目录中创建一个`fabfile.py`文件，其中包含几个函数，如下所示：

```py
# fabfile.py
# -*- coding: UTF-8 -*-
from fabric.api import env, run, prompt, local, get, sudo
from fabric.colors import red, green
from fabric.state import output

env.environment = ""
env.full = False
output['running'] = False

PRODUCTION_HOST = "myproject.com"
PRODUCTION_USER = "myproject"

def dev():
    """ chooses development environment """
    env.environment = "dev"
    env.hosts = [PRODUCTION_HOST]
    env.user = PRODUCTION_USER
    print("LOCAL DEVELOPMENT ENVIRONMENT\n")

def staging():
    """ chooses testing environment """
    env.environment = "staging"
    env.hosts = ["staging.myproject.com"]
    env.user = "myproject"
    print("STAGING WEBSITE\n")

def production():
    """ chooses production environment """
    env.environment = "production"
    env.hosts = [PRODUCTION_HOST]
    env.user = PRODUCTION_USER
    print("PRODUCTION WEBSITE\n")

def full():
    """ all commands should be executed without questioning """
    env.full = True

def deploy():
    """ updates the chosen environment """
    if not env.environment:
        while env.environment not in ("dev", "staging",
            "production"):
            env.environment = prompt(red('Please specify target'
                'environment ("dev", "staging", or '
                '"production"): '))
            print
    globals()["_update_%s" % env.environment]()
```

`dev()`、`staging()`和`production()`功能为当前任务设置了合适的环境。然后，`deploy()`函数分别调用`_update_dev()`、`_update_staging()`或`_update_production()`私有函数。让我们在同一个文件中定义这些私有函数，如下所示：

*   The function for deploying in the development environment will optionally do the following tasks:
    *   使用生产数据库中的数据更新本地数据库
    *   从生产服务器下载媒体文件
    *   从 Git 存储库更新代码
    *   迁移本地数据库

    让我们在 Fabric 脚本文件中创建此函数，如下所示：

    ```py
    def _update_dev():
        """ updates development environment """
        run("")  # password request
        print

        if env.full or "y" == prompt(red("Get latest "
            "production database (y/n)?"), default="y"):
            print(green(" * creating production-database "
                "dump..."))
            run("cd ~/db_backups/ && ./backup_db.sh --latest")
            print(green(" * downloading dump..."))
            get("~/db_backups/db_latest.sql",
                "tmp/db_latest.sql")
            print(green(" * importing the dump locally..."))
            local("python manage.py dbshell < "
                "tmp/db_latest.sql && rm tmp/db_latest.sql")
            print
            if env.full or "y" == prompt("Call prepare_dev "
               "command (y/n)?", default="y"):
                print(green(" * preparing data for "
                    "development..."))
                local("python manage.py prepare_dev")
        print

        if env.full or "y" == prompt(red("Download media "
            "uploads (y/n)?"), default="y"):
            print(green(" * creating an archive of media "
                "uploads..."))
            run("cd ~/project/myproject/media/ "
                "&& tar -cz -f "
                "~/project/myproject/tmp/media.tar.gz *")
            print(green(" * downloading archive..."))
            get("~/project/myproject/tmp/media.tar.gz",
                "tmp/media.tar.gz")
            print(green(" * extracting and removing archive "
                "locally..."))
            for host in env.hosts:
                local("cd media/ "
                    "&& tar -xzf ../tmp/media.tar.gz "
                    "&& rm tmp/media.tar.gz")
            print(green(" * removing archive from the "
                "server..."))
            run("rm ~/project/myproject/tmp/media.tar.gz")
        print

        if env.full or "y" == prompt(red("Update code (y/n)?"),
            default="y"):
            print(green(" * updating code..."))
            local("git pull")
        print

        if env.full or "y" == prompt(red("Migrate database "
            "schema (y/n)?"), default="y"):
            print(green(" * migrating database schema..."))
            local("python manage.py migrate --no-initial-data")
            local("python manage.py syncdb")
        print
    ```

*   The function for deploying in a staging environment will optionally do the following tasks:
    *   设置一个维护屏幕，显示站点正在更新，访问者应该等待或稍后再来
    *   停止计划的 cron 作业
    *   从生产数据库获取最新数据
    *   从生产数据库获取最新的媒体文件
    *   从 Git 存储库中提取代码
    *   收集静态文件
    *   迁移数据库架构
    *   重新启动 Apache web 服务器
    *   启动计划的 cron 作业
    *   取消设置维护屏幕

    让我们在 Fabric 脚本中创建此函数，如下所示：

    ```py
    def _update_staging():
        """ updates testing environment """
        run("")  # password request
        print

        if env.full or "y" == prompt(red("Set under-"
            "construction screen (y/n)?"), default="y"):
            print(green(" * Setting maintenance screen"))
            run("cd ~/public_html/ "
                "&& cp .htaccess_under_construction .htaccess")
        print

        if env.full or "y" == prompt(red("Stop cron jobs "
            " (y/n)?"), default="y"):
            print(green(" * Stopping cron jobs"))
            sudo("/etc/init.d/cron stop")
        print

        if env.full or "y" == prompt(red("Get latest "
            "production database (y/n)?"), default="y"):
            print(green(" * creating production-database "
                "dump..."))
            run("cd ~/db_backups/ && ./backup_db.sh --latest")
            print(green(" * downloading dump..."))
            run("scp %(user)s@%(host)s:"
                "~/db_backups/db_latest.sql "
                "~/db_backups/db_latest.sql" % {
                    "user": PRODUCTION_USER,
                    "host": PRODUCTION_HOST,
                }
            )
            print(green(" * importing the dump locally..."))
            run("cd ~/project/myproject/ && python manage.py "
                "dbshell < ~/db_backups/db_latest.sql")
            print
            if env.full or "y" == prompt(red("Call "
                " prepare_staging command (y/n)?"),
                default="y"):
                print(green(" * preparing data for "
                    " testing..."))
                run("cd ~/project/myproject/ "
                    "&& python manage.py prepare_staging")
        print
        if env.full or "y" == prompt(red("Get latest media "
            " (y/n)?"), default="y"):
            print(green(" * updating media..."))
            run("scp -r %(user)s@%(host)s:"
                "~/project/myproject/media/* "
                " ~/project/myproject/media/" % {
                    "user": PRODUCTION_USER,
                    "host": PRODUCTION_HOST,
                }
            )
        print

        if env.full or "y" == prompt(red("Update code (y/n)?"),
            default="y"):
            print(green(" * updating code..."))
            run("cd ~/project/myproject "
                "&& git pull")
        print

        if env.full or "y" == prompt(red("Collect static "
            "files (y/n)?"), default="y"):
            print(green(" * collecting static files..."))
            run("cd ~/project/myproject "
                "&& python manage.py collectstatic --noinput")
        print

        if env.full or "y" == prompt(red('Migrate database "
            " schema (y/n)?'), default="y"):
            print(green(" * migrating database schema..."))
            run("cd ~/project/myproject "
                "&& python manage.py migrate "
                "--no-initial-data")
            run("cd ~/project/myproject "
                "&& python manage.py syncdb")
        print

        if env.full or "y" == prompt(red("Restart webserver "
            "(y/n)?"), default="y"):
            print(green(" * Restarting Apache"))
            sudo("/etc/init.d/apache2 graceful")
        print

        if env.full or "y" == prompt(red("Start cron jobs "
            "(y/n)?"), default="y"):
            print(green(" * Starting cron jobs"))
            sudo("/etc/init.d/cron start")
        print

        if env.full or "y" == prompt(red("Unset under-"
            "construction screen (y/n)?"), default="y"):
            print(green(" * Unsetting maintenance screen"))
            run("cd ~/public_html/ "
                "&& cp .htaccess_live .htaccess")
        print
    ```

*   The function for deploying in a production environment will optionally do the following tasks:
    *   设置维护屏幕，告知网站正在更新，访问者应等待或稍后返回
    *   停止计划的 cron 作业
    *   备份数据库
    *   从 Git 存储库中提取代码
    *   收集静态文件
    *   迁移数据库架构
    *   重启Apache web 服务器
    *   启动计划的 cron 作业
    *   取消设置维护屏幕

    让我们在 Fabric 脚本中创建此函数，如下所示：

    ```py
    def _update_production():
        """ updates production environment """
        if "y" != prompt(red("Are you sure you want to "
            "update " + red("production", bold=True) + \
            " website (y/n)?"), default="n"):
            return

        run("")  # password request
        print

        if env.full or "y" == prompt(red("Set under-"
            "construction screen (y/n)?"), default="y"):
            print(green(" * Setting maintenance screen"))
            run("cd ~/public_html/ "
                "&& cp .htaccess_under_construction .htaccess")
        print
        if env.full or "y" == prompt(red("Stop cron jobs"
            " (y/n)?"), default="y"):
            print(green(" * Stopping cron jobs"))
            sudo("/etc/init.d/cron stop")
        print

        if env.full or "y" == prompt(red("Backup database "
            "(y/n)?"), default="y"):
            print(green(" * creating a database dump..."))
            run("cd ~/db_backups/ "
                "&& ./backup_db.sh")
        print

        if env.full or "y" == prompt(red("Update code (y/n)?"),
            default="y"):
            print(green(" * updating code..."))
            run("cd ~/project/myproject/ "
                "&& git pull")
        print

        if env.full or "y" == prompt(red("Collect static "
            "files (y/n)?"), default="y"):
            print(green(" * collecting static files..."))
            run("cd ~/project/myproject "
                "&& python manage.py collectstatic --noinput")
        print

        if env.full or "y" == prompt(red("Migrate database "
            "schema (y/n)?"), default="y"):
            print(green(" * migrating database schema..."))
            run("cd ~/project/myproject "
                "&& python manage.py migrate "
                "--no-initial-data")
            run("cd ~/project/myproject "
                "&& python manage.py syncdb")
        print

        if env.full or "y" == prompt(red("Restart webserver "
            "(y/n)?"), default="y"):
            print(green(" * Restarting Apache"))
            sudo("/etc/init.d/apache2 graceful")
        print
        if env.full or "y" == prompt(red("Start cron jobs "
            "(y/n)?"), default="y"):
            print(green(" * Starting cron jobs"))
            sudo("/etc/init.d/cron start")
        print

        if env.full or "y" == prompt(red("Unset under-"
            "construction screen (y/n)?"), default="y"):
            print(green(" * Unsetting maintenance screen"))
            run("cd ~/public_html/ "
                "&& cp .htaccess_live .htaccess")
        print
    ```

## 它是如何工作的。。。

`fabfile.py`文件中的每个非私有函数都成为一个可能的参数，可以从命令行工具调用。要查看所有可用的功能，请运行以下命令：

```py
(myproject_env)$ fab --list
Available commands:
 deploy      updates the chosen environment
 dev         chooses development environment
 full        all commands should be executed without questioning
 production  chooses production environment
 staging     chooses testing environment

```

这些函数的调用顺序与传递给结构脚本的顺序相同，因此在部署到不同环境时，需要注意参数的顺序：

*   To deploy in a development environment, you would run the following command:

    ```py
    (myproject_env)$ fab dev deploy

    ```

    这将向您提出与以下类似的问题：

    ```py
    Get latest production database (y/n)? [y] _

    ```

    当回答为肯定时，将执行特定步骤。

*   要在临时环境中部署，您需要运行以下命令：

    ```py
    (myproject_env)$ fab staging deploy

    ```

*   最后，要在生产环境中部署，您需要运行以下命令：

    ```py
    (myproject_env)$ fab production deploy

    ```

对于部署的每个步骤，都会询问您是要执行还是跳过。如果要在没有任何提示的情况下执行所有步骤（密码请求除外），请在部署脚本中添加一个`full`参数，如下所示：

```py
(myproject_env)$ fab dev full deploy

```

Fabric 脚本利用了以下几个基本功能：

*   `local()`：此功能用于在当前计算机本地运行命令
*   `run()`：此功能用于在远程服务器上以指定用户的身份运行命令
*   `prompt()`：此功能用于提问
*   `get()`：此功能用于将文件从远程服务器下载到本地计算机
*   `sudo()`：此函数用于以 root（或其他）用户身份运行命令

结构使用安全外壳连接在远程服务器上执行任务。每个`run()`或`sudo()`命令作为单独的连接执行；因此，当您想要一次执行多个命令时，您必须在服务器上创建一个`bash`脚本并从 Fabric 调用它，或者必须使用`&&`shell 操作符分离命令，只有在前一个命令成功时，才会执行下一个命令。

我们还使用`scp`命令将文件从生产服务器复制到临时服务器。`scp`从指定目录递归复制所有文件的语法如下：

```py
scp -r myproject_user@myproject.com:/path/on/production/server/* \
/path/on/staging/server/

```

为了使输出更加用户友好，我们使用了如下颜色：

```py
print(green(" * migrating database schema..."))

```

部署脚本希望您有两个管理命令：`prepare_dev`和`prepare_staging`。由您决定在这些命令中添加什么。基本上，您可以将超级用户密码更改为更简单的密码，并在那里更改站点域。如果您不需要这些功能，只需将其从结构脚本中删除即可。

一般的经验法则是，如果将任何敏感数据保存在 Git 存储库中，则不要将其存储在 Fabric 脚本中。因此，例如，为了备份数据库，我们在远程生产服务器上调用`backup_db.sh`脚本。此类文件的内容可能类似于以下内容：

```py
# ~/db_backups/backup_db.sh
#!/bin/bash
if [[ $1 = '--latest' ]]
then
    today="latest"
else
    today=$(date +%Y-%m-%d-%H%M)
fi
mysqldump --opt -u my_db_user -pmy_db_password myproject > \
    db_$today.sql
```

您可以使用以下命令使其可执行：

```py
$ chmod +x backup_db.sh

```

当前面的命令在没有参数的情况下运行时，它将创建一个数据库转储，文件名中有日期和时间，例如`db_2014-04-24-1400.sql`，如下所示：

```py
$ ./backup_db.sh

```

当传递`--latest`参数时，转储文件名为`db_latest.sql`：

```py
$ ./backup_db.sh --latest

```

## 还有更多。。。

Fabric 脚本不仅可用于部署，还可用于您需要在远程服务器上执行的任何例程，例如，当您使用 Rosetta 工具在线翻译`*.po`文件时收集可翻译字符串，当您使用 Haystack 进行全文搜索时重建搜索索引，按需创建备份，调用自定义管理命令，等等。

要了解有关 Fabric 的更多信息，请参考以下 URL:[http://docs.fabfile.org/en/1.10/](http://docs.fabfile.org/en/1.10/) 。

## 另见

*   使用 mod_wsgi 配方在 Apache 上部署的**