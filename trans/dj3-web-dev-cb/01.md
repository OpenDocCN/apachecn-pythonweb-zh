# 一、Django 3.0 入门

在本章中，我们将介绍以下主题：

*   使用虚拟环境
*   创建项目文件结构
*   用 pip 处理项目依赖关系
*   为开发、测试、暂存和生产环境配置设置
*   在设置中定义相对路径
*   处理敏感设置
*   在项目中包含外部依赖项
*   动态设置`STATIC_URL`
*   将 UTF-8 设置为 MySQL 配置的默认编码
*   创建 Git`ignore`文件
*   删除 Python 编译文件
*   遵守 Python 文件中的导入顺序
*   创建应用程序配置
*   定义可覆盖的应用程序设置
*   使用 Django、Gunicorn、Nginx 和 PostgreSQL 的 Docker 容器

# 介绍

在本章中，我们将看到在使用 Python3 启动 Django3.0 新项目时要遵循的一些有价值的实践。我们选择了最有用的方法来处理可伸缩的项目布局、设置和配置，无论是使用 virtualenv 还是 Docker 来管理您的项目。

我们假设您已经熟悉 Django、Git 版本控制、MySQL 以及 PostgreSQL 数据库的基础知识，以及命令行使用。我们还假设您使用的是基于 Unix 的操作系统，如 macOS 或 Linux。在基于 Unix 的平台上使用 Django 进行开发更有意义，因为 Django 网站很可能发布在 Linux 服务器上，这意味着您可以建立以相同方式工作的例程，无论您是在开发还是部署。如果您在 Windows 上本地使用 Django，则例程类似；然而，它们并不总是相同的。

在开发环境中使用 Docker，无论您的本地平台如何，都可以通过部署提高应用程序的可移植性，因为 Docker 容器中的环境可以与部署服务器的环境精确匹配。我们还应该提到，对于本章中的配方，我们假设您的本地计算机上已经安装了相应的版本控制系统和数据库服务器，无论您是否使用 Docker 进行开发。

# 技术要求

要使用本书的代码，您需要 Python 的最新稳定版本，可从[下载 https://www.python.org/downloads/](https://www.python.org/downloads/) 。在撰写本文时，最新版本是 3.8.X。您还需要一个 MySQL 或 PostgreSQL 数据库。您可以从[下载 MySQL 数据库服务器 https://dev.mysql.com/downloads/](https://dev.mysql.com/downloads/) 。PostgreSQL 数据库服务器可从[下载 https://www.postgresql.org/download/](https://www.postgresql.org/download/) 。其他要求将在特定配方中提出。

您可以在 GitHub 存储库的[目录中找到本章的所有代码 https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition) 。

# 使用虚拟环境

您很可能会在计算机上开发多个 Django 项目。某些模块（如 virtualenv、setuptools、wheel 或 Ansible）可以安装一次，然后为所有项目共享。其他模块，如 Django、第三方 Python 库和 Django 应用程序，需要彼此隔离。virtualenv 工具是一个将所有 Python 项目分离并将它们保留在自己领域中的实用工具。在这个食谱中，我们将看到如何使用它。

# 准备

要管理 Python 包，您需要 pip。如果您使用的是 Python 3.4+，那么它将包含在 Python 安装中。如果您使用的是另一个版本的 Python，您可以通过在[http 执行安装说明来安装 pip：/​/​皮普。​读道。​组织机构/​嗯/​稳定/安装/](https://pip.pypa.io/en/stable/installing/)​. 让我们升级共享 Python 模块、pip、setuptools 和控制盘：

```py
$ sudo pip3 install --upgrade pip setuptools wheel
```

从 3.3 版开始，虚拟环境就被内置到 Python 中。

# 怎么做。。。

安装了先决条件后，创建一个目录，将所有 Django 项目存储在其中，例如，主目录下的`projects`。创建目录后，请执行以下步骤：

1.  转到新创建的目录，创建一个使用共享系统站点包的虚拟环境：

```py
$ cd ~/projects
$ mkdir myproject_website
$ cd myproject_website
$ python3 -m venv env
```

2.  要使用新创建的虚拟环境，需要在当前 shell 中执行激活脚本。这可以通过以下命令完成：

```py
$ source env/bin/activate
```

3.  根据您使用的 shell，`source`命令可能不可用。另一种来源文件的方法是使用以下命令，该命令具有相同的结果（注意点和`env`之间的空格）：

```py
$ . env/bin/activate
```

4.  您将看到命令行工具的提示会获得项目名称的前缀，如下所示：

```py
(env)$
```

5.  要退出虚拟环境，请键入以下命令：

```py
(env)$ deactivate
```

# 它是如何工作的。。。

创建虚拟环境时，会创建一些特定的目录（`bin`、`include`和`lib`），以存储 Python 安装的副本，并定义一些共享 Python 路径。当虚拟环境被激活时，您使用`pip`或`easy_install`安装的任何东西都将被放入虚拟环境的站点软件包中并由其使用，而不是 Python 安装的全局站点软件包。

要在虚拟环境中安装最新的 Django 3.0.x，请键入以下命令：

```py
(env)$ pip install "Django~=3.0.0"
```

# 另见

*   *创建项目文件结构*配方
*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方
*   [第 12 章](12.html)、*部署*中针对暂存环境配方的*使用 mod_wsgi 在 Apache 上部署*
*   [第 12 章](12.html)*中*部署*中针对生产环境*配方使用 mod_wsgi 在 Apache 上部署
*   [第 12 章](12.html)*中的*部署在 Nginx 和 Gunicorn 上，用于搭建环境*配方，部署*
*   [第 12 章](12.html)*中*部署在 Nginx 和 Gunicorn 上的生产环境*配方，部署*

# 创建项目文件结构

项目的一致文件结构使您组织良好，工作效率更高。定义了基本工作流后，您可以更快地进入业务逻辑并创建出色的项目。

# 准备

如果您还没有这样做，请创建一个`~/projects`目录，您将在其中保存所有 Django 项目（您可以在*使用虚拟环境*配方中了解这一点）。

然后，为您的特定项目创建一个目录，例如，`myproject_website`。在`env`目录中启动虚拟环境。激活它并在那里安装 Django，如前一个配方中所述。我们建议为与项目相关的本地 shell 脚本添加`commands`目录，为数据库转储添加`db_backups`目录，为网站设计文件添加`mockups`目录，最重要的是为 Django 项目添加`src`目录。

# 怎么做。。。

按照以下步骤为项目创建文件结构：

1.  激活虚拟环境后，转到`src`目录并启动一个新的 Django 项目，如下所示：

```py
(env)$ django-admin.py startproject myproject
```

执行的命令将创建一个名为`myproject`的目录，其中包含项目文件。此目录将包含一个 Python 模块，也称为`myproject`。为了清晰方便，我们将顶层目录重命名为`django-myproject`。它是您将置于版本控制之下的目录，因此它将有一个`.git`或类似命名的子目录。

2.  在`django-myproject`目录中，创建一个`README.md`文件，向新的 developdjango-admin.py startproject myprojecters 描述您的项目。
3.  `django-myproject`目录还将包含以下内容：

*   您的项目的 Python 包，名为`myproject`。
*   您的项目对 Django 框架和其他外部依赖项的 pip 需求（请阅读*使用 pip*方法处理项目依赖项中的内容）。
*   项目许可证保存在`LICENSE`文件中。如果您的项目是开源的，您可以从[中选择最流行的许可证之一 https://choosealicense.com](https://choosealicense.com) 。

4.  在项目的根目录`django-myproject`中，创建以下内容：

*   用于项目上传的`media`目录
*   收集的静态文件的`static`目录
*   项目翻译的`locale`目录
*   当您不能使用 pip 需求时，此项目中包含的外部依赖项的`externals`目录

5.  `myproject`目录应包含以下目录和文件：

*   `apps`目录，您将在其中放置项目的所有内部 Django 应用程序。建议您使用一个名为`core`或`utils`的应用程序来实现项目的共享功能。
*   项目设置的`settings`目录（请阅读*为开发、测试、暂存和生产环境配置设置*配方中的内容）。
*   项目特定静态文件的`site_static`目录。
*   项目 HTML 模板的`templates`目录。
*   项目 URL 配置的`urls.py`文件。
*   项目 web 服务器配置的`wsgi.py`文件。

6.  在`site_static`目录中，创建`site`目录作为站点特定静态文件的名称空间。然后，我们将在其中的分类子目录之间划分静态文件。例如，请参见以下内容：

*   `scss`用于 Sass 文件（可选）
*   `css`用于生成的简化**级联样式表**（**CSS**）
*   `img`用于造型图像、装饰和徽标
*   `js`针对项目的 JavaScriptdjango-admin.py startproject myproject
*   `vendor`任何第三方模块，结合所有类型的文件，如 TinyMCE 富文本编辑器

7.  除`site`目录外，`site_static`目录还可能包含被覆盖的第三方应用程序的静态目录，例如，它可能包含`cms`，覆盖来自 Django CMS 的静态文件。要从 Sass 生成 CSS 文件并缩小 JavaScript 文件，可以使用 CodeKit（[https://codekitapp.com/](https://codekitapp.com/) 或预印本（[https://prepros.io/](https://prepros.io/) 具有图形用户界面的应用程序。

8.  将应用程序分隔的模板放在`templates`目录中。如果模板文件代表一个页面（例如，`change_item.html`或`item_list.html`，则直接将其放入应用程序的模板目录中。如果该模板包含在另一个模板中（例如，`similar_items.html`，则将其放入`includes`子目录中。此外，模板目录可以包含一个名为`utils`的目录，用于全局可重用的代码段，例如分页和语言选择器。

# 它是如何工作的。。。

完整项目的整个文件结构类似于以下内容：

```py
myproject_website/
├── commands/
├── db_backups/
├── mockups/
├── src/
│   └── django-myproject/
│       ├── externals/
│       │   ├── apps/
│       │   │   └── README.md
│       │   └── libs/
│       │       └── README.md
│       ├── locale/
│       ├── media/
│       ├── myproject/
│       │   ├── apps/
│       │   │   ├── core/
│       │   │   │   ├── __init__.py
│       │   │   │   └── versioning.py
│       │   │   └── __init__.py
│       │   ├── settings/
│       │   │   ├── __init__.py
│       │   │   ├── _base.py
│       │   │   ├── dev.py
│       │   │   ├── production.py
│       │   │   ├── sample_secrets.json
│       │   │   ├── secrets.json
│       │   │   ├── staging.py
│       │   │   └── test.py
│       │   ├── site_static/
│       │   │   └── site/
│       │   │  django-admin.py startproject myproject     ├── css/
│       │   │       │   └── style.css
│       │   │       ├── img/
│       │   │       │   ├── favicon-16x16.png
│       │   │       │   ├── favicon-32x32.png
│       │   │       │   └── favicon.ico
│       │   │       ├── js/
│       │   │       │   └── main.js
│       │   │       └── scss/
│       │   │           └── style.scss
│       │   ├── templates/
│       │   │   ├── base.html
│       │   │   └── index.html
│       │   ├── __init__.py
│       │   ├── urls.py
│       │   └── wsgi.py
│       ├── requirements/
│       │   ├── _base.txt
│       │   ├── dev.txt
│       │   ├── production.txt
│       │   ├── staging.txt
│       │   └── test.txt
│       ├── static/
│       ├── LICENSE
│       └── manage.py
└── env/
```

# 还有更多。。。

要以我们刚才描述的方式加速项目的创建，您可以使用[中的项目样板文件 https://github.com/archatas/django-myproject](https://github.com/archatas/django-myproject) 。下载代码后，执行全局搜索，并用对您的项目有意义的名称替换`myproject`，这样您就可以开始了。

# 另见

*   *使用 pip*配方处理项目依赖关系
*   *在您的项目*配方中包含外部依赖项
*   *为开发、测试、暂存和生产环境配置设置*配方
*   [第 12 章](12.html)**中的*使用 mod_wsgi 在 Apache 上部署登台环境*配方，部署**
*   [第 12 章](12.html)*中*部署*中针对生产环境*配方使用 mod_wsgi 在 Apache 上部署
*   [第 12 章](12.html)*中的*部署在 Nginx 和 Gunicorn 上，用于搭建环境*配方，部署*
*   [第 12 章](12.html)*中*部署在 Nginx 和 Gunicorn 上的生产环境*配方，部署*

# 用 pip 处理项目依赖关系

安装和管理 Python 包最方便的工具是 pip。您可以将要安装的软件包列表定义为文本文件的内容，而不是逐个安装软件包。我们可以将文本文件传递到 pip 工具中，然后该工具将自动处理列表中所有软件包的安装。这种方法的另一个好处是包列表可以存储在版本控制中。

一般来说，拥有一个与您的生产环境直接匹配的需求文件是理想的，而且通常已经足够了。您可以在开发计算机上更改版本或添加和删除依赖项，然后通过版本控制对其进行管理。这样，从一组依赖项（以及相关的代码更改）切换到另一组依赖项就可以像切换分支一样简单。

在某些情况下，环境差异很大，您需要至少有两个不同的项目实例：

*   创建新功能的开发环境
*   公共网站环境，通常称为托管服务器中的生产环境

可能有其他开发人员的开发环境，或者在开发过程中需要但在生产中不必要的特殊工具。您还可能有一个测试和登台环境，以便在本地和公共网站（如安装）中测试项目。

为了获得良好的可维护性，您应该能够为开发、测试、登台和生产环境安装所需的 Python 模块。一些模块将被共享，其中一些模块将特定于环境的子集。在本食谱中，我们将学习如何组织多个环境的项目依赖关系，并使用 pip 管理它们。

# 准备

在使用这个方法之前，您需要准备一个 Django 项目，安装 pip 并激活一个虚拟环境。有关如何执行此操作的更多信息，请阅读*使用虚拟环境*的方法。

# 怎么做。。。

逐个执行以下步骤，为您的虚拟环境 Django 项目准备 pip 需求：

1.  让我们转到版本控制下的 Django 项目，并使用以下文本文件创建一个`requirements`目录：

*   `_base.txt`用于共享模块
*   `dev.txt`针对开发环境
*   `test.txt`用于测试环境
*   `staging.txt`用于暂存环境
*   `production.txt`用于生产

2.  编辑`_base.txt`并逐行添加在所有环境中共享的 Python 模块：

```py
# requirements/_base.txt
Django~=3.0.4
djangorestframework
-e git://github.com/omab/python-social-auth.git@6b1e301c79#egg=python-social-auth
```

3.  如果某一特定环境的需求与`_base.txt`相同，则在该环境的需求文件中增加包含`_base.txt`的行，如下例所示：

```py
# requirements/production.txt
-r _base.txt
```

4.  如果某个环境有具体要求，则在`_base.txt`包含后添加，如下代码所示：

```py
# requirements/dev.txt
-r _base.txt
coverage
django-debug-toolbar
selenium
```

5.  您可以在虚拟环境中运行以下命令，以便为开发环境安装所有必需的依赖项（或为其他环境安装类似命令），如下所示：

```py
(env)$ pip install -r requirements/dev.txt
```

# 它是如何工作的。。。

前面的`pip install`命令，无论是在虚拟环境中还是在全局级别显式执行，都会从`requirements/_base.txt`和`requirements/dev.txt`下载并安装所有项目依赖项。如您所见，您可以指定 Django 框架所需的模块版本，甚至可以直接从 Git 存储库中的特定提交安装它，就像我们示例中的`python-social-auth`一样。

当您的项目中有许多依赖项时，对于 Python 模块的发布版本，最好只使用一个狭窄的发布版本范围。这样，您就可以更加确信，项目完整性不会因为依赖项中的更新而被破坏，因为这些更新可能包含冲突或向后不兼容。在部署项目或将其交给新开发人员时，这一点尤为重要。

如果您已经用 pip 逐个手动安装了项目需求，您可以在您的虚拟环境中使用以下命令生成`requirements/_base.txt`文件：

```py
(env)$ pip freeze > requirements/_base.txt
```

# 还有更多。。。

如果您希望保持简单，并且确信对于所有环境，您将使用相同的依赖项，那么您可以使用一个名为`requirements.txt`的文件来满足您的需求，该文件由定义生成，如下所示：

```py
(env)$ pip freeze > requirements.txt
```

要在新的虚拟环境中安装模块，只需使用以下命令：

```py
(env)$ pip install -r requirements.txt
```

如果您需要从另一个版本控制系统或本地路径安装 Python 库，那么您可以从[的官方文档中了解有关 pip 的更多信息 https://pip.pypa.io/en/stable/user_guide/](https://pip.pypa.io/en/stable/user_guide/) 。

另一种越来越流行的管理 Python 依赖关系的方法是 Pipenv。您可以在[获取并了解 https://github.com/pypa/pipenv](https://github.com/pypa/pipenv) 。

# 另见

*   *使用虚拟环境*配方
*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方
*   *在您的项目*配方中包含外部依赖项
*   *为开发、测试、暂存和生产环境配置设置*配方

# 为开发、测试、暂存和生产环境配置设置

如前所述，您将在开发环境中创建新功能，在测试环境中测试它们，然后将网站放在登台服务器上，让其他人尝试新功能。然后，该网站将部署到生产服务器，供公众访问。这些环境中的每一个都可以有特定的设置，您将学习如何在此配方中组织它们。

# 准备

在 Django 项目中，我们将为每个环境创建设置：开发、测试、登台和生产。

# 怎么做。。。

按照以下步骤配置项目设置：

1.  在`myproject`目录中，使用以下文件创建一个`settings`Python 模块：

*   `__init__.py`使设置目录成为 Python 模块。
*   `_base.py`用于共享设置
*   `dev.py`用于开发设置
*   `test.py`用于测试设置
*   `staging.py`用于分段设置
*   `production.py`用于生产设置

2.  将启动新 Django 项目时自动创建的`settings.py`内容复制到`settings/_base.py`。然后，删除`settings.py`。
3.  将`settings/_base.py`中的`BASE_DIR`改为向上一级。它首先应如下所示：

```py
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
```

更改后，它应该如下所示：

```py
BASE_DIR = os.path.dirname(
    os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
)
```

4.  如果一个环境的设置与共享的设置相同，那么只需从`_base.py`那里
    导入所有内容，如下所示：

```py
# myproject/settings/production.py
from ._base import *
```

5.  在其他文件中为您的特定环境应用要附加或覆盖的设置。例如，开发环境设置应转到`dev.py`，如以下代码段所示：

```py
# myproject/settings/dev.py
from ._base import *
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
```

6.  通过更改以下行，将`manage.py`和`myproject/wsgi.py`文件修改为默认使用环境设置之一：

```py
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
```

7.  您应将此行更改为以下内容：

```py
os.environ.setdefault('DJANGO_SETTINGS_MODULE',  'myproject.settings.production')
```

# 它是如何工作的。。。

默认情况下，Django 管理命令使用`myproject/settings.py`中的设置。使用此配方中定义的方法，我们可以在`config`目录中保留版本控制下所有环境所需的所有非敏感设置。另一方面，`settings.py`文件本身将被版本控制忽略，并且只包含当前开发、测试、暂存或生产环境所需的设置。

对于每个环境，建议您分别在 PyCharm 设置、`env/bin/activate`脚本或`.bash_profile`中设置`DJANGO_SETTINGS_MODULE`环境变量。

# 另见

*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方
*   *处理敏感设置*配方
*   *在*设置中定义相对路径
*   *创建 Git 忽略文件*配方

# 在设置中定义相对路径

Django 要求您在设置中定义不同的文件路径，例如媒体根目录、静态文件根目录、模板路径和翻译文件路径。对于项目的每个开发人员，路径可能不同，因为虚拟环境可以在任何地方设置，并且用户可能正在 macOS、Linux 或 Windows 上工作。即使项目包装在 Docker 容器中，定义绝对路径也会降低可维护性和可移植性。在任何情况下，都有一种方法可以动态定义这些路径，以便它们相对于 Django 项目目录。

# 准备

启动 Django 项目并打开`settings/_base.py`。

# 怎么做。。。

相应地修改与路径相关的设置，而不是对本地目录的路径进行硬编码，如下所示：

```py
# settings/_base.py
import os
BASE_DIR = os.path.dirname(
    os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
)
# ...
TEMPLATES = [{
    # ...
    DIRS: [
       os.path.join(BASE_DIR, 'myproject', 'templates'),
    ],
    # ...
}]
# ...
LOCALE_PATHS = [
    os.path.join(BASE_DIR, 'locale'),
]
# ...
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'myproject', 'site_static'),
]
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
```

# 它是如何工作的。。。

默认情况下，Django 设置包括一个`BASE_DIR`值，该值是指向包含`manage.py`的目录的绝对路径（通常比`settings.py`文件高一级或比`settings/_base.py`高两级）。然后，我们使用`os.path.join()`函数设置与`BASE_DIR`相关的所有路径。

根据我们在*创建项目文件结构*配方中设置的目录布局，我们将插入`'myproject'`作为前面一些示例的中间路径段，因为相关文件夹是在该配方中创建的。

# 另见

*   *创建项目文件结构*配方
*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方
*   *在您的项目*配方中包含外部依赖项

# 处理敏感设置

在配置 Django 项目时，您肯定会处理一些敏感信息，例如密码和 API 密钥。不建议您将该信息置于版本控制之下。有两种主要的方法来存储这些信息：在环境变量中和在单独的未跟踪文件中。在本食谱中，我们将探讨这两种情况。

# 准备

项目的大多数设置将在所有环境中共享，并保存在版本控制中。这些可以直接在设置文件中定义；但是，会有一些特定于项目实例环境的设置，或者是敏感的设置，需要额外的安全性，例如数据库或电子邮件设置。我们将使用环境变量公开这些。

# 怎么做。。。

要从环境变量中读取敏感设置，请执行以下步骤：

1.  在`settings/_base.py`开头，定义`get_secret()`功能如下：

```py
# settings/_base.py
import os
from django.core.exceptions import ImproperlyConfigured

def get_secret(setting):
    """Get the secret variable or return explicit exception."""
    try:
        return os.environ[setting]
    except KeyError:
        error_msg = f'Set the {setting} environment variable'
        raise ImproperlyConfigured(error_msg)
```

2.  然后，当您需要定义敏感值时，使用`get_secret()`函数，如下例所示：

```py
SECRET_KEY = get_secret('DJANGO_SECRET_KEY')

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': get_secret('DATABASE_NAME'),
        'USER': get_secret('DATABASE_USER'),
        'PASSWORD': get_secret('DATABASE_PASSWORD'),
        'HOST': 'db',
        'PORT': '5432',
    }
}
```

# 它是如何工作的。。。

如果在未设置环境变量的情况下运行 Django 管理命令，您将看到一条消息引发的错误，例如设置 Django_SECRET_KEY 环境变量。

您可以在 PyCharm 配置、远程服务器配置控制台、`env/bin/activate`脚本、`.bash_profile`中或直接在终端中设置环境变量，如下所示：

```py
$ export DJANGO_SECRET_KEY="change-this-to-50-characters-long-random-
  string"
$ export DATABASE_NAME="myproject"
$ export DATABASE_USER="myproject"
$ export DATABASE_PASSWORD="change-this-to-database-password"
```

请注意，对于 Django 项目配置中需要的所有密码、API 密钥和任何其他敏感信息，都应该使用`get_secret()`函数。

# 还有更多。。。

除了环境变量，您还可以使用带有敏感信息的文本文件，这些敏感信息在版本控制下不会被跟踪。它们可以是 YAML、INI、CSV 或 JSON 文件，放在硬盘上的某个位置。例如，对于 JSON 文件，您将具有`get_secret()`函数，如下所示：

```py
# settings/_base.py
import os
import json

with open(os.path.join(os.path.dirname(__file__), 'secrets.json'), 'r') 
 as f:
    secrets = json.loads(f.read())

def get_secret(setting):
    """Get the secret variable or return explicit exception."""
    try:
        return secrets[setting]
    except KeyError:
        error_msg = f'Set the {setting} secret variable'
        raise ImproperlyConfigured(error_msg)
```

这将从设置目录中读取一个`secrets.json`文件，并希望它至少具有以下结构：

```py
{
    "DATABASE_NAME": "myproject",
    "DATABASE_USER": "myproject",
    "DATABASE_PASSWORD": "change-this-to-database-password",
    "DJANGO_SECRET_KEY": "change-this-to-50-characters-long-random-string"
}
```

确保`secrets.json`文件在版本控制中被忽略，但为了方便起见，您可以使用空值创建`sample_secrets.json`并将其置于版本控制下：

```py
{
    "DATABASE_NAME": "",
    "DATABASE_USER": "",
    "DATABASE_PASSWORD": "",
    "DJANGO_SECRET_KEY": "change-this-to-50-characters-long-random-string"
}
```

# 另见

*   *创建项目文件结构*配方
*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方

# 在项目中包含外部依赖项

有时，无法使用 pip 安装外部依赖项，必须将其直接包含在项目中，例如在以下情况下：

*   当您有一个修补过的第三方应用程序，您自己修复了一个 bug 或添加了一个未被项目所有者接受的功能时
*   当您需要使用在**Python 包索引**（**PyPI**）或公共版本控制存储库无法访问的私有应用程序时
*   当您需要使用 PyPI 不再提供的依赖项的旧版本时

*在您的项目*中包含外部依赖项可确保每当开发人员升级依赖模块时，所有其他开发人员都将在版本控制系统的下一次更新中收到升级版本。

# 准备

您应该从虚拟环境下的 Django 项目开始。

# 怎么做。。。

对于虚拟环境项目，逐个执行以下步骤：

1.  如果您还没有这样做，请在 Django 项目目录`django-myproject`下创建一个`externals`目录。
2.  然后，在其下创建`libs`和`apps`目录。`libs`目录用于项目所需的 Python 模块，例如 Boto、Requests、Twython 和 Whoosh。`apps`目录用于第三方 Django 应用程序，例如 Django CMS、Django Haystack 和 Django storages。
    我们强烈建议您在`libs`和`apps`目录中创建`README.md`文件，在那里您可以提到每个模块的用途、使用的版本或修订版本以及它们的来源。
3.  目录结构应类似于以下内容：

```py
externals/
 ├── apps/
 │   ├── cms/
 │   ├── haystack/
 │   ├── storages/
 │   └── README.md
 └── libs/
     ├── boto/
     ├── requests/
     ├── twython/
     └── README.md
```

4.  下一步是将外部库和应用程序放在 Python 路径下，以便识别它们，就好像它们已安装一样。这可以通过在设置中添加以下代码来完成：

```py
# settings/_base.py
import os
import sys
BASE_DIR = os.path.dirname(
    os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
)
EXTERNAL_BASE = os.path.join(BASE_DIR, "externals")
EXTERNAL_LIBS_PATH = os.path.join(EXTERNAL_BASE, "libs")
EXTERNAL_APPS_PATH = os.path.join(EXTERNAL_BASE, "apps")
sys.path = ["", EXTERNAL_LIBS_PATH, EXTERNAL_APPS_PATH] + sys.path
```

# 它是如何工作的。。。

如果可以运行 Python 并导入该模块，那么模块就应该位于 Python 路径下。将模块置于 Python 路径下的方法之一是在导入位于异常位置的模块之前修改`sys.path`变量。`sys.path`的值由设置文件指定，是一个目录列表，从当前目录的空字符串开始，然后是项目中的目录，最后是 Python 安装的全局共享目录。您可以在 Python shell 中看到`sys.path`的值，如下所示：

```py
(env)$ python manage.py shell
>>> import sys
>>> sys.path
```

当尝试导入模块时，Python 会在此列表中搜索该模块并返回找到的第一个结果。

因此，我们首先定义`BASE_DIR`变量，它是`django-myproject`或高于`myproject/settings/_base.py`三个级别的绝对路径。然后，我们定义了与`BASE_DIR`相关的`EXTERNAL_LIBS_PATH`和`EXTERNAL_APPS_PATH`变量。最后，我们修改了`sys.path`属性，将新路径添加到列表的开头。注意，我们还添加了一个空字符串作为搜索的第一个路径，这意味着在检查其他 Python 路径之前，应该首先检查任何模块的当前目录。

这种包含外部库的方式不适用于具有 C 语言绑定的 Python 包，例如，`lxml`。对于这种依赖关系，我们建议使用在用 pip 方法处理项目依赖关系的*中引入的 pip 要求。*

# 另见

*   *创建项目文件结构*配方
*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方
*   *使用 pip*配方处理项目依赖关系
*   *在*设置中定义相对路径
*   *使用[第 10 章](http://bells)*中的 Django shell*配方，铃铛和哨子*

# 动态设置静态 URL

如果将`STATIC_URL`设置为静态值，则每次更新 CSS 文件、JavaScript 文件或图像时，您和您的网站访问者都需要清除浏览器缓存以查看更改。清除浏览器缓存有一个技巧。最新变更的时间戳如`STATIC_URL`所示。每当代码更新时，访问者的浏览器将强制加载所有新的静态文件。

在这个配方中，我们将看到如何为 Git 用户在`STATIC_URL`中添加时间戳。

# 准备

确保您的项目处于 Git 版本控制之下，并且您在设置中定义了`BASE_DIR`，如设置配方中的*定义相对路径所示。*

# 怎么做。。。

将 Git 时间戳置于`STATIC_URL`设置中的过程包括以下两个步骤：

1.  如果您还没有这样做，请在 Django 项目中创建`myproject.apps.core`应用程序。您还应该在那里创建一个`versioning.py`文件：

```py
# versioning.py
import subprocess
from datetime import datetime

def get_git_changeset_timestamp(absolute_path):
    repo_dir = absolute_path
    git_log = subprocess.Popen(
        "git log --pretty=format:%ct --quiet -1 HEAD",
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=True,
        cwd=repo_dir,
        universal_newlines=True,
    )

    timestamp = git_log.communicate()[0]
    try:
        timestamp = datetime.utcfromtimestamp(int(timestamp))
    except ValueError:
        # Fallback to current timestamp
        return datetime.now().strftime('%Y%m%d%H%M%S')
    changeset_timestamp = timestamp.strftime('%Y%m%d%H%M%S')
    return changeset_timestamp
```

2.  在设置中导入新创建的`get_git_changeset_timestamp()`功能，并将其用于`STATIC_URL`路径，如下所示：

```py
# settings/_base.py
from myproject.apps.core.versioning import get_git_changeset_timestamp
# ...
timestamp = get_git_changeset_timestamp(BASE_DIR)
STATIC_URL = f'/static/{timestamp}/'
```

# 它是如何工作的。。。

`get_git_changeset_timestamp()`函数以`absolute_path`目录为参数，用参数调用`git log`shell 命令，显示目录中 HEAD 修订的 Unix 时间戳。我们将`BASE_DIR`传递给函数，因为我们确信它处于版本控制之下。时间戳被解析，转换成由返回的年、月、日、小时、分钟和秒组成的字符串，然后包含在`STATIC_URL`的定义中。

# 还有更多。。。

在某些情况下，仅当您的每个环境都包含项目的完整 Git 存储库时，此方法才有效。例如，当您使用 Heroku 或 Docker 进行部署时，您无权访问 Git 存储库和远程服务器中的`git log`命令。为了使`STATIC_URL`具有动态片段，您必须从文本文件（例如，`myproject/settings/last-modified.txt`）中读取时间戳，该文件应随每次提交而更新。

在这种情况下，您的设置将包含以下行：

```py
# settings/_base.py
with open(os.path.join(BASE_DIR, 'myproject', 'settings', 'last-update.txt'), 'r') as f:
    timestamp = f.readline().strip()

STATIC_URL = f'/static/{timestamp}/'
```

您可以使用预提交挂钩更新 Git 存储库`last-modified.txt`。这是一个可执行的 bash 脚本，应该被称为`pre-commit`并放在`django-myproject/.git/hooks/`下：

```py
# django-myproject/.git/hooks/pre-commit
#!/usr/bin/env python
from subprocess import check_output, CalledProcessError
import os
from datetime import datetime

def root():
    ''' returns the absolute path of the repository root '''
    try:
        base = check_output(['git', 'rev-parse', '--show-toplevel'])
    except CalledProcessError:
        raise IOError('Current working directory is not a git repository')
    return base.decode('utf-8').strip()

def abspath(relpath):
    ''' returns the absolute path for a path given relative to the root of
        the git repository
    '''
    return os.path.join(root(), relpath)

def add_to_git(file_path):
    ''' adds a file to git '''
    try:
        base = check_output(['git', 'add', file_path])
    except CalledProcessError:
        raise IOError('Current working directory is not a git repository')
    return base.decode('utf-8').strip()

def main():
    file_path = abspath("myproject/settings/last-update.txt")

    with open(file_path, 'w') as f:
        f.write(datetime.now().strftime("%Y%m%d%H%M%S"))

    add_to_git(file_path)

if __name__ == '__main__':
    main()
```

每当您提交到 Git 存储库时，该脚本将更新`last-modified.txt`，并将该文件添加到 Git 索引中。

# 另见

*   *创建 Git 忽略文件*配方

# 将 UTF-8 设置为 MySQL 配置的默认编码

MySQL 自称是最流行的开源数据库。在这个配方中，我们将告诉您如何将 UTF-8 设置为它的默认编码。请注意，如果不在数据库配置中设置此编码，则可能会出现默认情况，即在 UTF-8 编码的数据中使用 LATIN1。每当使用欧元等符号时，这将导致数据库错误。此方法还可以避免将数据库数据从 LATIN1 转换为 UTF-8 的困难，特别是当一些表用 LATIN1 编码，而另一些表用 UTF-8 编码时。

# 准备

确保安装了 MySQL 数据库管理系统和**mysqlclient**Python 模块，并且在项目设置中使用了 MySQL 引擎。

# 怎么做。。。

在您喜爱的编辑器中打开`/etc/mysql/my.cnf`MySQL 配置文件，并确保在`[client]`、`[mysql]`和`[mysqld]`部分中设置了以下设置，如下所示：

```py
# /etc/mysql/my.cnf
[client]
default-character-set = utf8

[mysql]
default-character-set = utf8

[mysqld]
collation-server = utf8_unicode_ci
init-connect = 'SET NAMES utf8'
character-set-server = utf8
```

如果任何部分不存在，请在文件中创建它们。如果这些部分已经存在，请将这些设置添加到现有配置中，然后在命令行工具中重新启动 MySQL，如下所示：

```py
$ /etc/init.d/mysql restart
```

# 它是如何工作的。。。

现在，无论何时创建新的 MySQL 数据库，默认情况下，数据库及其所有表都将设置为 UTF-8 编码。不要忘记在开发或发布项目的所有计算机上设置此选项。

# 还有更多。。。

在 PostgreSQL 中，默认的服务器编码已经是 UTF-8，但是如果要显式地使用 UTF-8 编码创建 PostgreSQL 数据库，则可以使用以下命令：

```py
$ createdb --encoding=UTF8 --locale=en_US.UTF-8 --template=template0 myproject
```

# 另见

*   *创建项目文件结构*配方
*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方

# 创建 Git 忽略文件

Git 是最流行的分布式版本控制系统，您可能已经在 Django 项目中使用它了。虽然您正在跟踪大多数文件的文件更改，但建议您将某些特定文件和文件夹置于版本控制之外。通常，不应该在 Git 存储库中跟踪缓存、编译代码、日志文件和隐藏的系统文件。

# 准备

确保您的 Django 项目处于 Git 版本控制之下。

# 怎么做。。。

使用您喜爱的文本编辑器，在 Django 项目的根目录下创建一个`.gitignore`文件，并将以下文件和目录放在那里：

```py
# .gitignore ### Python template
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
db.sqlite3

# Sphinx documentation
docs/_build/

# IPython
profile_default/
ipython_config.py

# Environments
env/

# Media and Static directories
/media/
!/media/.gitkeep

/static/
!/static/.gitkeep

# Secrets
secrets.json
```

# 它是如何工作的。。。

`.gitignore`文件指定了 Git 版本控制系统应该有意不跟踪的模式。我们在此配方中创建的`.gitignore`文件将忽略 Python 编译文件、本地设置、收集的静态文件以及上载文件的媒体目录。

请注意，对于媒体和静态文件，我们有带感叹号的特殊语法：

```py
/media/
!/media/.gitkeep
```

这告诉 Git 忽略`/media/`目录，但在版本控制下跟踪`/media/.gitkeep`文件。由于 Git 版本控制跟踪文件，但不跟踪目录，因此我们使用`.gitkeep`确保在每个环境中创建`media`目录，但不跟踪。

# 另见

*   *创建项目文件结构*配方
*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方

# 删除 Python 编译文件

当您第一次运行项目时，Python 会在字节码编译文件`*.pyc`中编译所有的`*.py`代码，稍后用于执行。通常，当您更改`*.py`文件时，会重新编译`*.pyc`；但是，有时在切换分支或移动目录时，需要手动清理编译后的文件。

# 准备

使用您喜爱的编辑器，在主目录中编辑或创建一个`.bash_profile`文件。

# 怎么做。。。

1.  在`.bash_profile`末尾添加此别名，如下所示：

```py
# ~/.bash_profile alias delpyc='
find . -name "*.py[co]" -delete
find . -type d -name "__pycache__" -delete'
```

2.  现在，要清理 Python 编译的文件，请转到项目目录并在命令行中键入以下命令：

```py
(env)$ delpyc
```

# 它是如何工作的。。。

首先，我们创建一个 Unix 别名，搜索`*.pyc`和`*.pyo`文件和`__pycache__`目录，并删除当前目录中的这些文件及其子目录。当您在命令行工具中启动新会话时，将执行`.bash_profile`文件。

# 还有更多。。。

如果希望避免创建 Python 编译文件，可以在`.bash_profile`、`env/bin/activate`脚本或 PyCharm 配置中设置环境变量`PYTHONDONTWRITEBYTECODE=1`。

# 另见

*   *创建 Git 忽略文件*配方

# 遵守 Python 文件中的导入顺序

创建 Python 模块时，最好与文件中的结构保持一致。这使您和其他开发人员都更容易阅读代码。此配方将向您展示如何构造导入。

# 准备

创建虚拟环境并在其中创建 Django 项目。

# 怎么做。。。

对要创建的每个 Python 文件使用以下结构。将导入分为以下几个部分：

```py
# System libraries
import os
import re
from datetime import datetime

# Third-party libraries
import boto
from PIL import Image

# Django modules
from django.db import models
from django.conf import settings

# Django apps
from cms.models import Page

# Current-app modules
from .models import NewsArticle
from . import app_settings
```

# 它是如何工作的。。。

我们的进口产品主要有五类，如下所示：

*   **Python 默认安装包的系统库**
*   **第三方库**用于额外安装的 Python 软件包
*   **Django 模块**用于 Django 框架的不同模块
*   第三方和本地应用的**Django 应用**
*   **当前 app 模块**用于从当前 app 相对导入

# 还有更多。。。

使用 Python 和 Django 编码时，请使用 Python 代码的官方样式指南 PEP8。您可以在[https 上找到：/​/​www。​python​组织机构/​发展/​政治公众人物/​打气-​0008/](https://www.python.org/dev/peps/pep-0008/)​.

# 另见

*   *使用 pip*配方处理项目依赖关系
*   *在您的项目*配方中包含外部依赖项

# 创建应用程序配置

Django 项目由多个称为应用程序（或更常见的应用程序）的 Python 模块组成，这些模块结合了不同的模块功能。每个应用程序都可以有模型、视图、表单、URL 配置、管理命令、迁移、信号、测试、上下文处理器、中间件等。Django 框架有一个应用程序注册表，其中收集所有应用程序和模型，然后用于配置和内省。自 Django 1.7 以来，每个应用程序的元信息都可以保存在`AppConfig`实例中。让我们创建一个示例`magazine`应用程序，看看如何使用那里的应用程序配置。

# 准备

您可以通过调用`startapp`管理命令或手动创建应用程序模块来创建 Django 应用程序：

```py
(env)$ cd myproject/apps/
(env)$ django-admin.py startapp magazine
```

创建`magazine`应用程序后，在`models.py`中添加`NewsArticle`模型，在`admin.py`中创建模型的管理，并将`"myproject.apps.magazine"`放在`INSTALLED_APPS`中的设置中。如果您还不熟悉这些任务，请学习[上的官方 Django 教程 https://docs.djangoproject.com/en/3.0/intro/tutorial01/](https://docs.djangoproject.com/en/3.0/intro/tutorial01/) [。](https://docs.djangoproject.com/en/2.2/intro/tutorial01/)

# 怎么做。。。

按照以下步骤创建和使用应用程序配置：

1.  修改`apps.py`文件并插入以下内容，如下所示：

```py
# myproject/apps/magazine/apps.py
from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _

class MagazineAppConfig(AppConfig):
    name = "myproject.apps.magazine"
    verbose_name = _("Magazine")

    def ready(self):
        from . import signals
```

2.  编辑`magazine`模块中的`__init__.py`文件，包含以下内容：

```py
# myproject/apps/magazine/__init__.py
default_app_config = "myproject.apps.magazine.apps.MagazineAppConfig"
```

3.  让我们创建一个`signals.py`文件，并在其中添加一些信号处理程序：

```py
# myproject/apps/magazine/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.conf import settings

from .models import NewsArticle

@receiver(post_save, sender=NewsArticle)
def news_save_handler(sender, **kwargs):
    if settings.DEBUG:
        print(f"{kwargs['instance']} saved.")

@receiver(post_delete, sender=NewsArticle)
def news_delete_handler(sender, **kwargs):
    if settings.DEBUG:
        print(f"{kwargs['instance']} deleted.")
```

# 它是如何工作的。。。

当您运行 HTTP 服务器或调用管理命令时，`django.setup()`被调用。它加载设置、设置日志记录并准备应用程序注册表。此注册表分三步初始化。Django 首先从设置中的`INSTALLED_APPS`导入每个项目的配置。这些项目可以直接指向应用程序名称或配置，例如，`"myproject.apps.magazine"`或`"myproject.apps.magazine.apps.MagazineAppConfig"`。

Django 然后尝试从`INSTALLED_APPS`中的每个应用程序导入`models.py`并收集所有模型。

最后，Django 为每个应用程序配置运行`ready()`方法。此方法在开发过程中提供了一个很好的点来注册信号处理程序（如果有）。`ready()`方法是可选的。

在我们的示例中，`MagazineAppConfig`类为`magazine`应用程序设置配置。`name`参数定义当前 app 的模块。`verbose_name`参数定义了 Django 模型管理中使用的人名，其中模型按应用程序显示和分组。`ready()`方法导入并激活信号处理程序，当处于调试模式时，该信号处理程序在终端中打印`NewsArticle`对象已保存或删除。

# 还有更多。。。

调用`django.setup()`后，您可以从注册表加载应用配置和模型，如下所示：

```py
>>> from django.apps import apps as django_apps
>>> magazine_app_config = django_apps.get_app_config("magazine")
>>> magazine_app_config
<MagazineAppConfig: magazine>
>>> magazine_app_config.models_module
<module 'magazine.models' from '/path/to/myproject/apps/magazine/models.py'>
>>> NewsArticle = django_apps.get_model("magazine", "NewsArticle")
>>> NewsArticle
<class 'magazine.models.NewsArticle'>
```

您可以在
[的 Django 官方文档中阅读更多关于应用程序配置的信息 https://docs.djangoproject.com/en/2.2/ref/applications/](https://docs.djangoproject.com/en/2.2/ref/applications/) ​.

# 另见

*   *使用虚拟环境*配方
*   *使用 Docker 容器处理 Django、Gunicorn、Nginx 和 PostgreSQL*配方
*   *定义可覆盖应用设置*配方
*   [第 6 章](06.html)*模型管理*

# 定义可覆盖的应用程序设置

此配方将向您展示如何定义应用程序的设置，然后可以在项目的设置文件中覆盖这些设置。这对于可通过添加配置进行自定义的可重用应用程序尤其有用。

# 准备

按照*创建应用程序配置*配方中的*准备*中的步骤创建您的 Django 应用程序。

# 怎么做。。。

1.  如果您只有一个或两个设置，请使用`models.py`中的`getattr()`模式定义您的应用程序设置；如果设置广泛且您希望更好地组织它们，请使用`app_settings.py`文件中的`getattr()`模式定义您的应用程序设置：

```py
# myproject/apps/magazine/app_settings.py
from django.conf import settings
from django.utils.translation import gettext_lazy as _

# Example:
SETTING_1 = getattr(settings, "MAGAZINE_SETTING_1", "default value")

MEANING_OF_LIFE = getattr(settings, "MAGAZINE_MEANING_OF_LIFE", 42)

ARTICLE_THEME_CHOICES = getattr(
    settings,
    "MAGAZINE_ARTICLE_THEME_CHOICES",
    [
        ('futurism', _("Futurism")),
        ('nostalgia', _("Nostalgia")),
        ('sustainability', _("Sustainability")),
        ('wonder', _("Wonder")),
    ]
)
```

2.  `models.py`将包含`NewsArticle`模型，如下所示：

```py
# myproject/apps/magazine/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _

class NewsArticle(models.Model):
    created_at = models.DateTimeField(_("Created at"),  
     auto_now_add=True)
    title = models.CharField(_("Title"), max_length=255)
    body = models.TextField(_("Body"))
    theme = models.CharField(_("Theme"), max_length=20)

    class Meta:
        verbose_name = _("News Article")
        verbose_name_plural = _("News Articles")

    def __str__(self):
        return self.title
```

3.  接下来，在`admin.py`中，我们将导入并使用`app_settings.py`中的设置，如下所示：

```py
# myproject/apps/magazine/admin.py
from django import forms
from django.contrib import admin

from .models import NewsArticle

from .app_settings import ARTICLE_THEME_CHOICES

class NewsArticleModelForm(forms.ModelForm):
    theme = forms.ChoiceField(
        label=NewsArticle._meta.get_field("theme").verbose_name,
        choices=ARTICLE_THEME_CHOICES,
        required=not NewsArticle._meta.get_field("theme").blank,
    )
    class Meta:
        fields = "__all__"

@admin.register(NewsArticle)
class NewsArticleAdmin(admin.ModelAdmin):
 form = NewsArticleModelForm
```

4.  如果要覆盖给定项目的`ARTICLE_THEME_CHOICES`设置，应在项目设置中添加`MAGAZINE_ARTICLE_THEME_CHOICES`：

```py
# myproject/settings/_base.py
from django.utils.translation import gettext_lazy as _
# ...
MAGAZINE_ARTICLE_THEME_CHOICES = [
    ('futurism', _("Futurism")),
    ('nostalgia', _("Nostalgia")),
    ('sustainability', _("Sustainability")),
    ('wonder', _("Wonder")),
    ('positivity', _("Positivity")),
    ('solutions', _("Solutions")),
    ('science', _("Science")),
]
```

# 它是如何工作的。。。

`getattr(object, attribute_name[, default_value])`Python 函数尝试从`object`获取`attribute_name`属性，如果未找到，则返回`default_value`。我们尝试从 Django 项目设置模块读取不同的设置，或者，如果它们不存在，则使用默认值。

请注意，我们可以在`models.py`中为`theme`字段定义`choices`，但我们在管理中创建了一个自定义`ModelForm`并在那里设置选项。这样做是为了避免在更改`ARTICLE_THEME_CHOICES`时创建新的数据库迁移。

# 另见

*   *创建 app 配置*配方
*   [第 6 章](06.html)*给药模式*

# 使用 Django、Gunicorn、Nginx 和 PostgreSQL 的 Docker 容器

Django 项目不仅依赖于 Python 需求，还依赖于许多系统需求，例如 web 服务器、数据库、服务器缓存和邮件服务器。在开发 Django 项目时，您需要确保所有环境和所有开发人员都安装了相同的需求。保持这些依赖项同步的一种方法是使用 Docker。使用 Docker，您可以拥有每个项目所需的数据库、web 或其他服务器的不同版本。

Docker 是一个用于创建配置的、自定义的虚拟机（称为容器）的系统。它允许我们精确地复制任何生产环境的设置。Docker 容器是从所谓的 Docker 图像创建的。图像由关于如何构建容器的层（或说明）组成。PostgreSQL 可以有一个映像，Redis 可以有一个映像，Memcached 可以有一个映像，Django 项目可以有一个自定义映像，所有这些映像都可以通过 Docker Compose 组合到附带的容器中。

在这个方法中，我们将使用一个项目样板来建立一个带有 PostgreSQL 数据库的 Django 项目，由 Nginx 和 Gunicorn 提供服务，并使用 Docker Compose 管理所有这些数据库。

# 准备

首先，您需要按照[中的说明安装 Docker 引擎 https://www.docker.com/get-started](https://www.docker.com/get-started) 。这通常包括 Compose 工具，它使管理需要多个容器的系统成为可能，非常适合于完全隔离的 Django 项目。如果需要单独安装，可在[上获取 Compose 的安装详细信息 https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/) ​.

# 怎么做。。。

让我们探索一下 Django 和 Docker 样板文件：

1.  从[下载代码 https://github.com/archatas/django_docker 例如，](https://github.com/archatas/django_docker)到您的计算机的`~/projects/django_docker`目录。

如果您选择另一个目录，例如`myproject_docker`，则必须进行全局搜索，并将`django_docker`替换为`myproject_docker`。

2.  打开`docker-compose.yml`文件。需要创建三个容器：`nginx`、`gunicorn`和`db`。如果看起来很复杂，不要担心；我们将在后面对其进行详细描述：

```py
# docker-compose.yml
version: "3.7"

services:
  nginx:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./config/nginx/conf.d:/etc/nginx/conf.d
      - static_volume:/home/myproject/static
      - media_volume:/home/myproject/media
    depends_on:
      - gunicorn

  gunicorn:
    build:
      context: .
      args:
        PIP_REQUIREMENTS: "${PIP_REQUIREMENTS}"
    command: bash -c "/home/myproject/env/bin/gunicorn --workers 3 
    --bind 0.0.0.0:8000 myproject.wsgi:application"
    depends_on:
      - db
    volumes:
      - static_volume:/home/myproject/static
      - media_volume:/home/myproject/media
    expose:
      - "8000"
    environment:
      DJANGO_SETTINGS_MODULE: "${DJANGO_SETTINGS_MODULE}"
      DJANGO_SECRET_KEY: "${DJANGO_SECRET_KEY}"
      DATABASE_NAME: "${DATABASE_NAME}"
      DATABASE_USER: "${DATABASE_USER}"
      DATABASE_PASSWORD: "${DATABASE_PASSWORD}"
      EMAIL_HOST: "${EMAIL_HOST}"
      EMAIL_PORT: "${EMAIL_PORT}"
      EMAIL_HOST_USER: "${EMAIL_HOST_USER}"
      EMAIL_HOST_PASSWORD: "${EMAIL_HOST_PASSWORD}"

  db:
    image: postgres:latest
    restart: always
    environment:
      POSTGRES_DB: "${DATABASE_NAME}"
      POSTGRES_USER: "${DATABASE_USER}"
      POSTGRES_PASSWORD: "${DATABASE_PASSWORD}"
    ports:
      - 5432
    volumes:
      - postgres_data:/var/lib/postgresql/data/

volumes:
  postgres_data:
  static_volume:
  media_volume:

```

3.  打开并阅读`Dockerfile`文件。以下是创建`gunicorn`容器所需的层（或说明）：

```py
# Dockerfile
# pull official base image
FROM python:3.8

# accept arguments
ARG PIP_REQUIREMENTS=production.txt

# set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# install dependencies
RUN pip install --upgrade pip setuptools

# create user for the Django project
RUN useradd -ms /bin/bash myproject

# set current user
USER myproject

# set work directory
WORKDIR /home/myproject

# create and activate virtual environment
RUN python3 -m venv env

# copy and install pip requirements
COPY --chown=myproject ./src/myproject/requirements /home/myproject/requirements/
RUN ./env/bin/pip3 install -r /home/myproject/requirements/${PIP_REQUIREMENTS}

# copy Django project files
COPY --chown=myproject ./src/myproject /home/myproject/

```

4.  将`build_dev_example.sh`脚本复制到`build_dev.sh`并编辑其内容。这些是要传递给`docker-compose`脚本的环境变量：

```py
# build_dev.sh
#!/usr/bin/env bash
DJANGO_SETTINGS_MODULE=myproject.settings.dev \
DJANGO_SECRET_KEY="change-this-to-50-characters-long-
 random-string" \
DATABASE_NAME=myproject \
DATABASE_USER=myproject \
DATABASE_PASSWORD="change-this-too" \
PIP_REQUIREMENTS=dev.txt \
docker-compose up --detach --build
```

5.  在命令行工具中，将执行权限添加到`build_dev.sh`并运行它来构建容器：

```py
$ chmod +x build_dev.sh
$ ./build_dev.sh
```

6.  如果你现在去`http://0.0.0.0/en/`，你会看到一个你好，世界！页面在那里。
    导航到`http://0.0.0.0/en/admin/`时，您应该看到以下内容：

```py
OperationalError at /en/admin/
 FATAL: role "myproject" does not exist
```

这意味着您必须在 Docker 容器中创建数据库用户和数据库。

7.  让我们 SSH 到`db`容器，并在 Docker 容器中创建数据库用户、密码和数据库本身：

```py
$ docker exec -it django_docker_db_1 bash
/# su - postgres
/$ createuser --createdb --password myproject
/$ createdb --username myproject myproject
```

当被询问时，为数据库输入与`build_dev.sh`脚本中相同的密码。

按[*Ctrl*+*D*两次，即可注销 PostgreSQL 用户和 Docker 容器。

如果您现在转到`http://0.0.0.0/en/admin/`，您将看到以下内容：

```py
ProgrammingError at /en/admin/ relation "django_session" does not exist LINE 1: ...ession_data", "django_session"."expire_date" FROM "django_se...
```

这意味着您必须运行迁移来创建数据库架构。

8.  SSH 进入`gunicorn`容器并运行必要的 Django 管理命令：

```py
$ docker exec -it django_docker_gunicorn_1 bash
$ source env/bin/activate
(env)$ python manage.py migrate
(env)$ python manage.py collectstatic
(env)$ python manage.py createsuperuser
```

回答管理命令提出的所有问题。

按[*Ctrl*+*D*两次，即可注销 Docker 容器。

如果您现在导航到`[http://0.0.0.0/en/admin/](http://0.0.0.0/en/admin/)`，您应该会看到 Django 管理，您可以使用刚才创建的超级用户凭据登录。

9.  创建类似的脚本，`build_test.sh`、`build_staging.sh`和`build_production.sh`，其中只有环境变量不同。

# 它是如何工作的。。。

样板中的代码结构类似于虚拟环境中的代码结构。项目源文件在`src`目录下。我们有用于跟踪上次修改日期的预提交钩子的`git-hooks`目录和用于容器中使用的服务配置的`config`目录：

```py
django_docker
├── config/
│   └── nginx/
│       └── conf.d/
│           └── myproject.conf
├── git-hooks/
│   ├── install_hooks.sh
│   └── pre-commit
├── src/
│   └── myproject/
│       ├── locale/
│       ├── media/
│       ├── myproject/
│       │   ├── apps/
│       │   │   └── __init__.py
│       │   ├── settings/
│       │   │   ├── __init__.py
│       │   │   ├── _base.py
│       │   │   ├── dev.py
│       │   │   ├── last-update.txt
│       │   │   ├── production.py
│       │   │   ├── staging.py
│       │   │   └── test.py
│       │   ├── site_static/
│       │   │   └── site/
│       │   │       ├── css/
│       │   │       ├── img/
│       │   │       ├── js/
│       │   │       └── scss/
│       │   ├── templates/
│       │   │   ├── base.html
│       │   │   └── index.html
│       │   ├── __init__.py
│       │   ├── urls.py
│       │   └── wsgi.py
│       ├── requirements/
│       │   ├── _base.txt
│       │   ├── dev.txt
│       │   ├── production.txt
│       │   ├── staging.txt
│       │   └── test.txt
│       ├── static/
│       └── manage.py
├── Dockerfile
├── LICENSE
├── README.md
├── build_dev.sh
├── build_dev_example.sh
└── docker-compose.yml
```

与 Docker 相关的主要配置位于`docker-compose.yml`和`Dockerfile`。Docker Compose 是 Docker 命令行 API 的包装器。`build_dev.sh`脚本在端口`8000`的 Gunicorn WSGI HTTP 服务器、端口`80`的 Nginx（向 Gunicorn 提供静态和媒体文件并代理其他请求）和端口`5432`的 PostgreSQL 数据库下构建并运行 Django 项目。

在`docker-compose.yml`文件中，请求创建三个 Docker 容器：

*   `nginx`针对 Nginx web 服务器
*   `gunicorn`对于带有 Gunicorn web 服务器的 Django 项目
*   `db`用于 PostgreSQL 数据库

`nginx`和`db`容器将根据位于[的官方图像创建 https://hub.docker.com](https://hub.docker.com) 。它们具有特定的配置参数，例如运行它们的端口、环境变量、对其他容器的依赖关系以及卷。

Docker 卷是在重建 Docker 容器时保持不变的特定目录。需要为数据库数据文件、媒体、静态等定义卷。

`gunicorn`容器将根据`Dockerfile`处的指令构建，该指令由`docker-compose.yml`文件中的构建上下文定义。让我们检查其中的每一层（或指令）：

*   `gunicorn`容器将基于`python:3.7`图像
*   它将把`PIP_REQUIREMENTS`作为`docker-compose.yml`文件中的参数
*   它将为容器设置环境变量
*   它将安装和升级 pip、setuptools 和 virtualenv
*   它将为 Django 项目创建一个名为`myproject`的系统用户
*   将`myproject`设置为当前用户
*   将`myproject`用户的主目录设置为当前工作目录
*   它将在那里创建一个虚拟环境
*   它将把 pip 需求从基础计算机复制到 Docker 容器
*   它将为`PIP_REQUIREMENTS`变量定义的当前环境安装 pip 要求
*   它将复制整个 Django 项目的源代码

`config/nginx/conf.d/myproject.conf`的内容将保存在`nginx`容器中的`/etc/nginx/conf.d/`下。这是 Nginx web 服务器的配置，告诉它侦听端口`80`（默认 HTTP 端口）并将请求转发到端口`8000`上的 Gunicorn 服务器，请求静态或媒体内容的请求除外：

```py
#/etc/nginx/conf.d/myproject.conf
upstream myproject {
    server django_docker_gunicorn_1:8000;
}

server {
    listen 80;

    location / {
        proxy_pass http://myproject;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $host;
        proxy_redirect off;
    }

    rewrite "/static/\d+/(.*)" /static/$1 last;

    location /static/ {
        alias /home/myproject/static/;
    }

    location /media/ {
        alias /home/myproject/media/;
    }
}
```

您可以在[第 12 章](12.html)*部署*中的*部署在 Nginx 和 Gunicorn 上用于登台环境*和*部署在 Nginx 和 Gunicorn 上用于生产环境*配方中了解更多关于 Nginx 和 Gunicorn 的配置。

# 还有更多。。。

您可以使用`docker-compose down`命令销毁 Docker 容器，并使用构建脚本重建它们：

```py
$ docker-compose down
$ ./build_dev.sh
```

如果某项工作不符合预期，您可以使用`docker-compose logs`命令检查日志：

```py
$ docker-compose logs nginx
$ docker-compose logs gunicorn $ docker-compose logs db

```

要通过 SSH 连接到任何容器，应使用以下选项之一：

```py
$ docker exec -it django_docker_gunicorn_1 bash
$ docker exec -it django_docker_nginx_1 bash
$ docker exec -it django_docker_db_1 bash
```

您可以使用`docker cp`命令将文件和目录复制到 Docker 容器上的卷中或从中复制：

```py
$ docker cp ~/avatar.png django_docker_gunicorn_1:/home/myproject/media/ $ docker cp django_docker_gunicorn_1:/home/myproject/media ~/Desktop/

```

如果您想更好地了解 Docker 和 Docker Compose，请访问[查看官方文档 https://docs.docker.com/](https://docs.docker.com/) ，特别是[https://docs.docker.com/compose/](https://docs.docker.com/compose/) 。

# 另见

*   *创建项目文件结构*配方
*   [第 12 章](12.html)、*部署*中针对暂存环境配方的*使用 mod_wsgi 在 Apache 上部署*
*   [第 12 章](12.html)*中*部署*中针对生产环境*配方使用 mod_wsgi 在 Apache 上部署
*   [第 12 章](12.html)*中的*部署在 Nginx 和 Gunicorn 上，用于搭建环境*配方，部署*
*   [第 12 章](12.html)*中*部署在 Nginx 和 Gunicorn 上的生产环境*配方，部署*