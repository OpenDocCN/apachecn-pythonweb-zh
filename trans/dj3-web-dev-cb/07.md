# 安全和性能

在本章中，我们将介绍以下配方：

*   从**跨站点请求伪造**（**CSRF**中制作安全表单
*   使用**内容安全策略**（**CSP**确保请求安全）
*   使用 django 管理蜜罐
*   实现密码验证
*   下载授权文件
*   向图像添加动态水印
*   使用 Auth0 进行身份验证
*   缓存方法返回值
*   使用 Memcached 缓存 Django 视图
*   使用 Redis 缓存 Django 视图

# 介绍

如果软件不适当地暴露敏感信息，让用户忍受无休止的等待时间，或者需要大量的硬件，那么它将永远不会持续。作为开发人员，我们有责任确保应用程序的安全性和性能。在本章中，我们将探讨在 Django 应用程序中操作时如何确保用户（和您自己）的安全。然后，我们将介绍一些缓存选项，这些选项可以减少处理，并以较低的金钱和时间成本向用户获取数据。

# 技术要求

要使用本章中的代码，您将需要最新稳定版本的 Python、MySQL 或 PostgreSQL 数据库以及带有虚拟环境的 Django 项目。

您可以在本书的 GitHub 存储库的`ch07`目录中找到本章的所有代码：[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition) 。

# 确保表单安全，防止跨站点请求伪造（CSRF）

如果没有适当的预防措施，恶意网站可能会调用针对您网站的请求，从而导致对您的服务器进行不必要的更改。例如，它们可能会影响用户的身份验证或在未经用户同意的情况下更改内容。Django 附带了一个防止此类 CSRF 攻击的系统，我们将在本食谱中对此进行回顾。

# 准备

从我们在[第 3 章](03.html)*中的*创建具有 CRUDL 功能的*配方中创建的`ideas`应用开始，表单和视图*。

# 怎么做。。。

要在 Django 启用 CSRF 预防，请执行以下步骤：

1.  确保`CsrfViewMiddleware`包含在您的项目设置中，如下所示：

```py
# myproject/settings/_base.py
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "django.middleware.locale.LocaleMiddleware",
]
```

2.  确保表单视图是使用请求上下文呈现的。例如，在现有的`ideas`应用程序中，我们有：

```py
# myproject/apps/ideas/views.py from django.contrib.auth.decorators import login_required
from django.shortcuts import render

@login_required
def add_or_change_idea(request, pk=None):
    # …
    return render(request, "ideas/idea_form.html", context)
```

3.  在表单的模板中，确保它使用了`POST`方法并包含`{% csrf_token %}`标签：

```py
{# ideas/idea_form.html #}
{% extends "base.html" %}
{% load i18n crispy_forms_tags static %}

{% block content %}
    <h1>
        {% if idea %}
            {% blocktrans trimmed with title=idea
             .translated_title %}
                Change Idea "{{ title }}"
            {% endblocktrans %}
        {% else %}
            {% trans "Add Idea" %}
        {% endif %}
    </h1>
    <form action="{{ request.path }}" method="post">
 {% csrf_token %}
        {{ form.as_p }}
        <p>
            <button type="submit">{% trans "Save" %}</button>
        </p>
    </form>
{% endblock %}
```

4.  如果您使用`django-crispy-forms`进行表单布局，默认情况下会包含 CSRF 令牌：

```py
{# ideas/idea_form.html #}
{% extends "base.html" %}
{% load i18n crispy_forms_tags static %}

{% block content %}
    <h1>
        {% if idea %}
            {% blocktrans trimmed with title=idea
             .translated_title %}
                Change Idea "{{ title }}"
            {% endblocktrans %}
        {% else %}
            {% trans "Add Idea" %}
        {% endif %}
    </h1>
    {% crispy form %}
{% endblock %}
```

# 它是如何工作的。。。

Django 使用隐藏字段方法来防止 CSRF 攻击。基于请求特定信息和随机信息的组合，在服务器上生成令牌。通过`CsrfViewMiddleware`，该令牌通过请求上下文自动可用。
虽然不建议禁用此中间件，但可以通过应用`@csrf_protect`装饰器来标记各个视图以获得相同的行为：

```py
from django.views.decorators.csrf import csrf_protect

@csrf_protect
def my_protected_form_view():
    # …
```

类似地，我们可以通过使用`@csrf_exempt`装饰器从 CSRF 检查中排除单个视图，即使启用了中间件：

```py
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def my_unsecured_form_view():
    # …
```

内置的`{% csrf_token %}`标记生成提供令牌的隐藏输入字段，如下例所示：

```py
<input type="hidden" name="csrfmiddlewaretoken" value="29sQH3UhogpseHH60eEaTq0xKen9TvbKe5lpT9xs30cR01dy5QVAtATWmAHvUZFk">
```

对于使用`GET`、`HEAD`、`OPTIONS`或`TRACE`方法提交请求的表单，包含令牌被认为是无效的，因为使用这些方法的任何请求首先都不会产生副作用。在大多数情况下，需要 CSRF 保护的 web 表单将是`POST`表单。

当使用不安全方法的受保护表单在没有所需令牌的情况下提交时，Django 的内置表单验证将识别这一点并完全拒绝请求。只有包含具有有效值的令牌的提交才能继续。因此，外部站点将无法对服务器进行更改，因为它们无法知道并包含当前有效的令牌值。

# 还有更多。。。

在许多情况下，需要增强表单，以便通过 Ajax 提交表单。这些还需要使用 CSRF 令牌进行保护，虽然可以在每个请求中作为额外数据注入令牌，但使用这种方法需要开发人员记住对每个`POST`请求都这样做。使用 CSRF 令牌头的替代方案已经存在，它使事情更加高效。

首先，需要检索令牌值，我们如何检索取决于`CSRF_USE_SESSIONS`设置的值。当它是`True`时，令牌存储在会话中而不是 cookie 中，因此我们必须使用`{% csrf_token %}`标记将其包含在 DOM 中。然后，我们可以读取该元素以检索 JavaScript 中的数据：

```py
var input = document.querySelector('[name="csrfmiddlewaretoken"]');
var csrfToken = input && input.value; 
```

当`CSRF_USE_SESSIONS`设置处于默认`False`状态时，令牌值的首选来源是`csrftoken`cookie。虽然可以滚动您自己的 cookie 操作方法，但有许多实用程序可以简化此过程。例如，我们可以使用**js cookie**API（可从[获取）通过名称轻松提取令牌 https://github.com/js-cookie/js-cookie](https://github.com/js-cookie/js-cookie) ，如图所示：

```py
var csrfToken = Cookies.get('crsftoken');
```

提取令牌后，需要将其设置为`XmlHttpRequest`的 CSRF 令牌头值。尽管这可能会对每个请求分别进行，但这样做与将数据添加到每个请求的请求参数中具有相同的缺点。相反，我们可以使用 jQuery 及其在发送请求之前自动将数据附加到所有请求的功能，如下所示：

```py
var CSRF_SAFE_METHODS = ['GET', 'HEAD', 'OPTIONS', 'TRACE'];
$.ajaxSetup({
    beforeSend: function(xhr, settings) {
        if (CSRF_SAFE_METHODS.indexOf(settings.type) < 0
            && !this.crossDomain) {
            xhr.setRequestHeader("X-CSRFToken", csrfToken);
        } 
    }
});
```

# 另见

*   [第三章](03.html)*中*创建具有 CRUDL 功能*配方的应用程序*，表单和视图
*   *实现密码验证*配方
*   *下载授权文件*配方
*   使用 Auth0 配方进行的*认证*

# 使用内容安全策略（CSP）使请求安全

动态多用户网站通常允许用户添加各种媒体类型的各种数据：图像、视频、音频、HTML、JavaScript 片段等等。这就打开了用户向网站添加恶意代码的可能性，这些恶意代码可能会窃取 cookie 或其他个人信息，在后台调用不需要的 Ajax 请求，或造成其他伤害。现代浏览器支持一个额外的安全层，将媒体资源的来源列为白名单。它被称为 CSP，在这个配方中，我们将向您展示如何在 Django 网站中使用它。

# 准备

让我们从一个现有的 Django 项目开始；例如，包含[第 3 章](03.html)*中的`ideas`app 的表单和视图*。

# 怎么做。。。

要使用 CSP 保护您的项目，请执行以下步骤：

1.  将`django-csp`安装到您的虚拟环境中：

```py
(env)$ pip install django-csp==3.6
```

2.  在设置中添加`CSPMiddleware`：

```py
# myproject/settings/_base.py
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "django.middleware.locale.LocaleMiddleware",
    "csp.middleware.CSPMiddleware",
]
```

3.  在相同的设置文件中，添加`django-csp`设置，用于白名单您信任的包含媒体的源，例如，用于 jQuery 和 Bootstrap 的 CDN（您将在*如何工作…*部分中找到详细说明）：

```py
# myproject/settings/_base.py
CSP_DEFAULT_SRC = [
    "'self'",
    "https://stackpath.bootstrapcdn.com/",
]
CSP_SCRIPT_SRC = [
    "'self'",
    "https://stackpath.bootstrapcdn.com/",
    "https://code.jquery.com/",
    "https://cdnjs.cloudflare.com/",
]
CSP_IMG_SRC = ["*", "data:"]
CSP_FRAME_SRC = ["*"]
```

4.  如果模板中有任何内联脚本或样式，请使用加密`nonce`将其列入白名单，如下所示：

```py
<script nonce="{{ request.csp_nonce }}">
    window.settings = {
        STATIC_URL: '{{ STATIC_URL }}',
        MEDIA_URL: '{{ MEDIA_URL }}',
    }
</script>
```

# 它是如何工作的。。。

CSP 指令可以添加到 head 部分或响应头中的 meta 标记中：

*   `meta`标记语法如下所示：

```py
<meta http-equiv="Content-Security-Policy" content="img-src * data:; default-src 'self' https://stackpath.bootstrapcdn.com/ 'nonce-WWNu7EYqfTcVVZDs'; frame-src *; script-src 'self' https://stackpath.bootstrapcdn.com/ https://code.jquery.com/ https://cdnjs.cloudflare.com/">
```

*   我们选择的`django-csp`模块使用**响应头**创建要加载到网站中的列表源。您可以在浏览器的检查器的“网络”部分中检查标题，如下所示：

```py
Content-Security-Policy: img-src * data:; default-src 'self' https://stackpath.bootstrapcdn.com/ 'nonce-WWNu7EYqfTcVVZDs'; frame-src *; script-src 'self' https://stackpath.bootstrapcdn.com/ https://code.jquery.com/ https://cdnjs.cloudflare.com/
```

CSP 允许您定义彼此相邻的资源类型和允许的源。您可以使用的主要指令如下：

*   `default-src`用作所有未设置震源的备用，并由`CSP_DEFAULT_SRC`在 Django 设置中控制。
*   `script-src`用于`<script>`标签，在 Django 设置中由`CSP_DEFAULT_SRC`控制。
*   `style-src`用于`<style>`和`<link rel="stylesheet">`标记和 CSS`@import`语句，并由`CSP_STYLE_SRC`设置控制。
*   `img-src`用于`<img>`标签，由`CSP_IMG_SRC`设置控制。
*   `frame-src`用于`<frame>`和`<iframe>`标签，由`CSP_FRAME_SRC`设置控制。
*   `media-src`用于`<audio>`、`<video>`和`<track>`标签，由`CSP_MEDIA_SRC`设置控制。
*   `font-src`用于网页字体，由`CSP_FONT_SRC`设置控制。
*   `connect-src`用于 JavaScript 加载的资源，由`CSP_CONNECT_SRC`设置控制。

有关资源类型和类似设置的完整列表，请参见[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) 和[https://django-csp.readthedocs.io/en/latest/configuration.html 分别为](https://django-csp.readthedocs.io/en/latest/configuration.html)。

每个指令的值可以是以下列表中的一个或多个（单引号很重要）：

*   `*`：允许所有来源
*   `'none'`：禁止所有来源
*   `'self'`：允许来自同一域的源
*   协议；例如，`https:`或`data:`
*   一个领域；例如，`example.com`或`*.example.com`
*   网站 URL，例如，`https://example.com`
*   `'unsafe-inline'`：允许内联`<script>`或`<style>`标签
*   `'unsafe-eval'`：通过`eval()`功能允许脚本执行
*   `'nonce-<b64-value>'`：允许通过加密 nonce 进行特定标记
*   `'sha256-...'`：允许资源通过其源哈希

没有通用的防弹方式来配置`django-csp`。这总是一个反复试验的过程。然而，以下是我们的指导方针：

1.  首先为现有的工作项目添加 CSP。过早的限制只会使网站的开发更加困难。
2.  检查所有已硬编码到模板中的脚本、样式、字体和其他静态文件，并将其列入白名单。

3.  如果允许将媒体嵌入博客文章或其他动态内容，则允许所有图像、媒体和帧源，如下所示：

```py
# myproject/settings/_base.py CSP_IMG_SRC = ["*"]
CSP_MEDIA_SRC = ["*"]
CSP_FRAME_SRC = ["*"]
```

4.  如果您使用内联脚本或样式，请向其添加`nonce="{{ request.csp_nonce }}"`。
5.  避免使用`'unsafe-inline'`和`'unsafe-eval'`CSP 值，除非将 HTML 输入网站的唯一方法是在模板中硬编码。
6.  浏览网站并搜索任何未正确加载的内容。如果在开发人员控制台中看到如下消息，则表示内容受 CSP 限制：

    拒绝执行内联脚本，因为它违反了以下内容安全策略指令：“script src'self”https://stackpath.bootstrapcdn.com/ https://code.jquery.com/ https://cdnjs.cloudflare.com/". 启用内联执行需要'unsafe inline'关键字、哈希（'sha256-P1v4zceJ/oPr/yp20lBqDnqynDQhHf76lljlXUxt7NI='）或 nonce（'nonce-…'）。

    此类错误通常会发生，因为 django cms、django Debug Toolbar 和 Google Analytics 等第三方工具正试图通过 JavaScript 包含资源。您可以使用源哈希将这些资源列入白名单，就像我们在错误消息中看到的那样：
    `'sha256-P1v4zceJ/oPr/yp20lBqDnqynDQhHf76lljlXUxt7NI='`。
7.  如果你开发了现代的 Po.T2 渐进 Web 应用程序 To.T3（To.T4，Pay-TyT5），考虑检查由清单 T0 和 St1 T1 设置控制的清单和 Web 工作者的指令。

# 另见

*   *制作表单防止跨站点请求伪造（CSRF）*配方

# 使用 django 管理蜜罐

如果您保留 Django 网站的默认管理路径，则黑客可以执行暴力攻击，并尝试使用列表中的不同密码登录。有一个名为 django admin 蜜罐的应用程序，允许你伪造登录屏幕并检测那些暴力攻击。在这个食谱中，我们将学习如何使用它。

# 准备

我们可以从任何我们想要保护的 Django 项目开始。例如，可以从上一个配方扩展项目。

# 怎么做。。。

按照以下步骤设置 django 管理蜜罐：

1.  在虚拟环境中安装模块：

```py
(env)$ pip install django-admin-honeypot==1.1.0
```

2.  在您的设置中将`"admin_honeypot"`添加到`INSTALLED_APPS`：

```py
# myproject/settings/_base.py INSTALLED_APPS = (
    # …
    "admin_honeypot",
)
```

3.  修改 URL 规则：

```py
# myproject/urls.py from django.contrib import admin
from django.conf.urls.i18n import i18n_patterns
from django.urls import include, path

urlpatterns = i18n_patterns(
    # …
    path("admin/", include("admin_honeypot.urls", 
    namespace="admin_honeypot")),
 path("management/", admin.site.urls),
)
```

# 它是如何工作的。。。

如果您转到默认的管理 URL`http://127.0.0.1:8000/en/admin/`，您将看到登录屏幕，但您输入的任何内容都将被描述为无效密码：

![](assets/7fc7521b-9438-4ccd-9e5c-6b7efa6b23fc.png)

真实站点的管理现在处于`http://127.0.0.1:8000/en/management/`之下，您可以在这里查看蜜罐中跟踪的登录。

# 还有更多。。。

在撰写本文时，django admin 蜜罐在 django 3.0 中的功能并不完美–管理接口在安全呈现它的地方逃逸 HTML。在 django admin 蜜罐更新并提供新版本之前，我们可以通过做一些更改来修复它，如下所示：

1.  使用包含以下代码的`admin.py`文件创建一个名为`admin_honeypot_fix`的应用程序：

```py
# myproject/apps/admin_honeypot_fix/admin.py from django.contrib import admin

from admin_honeypot.admin import LoginAttemptAdmin
from admin_honeypot.models import LoginAttempt
from django.utils.safestring import mark_safe
from django.utils.translation import gettext_lazy as _

admin.site.unregister(LoginAttempt)

@admin.register(LoginAttempt)
class FixedLoginAttemptAdmin(LoginAttemptAdmin):
    def get_session_key(self, instance):
        return mark_safe('<a href="?session_key=
        %(key)s">%(key)s</a>' % {'key': instance.session_key})
    get_session_key.short_description = _('Session')

    def get_ip_address(self, instance):
        return mark_safe('<a href="?ip_address=%(ip)s">%(ip)s</a>' 
         % {'ip': instance.ip_address})
    get_ip_address.short_description = _('IP Address')

    def get_path(self, instance):
        return mark_safe('<a href="?path=%(path)s">%(path)s</a>' 
         % {'path': instance.path})
    get_path.short_description = _('URL')
```

2.  在同一个应用程序中，使用新的应用程序配置创建一个`apps.py`文件：

```py
# myproject/apps/admin_honeypot_fix/apps.py from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _

class AdminHoneypotConfig(AppConfig):
    name = "admin_honeypot"
    verbose_name = _("Admin Honeypot")

    def ready(self):
 from .admin import FixedLoginAttemptAdmin
```

3.  将`"admin_honeypot"`替换为设置中`INSTALLED_APPS`中的新应用配置：

```py
# myproject/settings/_base.py INSTALLED_APPS = [
    # …
    #"admin_honeypot",
    "myproject.apps.admin_honeypot_fix.apps.AdminHoneypotConfig",
]
```

在蜜罐上的登录尝试现在如下所示：

![](assets/3c76c52b-0f5c-4272-ab40-01ca4603d480.png)

# 另见

*   *实现密码验证*配方
*   使用 Auth0 配方进行的*认证*

# 实现密码验证

在软件安全故障列表顶部的项目中，用户选择不安全的密码。在本教程中，我们将学习如何通过内置和自定义密码验证器强制执行最低密码要求，以便引导用户设置更安全的身份验证。

# 准备

打开项目的设置文件，找到`AUTH_PASSWORD_VALIDATORS`设置。另外，创建一个包含一个`password_validation.py`文件的新`auth_extra`应用程序。

# 怎么做。。。

按照以下步骤为您的项目设置更强的密码验证：

1.  让我们通过添加一些选项来定制 Django 附带的验证器的设置：

```py
# myproject/settings/_base.py
AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation."
        "UserAttributeSimilarityValidator",
        "OPTIONS": {"max_similarity": 0.5},
    },
    {
        "NAME": "django.contrib.auth.password_validation." 
        "MinimumLengthValidator",
        "OPTIONS": {"min_length": 12},
    },
    {"NAME": "django.contrib.auth.password_validation." 
    "CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation." 
    "NumericPasswordValidator"},
]
```

2.  将`MaximumLengthValidator`类添加到新`auth_extra`应用的`password_validation.py`文件中，如下所示：

```py
# myproject/apps/auth_extra/password_validation.py from django.core.exceptions import ValidationError
from django.utils.translation import gettext as _

class MaximumLengthValidator:
    def __init__(self, max_length=24):
        self.max_length = max_length

    def validate(self, password, user=None):
        if len(password) > self.max_length:
            raise ValidationError(
                self.get_help_text(pronoun="this"),
                code="password_too_long",
                params={'max_length': self.max_length},
            )

    def get_help_text(self, pronoun="your"):
        return _(f"{pronoun.capitalize()} password must contain "
                 f"no more than {self.max_length} characters")
```

3.  在同一文件中，创建`SpecialCharacterInclusionValidator`类：

```py
class SpecialCharacterInclusionValidator:
    DEFAULT_SPECIAL_CHARACTERS = ('$', '%', ':', '#', '!')

    def __init__(self, special_chars=DEFAULT_SPECIAL_CHARACTERS):
        self.special_chars = special_chars

    def validate(self, password, user=None):
        has_specials_chars = False
        for char in self.special_chars:
            if char in password:
                has_specials_chars = True
                break
        if not has_specials_chars:
            raise ValidationError(
                self.get_help_text(pronoun="this"),
                code="password_missing_special_chars"
            )

    def get_help_text(self, pronoun="your"):
        return _(f"{pronoun.capitalize()} password must contain at"
                 " least one of the following special characters: "
                 f"{', '.join(self.special_chars)}")
```

4.  然后，将新的验证器添加到设置中：

```py
# myproject/settings/_base.py
from myproject.apps.auth_extra.password_validation import (
 SpecialCharacterInclusionValidator,
)

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation."
        "UserAttributeSimilarityValidator",
        "OPTIONS": {"max_similarity": 0.5},
    },
    {
        "NAME": "django.contrib.auth.password_validation." 
        "MinimumLengthValidator",
        "OPTIONS": {"min_length": 12},
    },
    {"NAME": "django.contrib.auth.password_validation." 
    "CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation." 
    "NumericPasswordValidator"},
    {
 "NAME": "myproject.apps.auth_extra.password_validation."
        "MaximumLengthValidator",
 "OPTIONS": {"max_length": 32},
 },
 {
 "NAME": "myproject.apps.auth_extra.password_validation."
        "SpecialCharacterInclusionValidator",
 "OPTIONS": {
 "special_chars": ("{", "}", "^", "&")
 + SpecialCharacterInclusionValidator
              .DEFAULT_SPECIAL_CHARACTERS
 },
 },
]
```

# 它是如何工作的。。。

Django 包含一组默认密码验证程序：

*   `UserAttributeSimilarityValidator`确保所选择的任何密码与用户的某些属性不太相似。默认情况下，相似性比率设置为`0.7`，检查的属性为用户名、名字和姓氏以及电子邮件地址。如果这些属性中的任何一个包含多个单词，则会单独检查每个单词。
*   `MinimumLengthValidator`检查输入的密码长度是否至少为最小字符数。默认情况下，密码长度必须为八个或更多字符。
*   `CommonPasswordValidator`指包含经常使用的密码列表的文件，因此不安全。Django 默认使用的列表包含 1000 个这样的密码。
*   `NumericPasswordValidator`验证输入的密码不完全由数字组成。

当您使用`startproject`管理命令创建一个新项目时，这些项目将与它们的默认选项一起添加，作为初始的验证器集。在此配方中，我们展示了如何根据项目需要调整这些选项，将密码的最小长度增加到 12 个字符。

对于`UserAttributeSimilarityValidator`，我们还将`max_similarity`减少为`0.5`，这意味着密码与用户属性的差异必须比默认值更大。

查看`password_validation.py`，我们定义了两个新的验证器：

*   `MaximumLengthValidator`在最小长度上与内置密码非常相似，确保密码长度不超过默认的 24 个字符
*   `SpecialCharacterInclusionValidator`检查是否在给定密码中找到一个或多个特殊字符–默认情况下定义为`$`、`%`、`:`、`#`和`!`符号

每个验证器类都有两个必需的方法：

*   `validate()`方法对`password`参数执行实际检查。或者，当用户已通过身份验证时，将传递第二个`user`参数。
*   我们还必须提供一个`get_help_text()`方法，该方法返回一个字符串，描述用户的验证需求。

最后，我们将新的验证器添加到设置中，以覆盖默认设置，允许密码的最大长度为 32 个字符，并能够将符号`{`、`}`、`^`和`&`添加到默认特殊字符列表中。

# 还有更多。。。

对于`createsuperuser`和`changepassword`管理命令，以及用于更改或重置密码的内置表单，`AUTH_PASSWORD_VALIDATORS`中提供的验证程序将自动执行。不过，有时您会希望对自定义密码管理代码使用相同的验证。Django 为该级别的集成提供了功能，您可以在`django.contrib.auth.password_validation`模块中提供的 Django`auth`应用程序中查看详细信息。

# 另见

*   *下载授权文件*配方
*   使用 Auth0 配方进行的*认证*

# 下载授权文件

有时，您可能只需要允许特定人员从您的网站下载知识产权。例如，音乐、视频、文学或其他艺术作品应该只对付费会员开放。在本教程中，您将了解如何使用提供的 Django auth 应用程序将图像下载限制为仅限经过身份验证的用户。

# 准备

让我们从我们在[第 3 章](03.html)中创建的`ideas`应用开始，*表单和视图*。

# 怎么做。。。

逐一执行以下步骤：

1.  创建需要身份验证才能下载文件的视图，如下所示：

```py
# myproject/apps/ideas/views.py import os

from django.contrib.auth.decorators import login_required
from django.http import FileResponse, HttpResponseNotFound
from django.shortcuts import get_object_or_404
from django.utils.text import slugify

from .models import Idea

@login_required
def download_idea_picture(request, pk):
    idea = get_object_or_404(Idea, pk=pk)
    if idea.picture:
        filename, extension = 
        os.path.splitext(idea.picture.file.name)
        extension = extension[1:] # remove the dot
        response = FileResponse(
            idea.picture.file, content_type=f"image/{extension}"
        )
        slug = slugify(idea.title)[:100]
        response["Content-Disposition"] = (
            "attachment; filename="
            f"{slug}.{extension}"
        )
    else:
        response = HttpResponseNotFound(
            content="Picture unavailable"
        )
    return response
```

2.  将下载视图添加到 URL 配置：

```py
# myproject/apps/ideas/urls.py from django.urls import path

from .views import download_idea_picture

urlpatterns = [
    # …
    path(
 "<uuid:pk>/download-picture/",
 download_idea_picture,
 name="download_idea_picture",
 ),
]
```

3.  在我们的项目 URL 配置中设置登录视图：

```py
# myproject/urls.py from django.conf.urls.i18n import i18n_patterns
from django.urls import include, path

urlpatterns = i18n_patterns(
    # …
    path("accounts/", include("django.contrib.auth.urls")),
    path("ideas/", include(("myproject.apps.ideas.urls", "ideas"), 
     namespace="ideas")),
)
```

4.  为登录表单创建一个模板，如下代码所示：

```py
{# registration/login.html #} {% extends "base.html" %}
{% load i18n %}

{% block content %}
    <h1>{% trans "Login" %}</h1>
    <form action="{{ request.path }}" method="POST">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit" class="btn btn-primary">{% trans 
         "Log in" %}</button>
    </form>
{% endblock %}
```

5.  在 idea 详细信息模板中，添加下载链接：

```py
{# ideas/idea_detail.html #}
{% extends "base.html" %}
{% load i18n %}

{% block content %}
…
 <a href="{% url 'ideas:download_idea_picture' pk=idea.pk %}" 
     class="btn btn-primary">{% trans "Download picture" %}</a>
{% endblock %}
```

您应该限制用户绕过 Django 并直接下载受限制的文件。为此，在 Apache web 服务器上，如果您正在运行 Apache 2.4，则可以使用以下内容将`.htaccess`文件放入`media/ideas`目录中：

```py
# media/ideas/.htaccess Require all denied
```

当使用`django-imagekit`时，如本书中的示例所示，生成的图像版本将从`media/CACHE`目录存储和服务，因此我们的`.htaccess`配置不会影响它。

# 它是如何工作的。。。

`download_idea_picture`视图从一个特定的想法流式传输原始上传的图片。设置为`attachment`的`Content-Disposition`头使文件可下载，而不是立即显示在浏览器中。该文件的文件名也在该标题中设置，类似于`gamified-donation-platform.jpg`。如果创意图片不可用，404 页面将显示一条非常简单的消息：图片不可用。

如果访问者试图在未登录的情况下访问可下载文件，`@login_required`装饰程序会将其重定向到登录页面。默认情况下，登录屏幕如下所示：

![](assets/273c8926-f6a8-4087-b876-ae6bd05c0981.png)

# 另见

*   来自[第三章](03.html)的*上传图片*配方*表单和视图*
*   *使用[第 3 章](03.html)、*表单和视图*中的自定义模板*配方创建表单布局
*   *使用[第 3 章](03.html)、*表单和视图*中的 django crispy forms*配方创建表单布局
*   *整理[第 4 章](04.html)中的 base.html 模板*配方、*模板和 JavaScript*
*   *实现密码验证*配方
*   *为图像*添加动态水印的配方

# 向图像添加动态水印

有时，允许用户查看图像是可取的，但由于知识产权和艺术权利的原因，不允许图像被重新分发。在本食谱中，我们将学习如何将水印应用于站点上显示的图像。

# 准备

让我们从[第 3 章](03.html)*表单和视图*中的*创建具有 CRUDL 功能的*配方中创建的`core`和`ideas`应用开始。

# 怎么做。。。

按照以下步骤将水印应用于显示的 idea 图像：

1.  如果尚未安装，请将`django-imagekit`安装到您的虚拟环境中：

```py
(env)$ pip install django-imagekit==4.0.2
```

2.  在设置中将`"imagekit"`放入`INSTALLED_APPS`：

```py
# myproject/settings/_base.py
INSTALLED_APPS = [
    # …
    "imagekit",
]
```

3.  在`core`应用中，使用`WatermarkOverlay`类创建一个名为`processors.py`的文件，如下所示：

```py
# myproject/apps/core/processors.py
from pilkit.lib import Image

class WatermarkOverlay(object):
    def __init__(self, watermark_image):
        self.watermark_image = watermark_image

    def process(self, img):
        original = img.convert('RGBA')
        overlay = Image.open(self.watermark_image)
        img = Image.alpha_composite(original, 
        overlay).convert('RGB')
        return img
```

4.  在`Idea`模型中，在`picture`字段旁添加`watermarked_picture_large`规范，如下所示：

```py
# myproject/apps/ideas/models.py import os

from imagekit.models import ImageSpecField
from pilkit.processors import ResizeToFill

from django.db import models
from django.conf import settings
from django.utils.translation import gettext_lazy as _
from django.utils.timezone import now as timezone_now

from myproject.apps.core.models import CreationModificationDateBase, UrlBase
from myproject.apps.core.processors import WatermarkOverlay

def upload_to(instance, filename):
    now = timezone_now()
    base, extension = os.path.splitext(filename)
    extension = extension.lower()
    return f"ideas/{now:%Y/%m}/{instance.pk}{extension}"

class Idea(CreationModificationDateBase, UrlBase):
    # …
    picture = models.ImageField(
        _("Picture"), upload_to=upload_to
    )
    watermarked_picture_large = ImageSpecField(
 source="picture",
 processors=[
 ResizeToFill(800, 400),
 WatermarkOverlay(
 watermark_image=os.path.join(settings.STATIC_ROOT, 
                'site', 'img', 'watermark.png'),
 )
 ],
 format="PNG"
    )
```

5.  使用您选择的图形程序，在透明背景上创建带有白色文本或徽标的半透明 PNG 图像。尺寸为 800 x 400 像素。将图像另存为`site_static/site/img/watermark.png`。下面是它可能的样子：

![](assets/e5d2c032-4ad3-426e-9fa5-a932de9e6183.png)

6.  之后运行`collectstatic`管理命令：

```py
(env)$ export DJANGO_SETTINGS_MODULE=myproject.settings.dev
(env)$ python manage.py collectstatic
```

7.  编辑 idea 详细信息模板并在其中添加水印图像，如下所示：

```py
{# ideas/idea_detail.html #} {% extends "base.html" %}
{% load i18n %}

{% block content %}
    <a href="{% url "ideas:idea_list" %}">{% trans "List of ideas" 
     %}</a>
    <h1>
        {% blocktrans trimmed with title=idea.translated_title %}
            Idea "{{ title }}"
        {% endblocktrans %}
    </h1>
    <img src="{{ idea.watermarked_picture_large.url }}" alt="" />
    {{ idea.translated_content|linebreaks|urlize }}
    <p>
        {% for category in idea.categories.all %}
            <span class="badge badge-pill badge-info">
             {{ category.translated_title }}</span>
        {% endfor %}
    </p>
    <a href="{% url 'ideas:download_idea_picture' pk=idea.pk %}" 
     class="btn btn-primary">{% trans "Download picture" %}</a>
{% endblock %}
```

# 它是如何工作的。。。

如果我们导航到 idea 详细信息页面，我们将看到被水印掩盖的大图像，类似于以下内容：

![](assets/527e60a3-66e9-45f5-87bd-f521ce8fc34f.png)

让我们看看这是如何做到的。在细节模板中，`<img>`标记的`src`属性使用 idea 的图像规范，即`watermarked_picture_large`，创建一个修改后的图像，然后保存在`media/CACHE/`目录下并从那里提供服务。

`django-imagekit`规范使用处理器修改图像。这里使用两个处理器：

*   `ResizeToFill`将图像大小调整为 800×400 像素
*   我们的定制处理器`WatermarkOverlay`对其应用半透明覆盖

`django-imagekit`处理器必须具有`process()`方法，该方法从以前的处理器获取图像并返回新的修改图像。在我们的例子中，我们合成了原始和半透明覆盖的结果。

# 另见

*   *下载授权文件*配方

# 使用 Auth0 进行身份验证

随着人们每天与之交互的服务数量的增加，他们需要记住的用户名和密码的数量也在增加。除此之外，如果出现安全漏洞，用户信息存储的每个附加位置都是另一个可能被盗的位置。为了帮助缓解这一问题，像**Auth0**这样的服务允许您将身份验证服务集中在一个安全的平台上。

除了支持用户名和密码凭据之外，Auth0 还能够通过社交平台（如 Google、Facebook 或 Twitter）对用户进行身份验证。您可以通过短信或电子邮件发送的一次性密码使用无密码登录，甚至还有对不同服务的企业级支持。在本教程中，您将学习如何将 Auth0 应用程序连接到 Django，以及如何将其集成以处理用户身份验证。

# 准备

如果尚未执行此操作，请在[处创建一个 Auth0 应用程序 https://auth0.com/](https://auth0.com/) ​ 并按照此处的说明进行配置。免费计划中提供了两个社交连接，因此我们将激活谷歌和推特登录。您也可以尝试其他服务。请注意，其中一些要求您注册应用程序并获取 API 密钥和机密。

接下来，我们需要在项目中安装`python-social-auth`和一些其他依赖项。在您的`pip`要求中包括这些依赖项：

```py
# requirements/_base.txt
social-auth-app-django~=3.1
python-jose~=3.0
python-dotenv~=0.9
```

`social-auth-app-django` is a Django-specific package of the `python-social-auth` project that allows you to authenticate to your website using one of many social connections.

使用`pip`将这些依赖项安装到您的虚拟环境中。

# 怎么做。。。

要将 Auth0 连接到 Django 项目，请执行以下步骤：

1.  将社交认证 app 添加到设置文件中的`INSTALLED_APPS`，如下所示：

```py
# myproject/settings/_base.py
INSTALLED_APPS = [
    # …
    "social_django",
]
```

2.  现在，添加`social_django`应用程序所需的 Auth0 设置，如下所示：

```py
# myproject/settings/_base.py
SOCIAL_AUTH_AUTH0_DOMAIN = get_secret("AUTH0_DOMAIN")
SOCIAL_AUTH_AUTH0_KEY = get_secret("AUTH0_KEY")
SOCIAL_AUTH_AUTH0_SECRET = get_secret("AUTH0_SECRET")
SOCIAL_AUTH_AUTH0_SCOPE = ["openid", "profile", "email"]
SOCIAL_AUTH_TRAILING_SLASH = False

```

确保您在机密或环境变量中定义了`AUTH0_DOMAIN`、`AUTH0_KEY`和`AUTH0_SECRET`。这些变量的值可以在您在本配方的*准备*部分*步骤 1*中创建的 Auth0 应用程序的设置中找到。

3.  我们需要为 Auth0 连接创建后端，如下例所示：

```py
# myproject/apps/external_auth/backends.py from urllib import request
from jose import jwt
from social_core.backends.oauth import BaseOAuth2

class Auth0(BaseOAuth2):
    """Auth0 OAuth authentication backend"""

    name = "auth0"
    SCOPE_SEPARATOR = " "
    ACCESS_TOKEN_METHOD = "POST"
    REDIRECT_STATE = False
    EXTRA_DATA = [("picture", "picture"), ("email", "email")]

    def authorization_url(self):
        return "https://" + self.setting("DOMAIN") + "/authorize"

    def access_token_url(self):
        return "https://" + self.setting("DOMAIN") + "/oauth/token"

    def get_user_id(self, details, response):
        """Return current user id."""
        return details["user_id"]

    def get_user_details(self, response):
        # Obtain JWT and the keys to validate the signature
        id_token = response.get("id_token")
        jwks = request.urlopen(
            "https://" + self.setting("DOMAIN") + "/.well-
              known/jwks.json"
        )
        issuer = "https://" + self.setting("DOMAIN") + "/"
        audience = self.setting("KEY")  # CLIENT_ID
        payload = jwt.decode(
            id_token,
            jwks.read(),
            algorithms=["RS256"],
            audience=audience,
            issuer=issuer,
        )
        first_name, last_name = (payload.get("name") or 
         " ").split(" ", 1)
        return {
            "username": payload.get("nickname") or "",
            "first_name": first_name,
            "last_name": last_name,
            "picture": payload.get("picture") or "",
            "user_id": payload.get("sub") or "",
            "email": payload.get("email") or "",
        }
```

4.  将新后端添加到您的`AUTHENTICATION_BACKENDS`设置中，如下代码所示：

```py
# myproject/settings/_base.py
AUTHENTICATION_BACKENDS = {
    "myproject.apps.external_auth.backends.Auth0",
    "django.contrib.auth.backends.ModelBackend",
}
```

5.  我们希望社交身份验证用户可以从任何模板访问。因此，我们将为其创建一个上下文处理器：

```py
# myproject/apps/external_auth/context_processors.py
def auth0(request):
    data = {}
    if request.user.is_authenticated:
        auth0_user = request.user.social_auth.filter(
            provider="auth0",
        ).first()
        data = {
            "auth0_user": auth0_user,
        }
    return data
```

6.  接下来，我们需要在设置中注册它：

```py
# myproject/settings/_base.py
TEMPLATES = [
    {
        "BACKEND": 
        "django.template.backends.django.DjangoTemplates",
        "DIRS": [os.path.join(BASE_DIR, "myproject", "templates")],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors
                 .messages",
                "django.template.context_processors.media",
                "django.template.context_processors.static",
                "myproject.apps.core.context_processors
                 .website_url",
                "myproject.apps.external_auth
               .context_processors.auth0",
            ]
        },
    }
]
```

7.  现在，让我们为索引页、仪表板和注销创建视图：

```py
# myproject/apps/external_auth/views.py
from urllib.parse import urlencode

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth import logout as log_out
from django.conf import settings

def index(request):
    user = request.user
    if user.is_authenticated:
        return redirect(dashboard)
    else:
        return render(request, "index.html")

@login_required
def dashboard(request):
    return render(request, "dashboard.html")

def logout(request):
    log_out(request)
    return_to = urlencode({"returnTo": 
     request.build_absolute_uri("/")})
    logout_url = "https://%s/v2/logout?client_id=%s&%s" % (
        settings.SOCIAL_AUTH_AUTH0_DOMAIN,
        settings.SOCIAL_AUTH_AUTH0_KEY,
        return_to,
    )
    return redirect(logout_url)
```

8.  创建索引模板，如下所示：

```py
{# index.html #}
{% extends "base.html" %}
{% load i18n utility_tags %}

{% block content %}
<div class="login-box auth0-box before">
    <h3>{% trans "Please log in for the best user experience" %}</h3>
    <a class="btn btn-primary btn-lg" href="{% url "social:begin" 
     backend="auth0" %}">{% trans "Log in" %}</a>
</div>
{% endblock %}
```

9.  相应地创建仪表板模板：

```py
{# dashboard.html #}
{% extends "base.html" %}
{% load i18n %}

{% block content %}
    <div class="logged-in-box auth0-box logged-in">
        <img alt="{% trans 'Avatar' %}" src="{{ 
         auth0_user.extra_data.picture }}" 
         width="50" height="50" />
        <h2>{% blocktrans with name=request.user
         .first_name %}Welcome, {{ name }}
         {% endblocktrans %}!</h2>

        <a class="btn btn-primary btn-logout" href="{% url 
         "auth0_logout" %}">{% trans "Log out" %}</a>
    </div>
{% endblock %}
```

10.  更新 URL 规则：

```py
# myproject/urls.py
from django.conf.urls.i18n import i18n_patterns
from django.urls import path, include

from myproject.apps.external_auth import views as external_auth_views

urlpatterns = i18n_patterns(
    path("", external_auth_views.index, name="index"),
    path("dashboard/", external_auth_views.dashboard, 
     name="dashboard"),
    path("logout/", external_auth_views.logout, 
     name="auth0_logout"),
    path("", include("social_django.urls")),
    # …
)
```

11.  最后，添加登录 URL 设置：

```py
LOGIN_URL = "/login/auth0"
LOGIN_REDIRECT_URL = "dashboard"
```

# 它是如何工作的。。。

如果将浏览器指向项目的索引页，您将看到一个邀请您登录的链接。单击它时，您将被重定向到 Auth0 身份验证系统，其屏幕将类似于以下内容：

![](assets/6999e777-9040-41a5-93e8-b93bd128971a.png)

这一点是由`Auth0`后端`python-social-auth`通过配置其相关`SOCIAL_AUTH_*`设置来实现的。

成功登录完成后，Auth0 后端将从响应接收数据并对其进行处理。关联数据附加到与请求关联的用户对象。在仪表板视图中，用户详细信息被提取并添加到模板上下文中，该视图是身份验证进入`LOGIN_REDIRECT_URL`的结果。然后呈现`dashboard.html`。结果可能如下所示：

![](assets/0da83ec6-d5be-411f-9d3b-865f1de66ba7.png)

按下仪表板上的注销按钮后，用户将继续注销。

# 另见

*   *实现密码验证*配方
*   *下载授权文件*配方

# 缓存方法返回值

如果在请求-响应周期中多次调用具有大量计算或数据库查询的模型方法，则视图的性能可能会变得非常缓慢。在本配方中，您将了解一种模式，可以使用该模式缓存方法的返回值，以供以后重复使用。注意，这里我们没有使用 Django 缓存框架，只使用 Python 默认提供的框架。

# 准备

选择一个应用程序，其模型具有耗时的方法，该方法将在同一请求-响应周期中重复使用。

# 怎么做。。。

执行以下步骤：

1.  此模式可用于缓存模型的方法返回值，以便在视图、表单或模板中重复使用，如下所示：

```py
class SomeModel(models.Model):
    def some_expensive_function(self):
        if not hasattr(self, "_expensive_value_cached"):
            # do some heavy calculations...
            # ... and save the result to result variable
            self._expensive_value_cached = result
        return self._expensive_value_cached
```

2.  例如，让我们为`ViralVideo`模型创建一个`get_thumbnail_url()`方法。您将在[第 10 章](10.html)*中的*使用数据库查询表达式*配方*中对此进行更详细的探讨：

```py
# myproject/apps/viral_videos/models.py
import re
from django.db import models
from django.utils.translation import ugettext_lazy as _

from myproject.apps.core.models import CreationModificationDateBase, UrlBase

class ViralVideo(CreationModificationDateBase, UrlBase):
    embed_code = models.TextField(
        _("YouTube embed code"),
        blank=True)

    # …

    def get_thumbnail_url(self):
        if not hasattr(self, "_thumbnail_url_cached"):
            self._thumbnail_url_cached = ""
            url_pattern = re.compile(
                r'src="https://www.youtube.com/embed/([^"]+)"'
            )
            match = url_pattern.search(self.embed_code)
            if match:
                video_id = match.groups()[0]
                self._thumbnail_url_cached = (
                    f"https://img.youtube.com/vi/{video_id}/0.jpg"
                )
        return self._thumbnail_url_cached
```

# 它是如何工作的。。。

在这个通用示例中，该方法检查模型实例是否存在`_expensive_value_cached`属性。如果该属性不存在，将执行耗时的计算，并将结果指定给该新属性。在方法的末尾，将返回缓存的值。当然，如果有几个重要的方法，则需要使用不同的属性名称来保存每个计算值。

您现在可以在模板的页眉和页脚中使用类似于`{{ object.some_expensive_function }}`的内容，耗时的计算只需进行一次。

在模板中，您还可以在`{% if %}`条件和值的输出中使用该函数，如下所示：

```py
{% if object.some_expensive_function %}
    <span class="special">
        {{ object.some_expensive_function }}
    </span>
{% endif %}
```

在另一个示例中，我们检查了 YouTube 视频的缩略图，方法是解析视频嵌入代码的 URL，获取其 ID，然后合成缩略图图像的 URL。通过执行此操作，您可以在模板中使用它，如下所示：

```py
{% if video.get_thumbnail_url %}
    <figure>
        <img src="{{ video.get_thumbnail_url }}"
             alt="{{ video.title }}" 
        />
        <figcaption>{{ video.title }}</figcaption>
    </figure>
{% endif %}
```

# 还有更多。。。

我们刚才描述的方法只有在调用方法时不带参数才能起作用，因此结果总是相同的。但是如果输入不同怎么办？自 Python 3.2 以来，我们可以使用一个修饰符来提供基于散列参数（至少是可散列的参数）的方法调用的基本**缓存（最近使用的**（**LRU**）。

例如，让我们看一个精心设计的简单示例，其中一个函数接受两个值并返回一些昂贵逻辑的结果：

```py
def busy_bee(a, b):
    # expensive logic
    return result
```

如果我们有这样一个函数，并且希望提供一个缓存来存储一些常用输入变量的结果，那么我们可以使用`functools`包中的`@lru_cache`装饰器轻松地实现这一点，如下所示：

```py
from functools import lru_cache

@lru_cache(maxsize=100, typed=True)
def busy_bee(a, b):
    # expensive logic
    return result
```

现在，我们提供了一种缓存机制，它将在从输入散列的键下存储多达 100 个结果。在 Python 3.3 中添加了`typed`选项，通过指定`True`，我们已经这样做了，因此具有`a=1`和`b=2`的调用将与具有`a=1.0`和`b=2.0`的调用分开存储。根据逻辑的运行方式和返回值，这种变化可能是适当的，也可能是不适当的。

您可以在[的`functools`文档中了解有关`@lru_cache`装饰器的更多信息 https://docs.python.org/3/library/functools.html#functools.lru_cache](https://docs.python.org/3/library/functools.html#functools.lru_cache) 。

我们还可以在本配方前面的示例中使用此装饰器来简化代码，如下所示：

```py
# myproject/apps/viral_videos/models.py
from functools import lru_cache # …

class ViralVideo(CreationModificationDateMixin, UrlMixin):
    # …
    @lru_cache
    def get_thumbnail_url(self):
        # …
```

# 另见

*   [第 4 章](04.html)*，模板和 JavaScript*
*   使用 Memcached 缓存 Django 视图的*方法*
*   *使用 Redis 缓存 Django 视图*配方

# 使用 Memcached 缓存 Django 视图

Django 允许我们通过缓存最昂贵的部分（如数据库查询或模板呈现）来加快请求-响应周期。Django 本机支持的最快、最可靠的缓存是基于内存的缓存服务器**Memcached**。在本食谱中，您将学习如何使用 Memcached 来缓存`viral_videos`应用程序的视图。我们将在[第 10 章](10.html)*中的*使用数据库查询表达式*配方*中进一步探讨这一点。

# 准备

为了为 Django 项目准备缓存，我们需要做几件事：

1.  让我们安装`memcached`服务。例如，在 macOS 上执行此操作的最简单方法是使用自制软件：

```py
$ brew install memcached
```

2.  然后，您可以使用以下命令启动、停止或重新启动 Memcached 服务：

```py
$ brew services start memcached
$ brew services stop memcached
$ brew services restart memcached
```

在其他操作系统上，可以使用 apt-get、yum 或其他默认包管理实用程序安装 Memcached。另一种选择是从源代码处编译，如[所述 https://memcached.org/downloads](https://memcached.org/downloads) 。

3.  在虚拟环境中安装 Memcached Python 绑定，如下所示：

```py
(env)$ pip install python-memcached==1.59
```

# 怎么做。。。

要为特定视图集成缓存，请执行以下步骤：

1.  在项目设置中设置`CACHES`，如下：

```py
# myproject/settings/_base.py
CACHES = {
    "memcached": {
        "BACKEND": 
        "django.core.cache.backends.memcached.MemcachedCache",
        "LOCATION": get_secret("CACHE_LOCATION"),
        "TIMEOUT": 60,  # 1 minute
        "KEY_PREFIX": "myproject",
    },
}
CACHES["default"] = CACHES["memcached"]
```

2.  确保您的机密或环境变量中的`CACHE_LOCATION`设置为`"localhost:11211"`。
3.  修改`viral_videos`应用程序的视图，如下所示：

```py
# myproject/apps/viral_videos/views.py from django.shortcuts import render
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_cookie

@vary_on_cookie
@cache_page(60)
def viral_video_detail(request, pk):
    # …
    return render(
        request,
        "viral_videos/viral_video_detail.html",
        {'video': video}
    )
```

如果您遵循下一个配方中的 Redis 设置，您将看到`views.py`文件中没有任何更改。这向我们表明，我们可以随意更改底层缓存机制，而无需修改使用它的代码。

# 它是如何工作的。。。

正如您将在[第 10 章](10.html)、*钟声和哨声*中的*使用数据库查询表达式*配方中看到的，病毒视频的详细视图显示了经过身份验证和匿名用户的印象数。如果您访问病毒性视频（如在`http://127.0.0.1:8000/en/videos/1/`处），并在启用缓存的情况下刷新页面几次，您会注意到印象的数量每分钟只改变一次。这是因为每个用户的每个响应都会被缓存 60 秒。我们使用`@cache_page`装饰器为视图设置缓存。

Memcached 是一个键值存储，默认情况下，它使用完整的 URL 为每个缓存页面生成键值。当两个访问者同时访问同一页面时，第一个访问者的请求将接收由 Python 代码生成的页面，第二个访问者将从 Memcached 服务器获得相同的 HTML 代码。

在我们的示例中，为了确保每个访问者都得到单独的处理，即使他们访问相同的 URL，我们使用了`@vary_on_cookie`装饰器。此装饰程序检查 HTTP 请求中`Cookie`头的唯一性。

您可以从[的官方文档中了解更多关于 Django 的缓存框架的信息 https://docs.djangoproject.com/en/3.0/topics/cache/](https://docs.djangoproject.com/en/3.0/topics/cache/) 。类似地，您可以在[上找到有关 Memcached 的更多信息 https://memcached.org/](https://memcached.org/) 。

# 另见

*   *缓存方法返回值*配方
*   *使用 Redis 缓存 Django 视图*配方
*   [第 10 章](10.html)*中的*使用数据库查询表达式*配方*

# 使用 Redis 缓存 Django 视图

尽管 Memcached 作为一种缓存机制在市场上已经很成熟，并且受到 Django 的良好支持，但 Redis 是一种替代系统，它提供了 Memcached 的所有功能以及更多功能。在这里，我们将重温使用 Memcached 缓存 Django 视图的*过程，并学习如何使用 Redis 进行同样的操作。*

# 准备

为了为 Django 项目准备缓存，我们需要做几件事：

1.  让我们安装 Redis 服务。例如，在 macOS 上执行此操作的最简单方法是使用自制软件：

```py
$ brew install redis
```

2.  然后，您可以使用以下命令启动、停止或重新启动 Redis 服务：

```py
$ brew services start redis
$ brew services stop redis
$ brew services restart redis
```

在其他操作系统上，可以使用 apt-get、yum 或其他默认包管理实用程序安装 Redis。另一种选择是从源代码处编译，如[所述 https://redis.io/download](https://redis.io/download) 。

3.  在虚拟环境中安装 Django 的 Redis 缓存后端及其依赖项，如下所示：

```py
(env)$ pip install redis==3.3.11
(env)$ pip install hiredis==1.0.1
(env)$ pip install django-redis-cache==2.1.0

```

# 怎么做。。。

要为特定视图集成缓存，请执行以下步骤：

1.  在项目设置中设置`CACHES`，如下：

```py
# myproject/settings/_base.py
CACHES = {
    "redis": {
        "BACKEND": "redis_cache.RedisCache",
        "LOCATION": [get_secret("CACHE_LOCATION")],
        "TIMEOUT": 60, # 1 minute
        "KEY_PREFIX": "myproject",
    },
}
CACHES["default"] = CACHES["redis"]
```

2.  确保您的机密或环境变量中的`CACHE_LOCATION`设置为`"localhost:6379"`。
3.  修改`viral_videos`应用程序的视图，如下所示：

```py
# myproject/apps/viral_videos/views.py from django.shortcuts import render
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_cookie

@vary_on_cookie
@cache_page(60)
def viral_video_detail(request, pk):
    # …
    return render(
        request,
        "viral_videos/viral_video_detail.html",
        {'video': video}
    )
```

如果您按照上一个配方中的 Memcached 设置，您将看到此处的`views.py`没有任何变化。这表明我们可以随意更改底层缓存机制，而无需修改使用它的代码。

# 它是如何工作的。。。

与 Memcached 一样，我们使用`@cache_page`装饰器为视图设置缓存。因此，每个用户的每个响应都会被缓存 60 秒。病毒视频详细视图（如`http://127.0.0.1:8000/en/videos/1/`中的视图）显示了经过身份验证和匿名用户的印象数量。启用缓存后，如果刷新页面几次，您会注意到印象的数量每分钟只更改一次。

与 Memcached 一样，Redis 是一个键值存储，当用于缓存时，它会根据完整的 URL 为每个缓存页面生成键值。当两个访问者同时访问同一页面时，第一个访问者的请求将接收由 Python 代码生成的页面，第二个访问者将从 Redis 服务器获得相同的 HTML 代码。

在我们的示例中，为了确保每个访问者都得到单独的处理，即使他们访问相同的 URL，我们使用了`@vary_on_cookie`装饰器。此装饰程序检查 HTTP 请求中`Cookie`头的唯一性。

您可以从[的官方文档中了解更多关于 Django 的缓存框架的信息 https://docs.djangoproject.com/en/3.0/topics/cache/](https://docs.djangoproject.com/en/3.0/topics/cache/) 。类似地，您可以在[上找到有关 Memcached 的更多信息 https://redis.io/](https://redis.io/) 。

# 还有更多。。。

虽然 Redis 能够以与 Memcached 相同的方式处理缓存，但系统中内置的缓存算法还有许多其他选项。除了缓存，Redis 还可以用作数据库或消息存储。它支持各种数据结构、事务、发布/订阅和自动故障切换等。

通过 django redis 缓存后端，redis 也可以配置为会话后端，几乎不费吹灰之力，如下所示：

```py
# myproject/settings/_base.py
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "default"
```

# 另见

*   *缓存方法返回值*配方
*   使用 Memcached 缓存 Django 视图的*方法*
*   [第 10 章](10.html)*中*使用数据库查询表达式*配方*