# 模型和数据库结构

在本章中，我们将介绍以下主题：

*   使用模型混合器
*   使用 URL 相关方法创建模型 mixin
*   创建模型 mixin 以处理创建和修改日期
*   创建模型 mixin 以处理元标记
*   创建模型 mixin 以处理泛型关系
*   处理多语言字段
*   使用模型转换表
*   避免循环依赖
*   添加数据库约束
*   使用迁移
*   将外键更改为多对多字段

# 介绍

启动新应用程序时，首先要做的是创建表示数据库结构的模型。我们假设您已经创建了 Django 应用程序，或者至少已经阅读并理解了 Django 官方教程。在本章中，您将看到一些有趣的技术，这些技术将使您的数据库结构在项目中的不同应用程序之间保持一致。然后，您将看到如何处理数据库中数据的国际化。之后，您将学习如何避免模型中的循环依赖关系以及如何设置数据库约束。在本章末尾，您将看到如何在开发过程中使用迁移来更改数据库结构。

# 技术要求

要使用本书中的代码，您需要 Python 的最新稳定版本、MySQL 或 PostgreSQL 数据库以及带有虚拟环境的 Django 项目。

您可以在 GitHub 存储库的`ch02`目录中找到本章的所有代码，网址为：[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition) 。

# 使用模型混合器

在面向对象语言（如 Python）中，可以将 mixin 类视为具有实现特性的接口。当一个模型扩展一个 mixin 时，它实现接口并包括它的所有字段、属性、属性和方法。当您想要在不同的模型中多次重用通用功能时，可以使用 Django 模型中的 mixin。Django 中的模型混合是抽象的基本模型类。我们将在接下来的几个食谱中探索它们。

# 准备

首先，您需要创建可重用的 mixin。在`myproject.apps.core`应用程序中有一个保存模型混音的好地方。如果您创建了一个可重用的应用程序，您将与其他人共享，那么将模型混合保存在可重用应用程序本身中，可能保存在一个`base.py`文件中。

# 怎么做。。。

打开要使用 mixins 的任何 Django 应用程序的`models.py`文件，并键入以下代码：

```
# myproject/apps/ideas/models.py
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.models import (
    CreationModificationDateBase,
    MetaTagsBase,
    UrlBase,
)

class Idea(CreationModificationDateBase, MetaTagsBase, UrlBase):
    title = models.CharField(
        _("Title"),
        max_length=200,
    )
    content = models.TextField(
        _("Content"),
    )
    # other fields…

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title

    def get_url_path(self):
        return reverse("idea_details", kwargs={
            "idea_id": str(self.pk),
        })
```

# 它是如何工作的。。。

Django 的模型继承支持三种类型的继承：抽象基类、多表继承和代理模型。模型混合是抽象模型类，因为我们通过使用抽象的`Meta`类来定义它们，该类具有指定的字段、属性和方法。当您创建一个模型，例如`Idea`，如上例所示，它继承了`CreationModificationDateMixin`、`MetaTagsMixin`和`UrlMixin`的所有特征。这些抽象类的所有字段都保存在与扩展模型的字段相同的数据库表中。在下面的食谱中，您将学习如何定义模型混合。

# 还有更多。。。

在正常的 Python 类继承中，如果有多个基类，并且所有基类都实现了一个特定的方法，并且您在子类的实例上调用了该方法，那么将只调用第一个父类中的方法，如下例所示：

```
>>> class A(object):
... def test(self):
...     print("A.test() called")
... 

>>> class B(object):
... def test(self):
...     print("B.test() called")
... 

>>> class C(object):
... def test(self):
...     print("C.test() called")
... 

>>> class D(A, B, C):
... def test(self):
...     super().test()
...     print("D.test() called")

>>> d = D()
>>> d.test()
A.test() called
D.test() called
```

Django 模型基类也是如此；然而，有一个特殊的例外。

Django 框架通过调用每个基类中的`save()`和`delete()`方法的元类实现了一些魔力。

这意味着您可以通过覆盖`save()`和`delete()`方法，自信地对 mixin 中专门定义的特定字段执行预保存、后保存、预删除和后删除操作。

要了解有关不同类型的模型继承的更多信息，请参阅官方 Django 文档，可在[上获得 https://docs.djangoproject.com/en/2.2/topics/db/models/#model-继承](https://docs.djangoproject.com/en/2.2/topics/db/models/#model-inheritance)。

# 另见

*   *使用 URL 相关方法创建模型 mixin*配方
*   *创建模型 mixin 以处理创建和修改日期*配方
*   *创建模型 mixin 来处理元标记*配方

# 使用 URL 相关方法创建模型 mixin

对于每个有自己独特细节页面的模型，定义`get_absolute_url()`方法是一个很好的实践。此方法可以在模板中使用，也可以在 Django 管理站点中使用，以预览保存的对象。但是，`get_absolute_url()`是不明确的，因为它返回的是 URL 路径而不是完整的 URL。

在这个配方中，我们将看看如何创建一个模型 mixin，它为特定于模型的 URL 提供简化的支持。此 mixin 将使您能够执行以下操作：

*   允许您在模型中定义 URL 路径或完整 URL
*   根据您定义的 URL 自动生成另一个 URL
*   在幕后定义`get_absolute_url()`方法

# 准备

如果您还没有这样做，请创建`myproject.apps.core`应用程序，您将在其中存储模型混音。然后，在核心包中创建一个`models.py`文件。或者，如果您创建了一个可重用的应用程序，请将 mixin 放入该应用程序中的`base.py`文件中。

# 怎么做。。。

逐个执行以下步骤：

1.  将以下内容添加到您的`core`应用程序的`models.py`文件中：

```
# myproject/apps/core/models.py from urllib.parse import urlparse, urlunparse
from django.conf import settings
from django.db import models

class UrlBase(models.Model):
    """
    A replacement for get_absolute_url()
    Models extending this mixin should have either get_url or 
     get_url_path implemented.
    """
    class Meta:
        abstract = True

    def get_url(self):
        if hasattr(self.get_url_path, "dont_recurse"):
            raise NotImplementedError
        try:
            path = self.get_url_path()
        except NotImplementedError:
            raise
        return settings.WEBSITE_URL + path
    get_url.dont_recurse = True

    def get_url_path(self):
        if hasattr(self.get_url, "dont_recurse"):
            raise NotImplementedError
        try:
            url = self.get_url()
        except NotImplementedError:
            raise
        bits = urlparse(url)
        return urlunparse(("", "") + bits[2:])
    get_url_path.dont_recurse = True

    def get_absolute_url(self):
        return self.get_url()
```

2.  将不带尾随斜杠的`WEBSITE_URL`设置添加到`dev`、`test`、`staging`和`production`设置中。例如，对于开发环境，这将如下所示：

```
# myproject/settings/dev.py
from ._base import *

DEBUG = True
WEBSITE_URL = "http://127.0.0.1:8000"  # without trailing slash
```

3.  要在应用程序中使用 mixin，请从`core`应用程序导入 mixin，在模型类中继承 mixin，并定义`get_url_path()`方法，如下所示：

```
# myproject/apps/ideas/models.py
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.models import UrlBase

class Idea(UrlBase):
    # fields, attributes, properties and methods…

    def get_url_path(self):
        return reverse("idea_details", kwargs={
            "idea_id": str(self.pk),
        })
```

# 它是如何工作的。。。

`UrlBase`类是一个抽象模型，有三种方法，如下所示：

*   `get_url()`检索对象的完整 URL。
*   `get_url_path()`获取对象的绝对路径。
*   `get_absolute_url()`模仿`get_url_path()`方法。

`get_url()`和`get_url_path()`方法预计会在扩展模型类中被覆盖，例如`Idea`。您可以定义`get_url()`，而`get_url_path()`会将其剥离到路径。或者，您可以定义`get_url_path()`，并且`get_url()`会将网站 URL 前置到路径的开头。

经验法则是总是覆盖`get_url_path()`方法。

在模板中，当您需要指向同一网站上对象的链接时，请使用`get_url_path()`，如下所示：

```
<a href="{{ idea.get_url_path }}">{{ idea.title }}</a>
```

将`get_url()`用于外部通信中的链接，如电子邮件、RSS 提要或 API 中的链接；例如：

```
<a href="{{ 
idea.get_url }}">{{ idea.title }}</a>
```

默认的`get_absolute_url()`方法将在 Django 模型管理中用于查看站点功能，某些第三方 Django 应用程序也可能使用该方法。

# 还有更多。。。

一般来说，不要在 URL 中使用增量主键，因为向最终用户公开这些主键是不安全的：项目的总量是可见的，只需更改 URL 路径就很容易浏览不同的项目。

仅当 URL 中的主键是**通用唯一标识符**（**UUID**或生成的随机字符串时，您才可以将其用于详细信息页面。否则，创建并使用 slug 字段，如下所示：

```
class Idea(UrlBase):
    slug = models.SlugField(_("Slug for URLs"), max_length=50)
```

# 另见

*   *使用模型混合*配方
*   *创建模型 mixin 以处理创建和修改日期*配方
*   *创建模型 mixin 来处理元标记*配方
*   *创建模型 mixin 来处理泛型关系*配方
*   *在[第 1 章](01.html)*中的*为开发、测试、暂存和生产环境配置设置*配方，开始使用 Django 3.0**

# 创建模型 mixin 以处理创建和修改日期

通常在模型中包含时间戳，用于创建和修改模型实例。在这个配方中，您将学习如何创建一个简单的模型 mixin，它可以保存模型的创建和修改日期和时间。使用这样的 mixin 将确保所有模型对时间戳使用相同的字段名，并且具有相同的行为。

# 准备

如果您还没有这样做，请创建`myproject.apps.core`包来保存您的混音。然后，在核心包中创建`models.py`文件。

# 怎么做。。。

打开`myprojects.apps.core`包中的`models.py`文件，并在其中插入以下内容：

```
# myproject/apps/core/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _

class CreationModificationDateBase(models.Model):
    """
    Abstract base class with a creation and modification date and time
    """

    created = models.DateTimeField(
        _("Creation Date and Time"),
        auto_now_add=True,
    )

    modified = models.DateTimeField(
        _("Modification Date and Time"),
        auto_now=True,
    )

    class Meta:
        abstract = True
```

# 它是如何工作的。。。

`CreationModificationDateMixin`类是一个抽象模型，这意味着扩展模型类将在同一个数据库表中创建所有字段，也就是说，不存在使表更复杂的一对一关系。

此 mixin 有两个日期时间字段，`created`和`modified`。通过`auto_now_add`和`auto_now`属性，保存模型实例时会自动保存时间戳。这些字段将自动获得`editable=False`属性，因此将隐藏在管理表单中。如果在设置中`USE_TZ`设置为`True`（这是默认值和建议值），则将使用时区感知时间戳。否则，将使用时区原始时间戳。时区感知时间戳保存在数据库中的**协调世界时**（**UTC**时区）中，并在读取或写入时转换为项目的默认时区。时区原始时间戳保存在数据库中项目的本地时区中；一般来说，它们并不实用，因为它们使时区之间的时间管理更加复杂。

要使用此 mixin，我们只需导入它并扩展我们的模型，如下所示：

```
# myproject/apps/ideas/models.py
from django.db import models

from myproject.apps.core.models import CreationModificationDateBase

class Idea(CreationModificationDateBase):
    # other fields, attributes, properties, and methods…
```

# 另见

*   *使用模型混合*配方
*   *创建模型 mixin 来处理元标记*配方
*   *创建模型 mixin 来处理泛型关系*配方

# 创建模型 mixin 以处理元标记

当您为搜索引擎优化站点时，您不仅需要为每个页面使用语义标记，还必须包含适当的元标记。为了获得最大的灵活性，它有助于定义通用元标记的内容，特定于在您的网站上有自己详细信息页面的对象。在这个配方中，我们将了解如何为与关键字、描述、作者和版权元标记相关的字段和方法创建一个模型 mixin。

# 准备

正如前面的食谱中所详细说明的，确保你有用于混合的`myproject.apps.core`包装。另外，在包下创建一个目录结构`templates/utils/includes/`，并在其中创建一个`meta.html`文件来存储基本的元标记标记。

# 怎么做。。。

让我们创建我们的模型 mixin：

1.  请确保在设置中将`"myproject.apps.core"`添加到`INSTALLED_APPS`中，因为我们希望此模块考虑`templates`目录。
2.  将以下基本元标记标记添加到`meta_field.html`：

```
{# templates/core/includes/meta_field.html #}
<meta name="{{ name }}" content="{{ content }}" />
```

3.  在您喜爱的编辑器中打开 core 软件包中的`models.py`文件，并添加以下内容：

```
# myproject/apps/core/models.py from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
from django.utils.safestring import mark_safe
from django.template.loader import render_to_string

class MetaTagsBase(models.Model):
    """
    Abstract base class for generating meta tags
    """
    meta_keywords = models.CharField(
        _("Keywords"),
        max_length=255,
        blank=True,
        help_text=_("Separate keywords with commas."),
    )
    meta_description = models.CharField(
        _("Description"),
        max_length=255,
        blank=True,
    )
    meta_author = models.CharField(
        _("Author"),
        max_length=255,
        blank=True,
    )
    meta_copyright = models.CharField(
        _("Copyright"),
        max_length=255,
        blank=True,
    )

    class Meta:
        abstract = True

    def get_meta_field(self, name, content):
        tag = ""
        if name and content:
            tag = render_to_string("core/includes/meta_field.html", 
            {
                "name": name,
                "content": content,
            })
        return mark_safe(tag)

    def get_meta_keywords(self):
        return self.get_meta_field("keywords", self.meta_keywords)

    def get_meta_description(self):
        return self.get_meta_field("description", 
         self.meta_description)

    def get_meta_author(self):
        return self.get_meta_field("author", self.meta_author)

    def get_meta_copyright(self):
        return self.get_meta_field("copyright", 
         self.meta_copyright)

    def get_meta_tags(self):
        return mark_safe("\n".join((
            self.get_meta_keywords(),
            self.get_meta_description(),
            self.get_meta_author(),
            self.get_meta_copyright(),
        )))
```

# 它是如何工作的。。。

这个 mixin 在扩展后的模型中添加了四个字段：`meta_keywords`、`meta_description`、`meta_author`和`meta_copyright`。还添加了用于呈现相关元标记的相应的`get_*()`方法。每种方法都将名称和适当的字段内容传递给核心`get_meta_field()`方法，该方法使用此输入返回基于`meta_field.html`模板的呈现标记。最后，提供了一种快捷方式`get_meta_tags()`方法，一次为所有可用元数据生成组合标记。

如果您在模型中使用此 mixin，如本章开头的*使用模型 mixin*配方中所示的`Idea`，您可以将以下内容放在`detail`页面模板的`HEAD`部分，一次呈现所有元标记，如下所示：

```
{% block meta_tags %}
{{ block.super }}
{{ idea.get_meta_tags }}
{% endblock %}
```

在这里，父模板中定义了一个`meta_tags`块，该片段显示了子模板如何重新定义该块，包括来自父模板的内容，首先是`block.super`，并使用`idea`对象中的附加标记对其进行扩展。您还可以使用类似于以下内容的方式仅呈现特定的元标记：`{{ idea.get_meta_description }}`。

正如您从`models.py`代码中注意到的，呈现的元标记被标记为安全的——也就是说，它们不会被转义，我们不需要使用`safe`模板过滤器。只有来自数据库的值被转义，以保证最终的 HTML 格式正确。当我们为`meta_field.html`模板调用`render_to_string()`时，`meta_keywords`和其他字段中的数据库数据将自动转义，因为该模板在其内容中没有指定`{% autoescape off %}`。

# 另见

*   *使用模型混合*配方
*   *创建模型 mixin 以处理创建和修改日期*配方
*   *创建模型 mixin 来处理泛型关系*配方
*   *在[第 4 章](04.html)*中安排 base.html 模板*配方，模板和 JavaScript*

# 创建模型 mixin 以处理泛型关系

除了正常的数据库关系（如外键关系或多对多关系）之外，Django 还有一种将模型与任何其他模型的实例关联的机制。这个概念被称为泛型关系。对于每个泛型关系，我们保存相关模型的内容类型以及该模型实例的 ID。

在本食谱中，我们将了解如何在模型混合中抽象泛型关系的创建。

# 准备

要使此配方起作用，您需要安装`contenttypes`应用程序。默认情况下应该在设置的`INSTALLED_APPS`列表中，如下代码所示：

```
# myproject/settings/_base.py

INSTALLED_APPS = [
    # contributed
    "django.contrib.admin",
    "django.contrib.auth",
 "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # third-party
    # ...
    # local
    "myproject.apps.core",
    "myproject.apps.categories",
    "myproject.apps.ideas",
]
```

再次确认你已经为你的混音模型创建了`myproject.apps.core`应用程序。

# 怎么做。。。

要为泛型关系创建和使用 mixin，请执行以下步骤：

1.  在文本编辑器中打开核心包中的`models.py`文件，并在其中插入以下内容：

```
# myproject/apps/core/models.py from django.db import models
from django.utils.translation import gettext_lazy as _
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from django.core.exceptions import FieldError

def object_relation_base_factory(
        prefix=None,
        prefix_verbose=None,
        add_related_name=False,
        limit_content_type_choices_to=None,
        is_required=False):
    """
    Returns a mixin class for generic foreign keys using
    "Content type - object ID" with dynamic field names.
    This function is just a class generator.

    Parameters:
    prefix:           a prefix, which is added in front of
                      the fields
    prefix_verbose:   a verbose name of the prefix, used to
                      generate a title for the field column
                      of the content object in the Admin
    add_related_name: a boolean value indicating, that a
                      related name for the generated content
                      type foreign key should be added. This
                      value should be true, if you use more
                      than one ObjectRelationBase in your
                      model.

    The model fields are created using this naming scheme:
        <<prefix>>_content_type
        <<prefix>>_object_id
        <<prefix>>_content_object
    """
    p = ""
    if prefix:
        p = f"{prefix}_"

    prefix_verbose = prefix_verbose or _("Related object")
    limit_content_type_choices_to = limit_content_type_choices_to 
     or {}

    content_type_field = f"{p}content_type"
    object_id_field = f"{p}object_id"
    content_object_field = f"{p}content_object"

    class TheClass(models.Model):
 class Meta:
 abstract = True

    if add_related_name:
        if not prefix:
            raise FieldError("if add_related_name is set to "
                             "True, a prefix must be given")
        related_name = prefix
    else:
        related_name = None

    optional = not is_required

    ct_verbose_name = _(f"{prefix_verbose}'s type (model)")

    content_type = models.ForeignKey(
        ContentType,
        verbose_name=ct_verbose_name,
        related_name=related_name,
        blank=optional,
        null=optional,
        help_text=_("Please select the type (model) "
                    "for the relation, you want to build."),
        limit_choices_to=limit_content_type_choices_to,
        on_delete=models.CASCADE)

    fk_verbose_name = prefix_verbose

    object_id = models.CharField(
        fk_verbose_name,
        blank=optional,
        null=False,
        help_text=_("Please enter the ID of the related object."),
        max_length=255,
        default="")  # for migrations

    content_object = GenericForeignKey(
        ct_field=content_type_field,
        fk_field=object_id_field)

    TheClass.add_to_class(content_type_field, content_type)
    TheClass.add_to_class(object_id_field, object_id)
    TheClass.add_to_class(content_object_field, content_object)

    return TheClass
```

2.  下面的代码片段是如何在应用程序中使用两个通用关系的示例（将此代码放在`ideas/models.py`中）：

```
# myproject/apps/ideas/models.py from django.db import models
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.models import (
    object_relation_base_factory as generic_relation,
)

FavoriteObjectBase = generic_relation(
    is_required=True,
)

OwnerBase = generic_relation(
    prefix="owner",
    prefix_verbose=_("Owner"),
    is_required=True,
    add_related_name=True,
    limit_content_type_choices_to={
        "model__in": (
            "user",
            "group",
        )
    }
)

class Like(FavoriteObjectBase, OwnerBase):
    class Meta:
        verbose_name = _("Like")
        verbose_name_plural = _("Likes")

    def __str__(self):
        return _("{owner} likes {object}").format(
            owner=self.owner_content_object,
            object=self.content_object
        )
```

# 它是如何工作的。。。

如您所见，此代码段比前面的代码段更复杂。

`object_relation_base_factory`函数，简称为`generic_relation`，在我们的导入中，它本身不是一个 mixin；它是一个生成模型 mixin 的函数，也就是一个要从中扩展的抽象模型类。动态创建的 mixin 添加了`content_type`和`object_id`字段以及指向相关实例的`content_object`通用外键。

为什么我们不能用这三个属性定义一个简单的模型？动态生成的抽象类允许我们为每个字段名设置前缀；因此，在同一个模型中可以有多个泛型关系。例如，前面显示的`Like`模型将有`content_type`、`object_id`和`content_object`字段用于最喜欢的对象，以及`owner_content_type`、`owner_object_id`和`owner_content_object`字段用于喜欢该对象的对象（用户或组）。

`object_relation_base_factory`函数（简称
为`generic_relation`的别名）增加了通过`limit_content_type_choices_to`参数限制内容类型选择的可能性。前面的示例将对`owner_content_type`的选择仅限于`User`和`Group`模型的内容类型。

# 另见

*   *使用 URL 相关方法创建模型 mixin*配方
*   *创建模型 mixin 以处理创建和修改日期*配方
*   *创建模型 mixin 来处理元标记*配方
*   在[Ch](04.html)[apter](04.html)[4](04.html)*中实现类似小部件*配方的*模板和 JavaScript*

# 处理多语言字段

Django 使用国际化机制翻译代码和模板中的详细字符串。但是，如何在模型中实现多语言内容取决于开发人员。我们将向您展示如何在项目中直接实现多语言模型的几种方法。第一种方法是在模型中使用特定于语言的字段。

这种方法具有以下特点：

*   在模型中定义多语言字段很简单。
*   在数据库查询中使用多语言字段很简单。
*   您可以使用“贡献管理”来编辑具有多语言字段的模型，而无需进行其他修改。
*   如果需要，可以毫不费力地在同一模板中显示对象的所有翻译。
*   更改设置中的语言数量后，需要为所有多语言模型创建和运行迁移。

# 准备

您是否创建了本章前面配方中使用的`myproject.apps.core`包？您现在需要在`core`应用程序中为自定义模型字段创建一个新的`model_fields.py`文件。

# 怎么做。。。

执行以下步骤以定义多语言字符字段和多语言文本字段：

1.  打开`model_fields.py`文件，创建基础多语字段，如下所示：

```
# myproject/apps/core/model_fields.py from django.conf import settings
from django.db import models
from django.utils.translation import get_language
from django.utils import translation

class MultilingualField(models.Field):
    SUPPORTED_FIELD_TYPES = [models.CharField, models.TextField]

    def __init__(self, verbose_name=None, **kwargs):
        self.localized_field_model = None
        for model in MultilingualField.SUPPORTED_FIELD_TYPES:
            if issubclass(self.__class__, model):
                self.localized_field_model = model
        self._blank = kwargs.get("blank", False)
        self._editable = kwargs.get("editable", True)
        super().__init__(verbose_name, **kwargs)

    @staticmethod
    def localized_field_name(name, lang_code):
        lang_code_safe = lang_code.replace("-", "_")
        return f"{name}_{lang_code_safe}"

    def get_localized_field(self, lang_code, lang_name):
        _blank = (self._blank
                  if lang_code == settings.LANGUAGE_CODE
                  else True)
        localized_field = self.localized_field_model(
            f"{self.verbose_name} ({lang_name})",
            name=self.name,
            primary_key=self.primary_key,
            max_length=self.max_length,
            unique=self.unique,
            blank=_blank,
            null=False, # we ignore the null argument!
            db_index=self.db_index,
            default=self.default or "",
            editable=self._editable,
            serialize=self.serialize,
            choices=self.choices,
            help_text=self.help_text,
            db_column=None,
            db_tablespace=self.db_tablespace)
        return localized_field

    def contribute_to_class(self, cls, name,
                            private_only=False,
                            virtual_only=False):
        def translated_value(self):
            language = get_language()
            val = self.__dict__.get(
                MultilingualField.localized_field_name(
                        name, language))
            if not val:
                val = self.__dict__.get(
                    MultilingualField.localized_field_name(
                            name, settings.LANGUAGE_CODE))
            return val

        # generate language-specific fields dynamically
        if not cls._meta.abstract:
            if self.localized_field_model:
                for lang_code, lang_name in settings.LANGUAGES:
                    localized_field = self.get_localized_field(
                        lang_code, lang_name)
                    localized_field.contribute_to_class(
                            cls,
                            MultilingualField.localized_field_name(
                                    name, lang_code))

                setattr(cls, name, property(translated_value))
            else:
                super().contribute_to_class(
                    cls, name, private_only, virtual_only)
```

2.  在同一文件中，为字符和文本字段表单的基字段创建子类，如下所示：

```
class MultilingualCharField(models.CharField, MultilingualField):
    pass

class MultilingualTextField(models.TextField, MultilingualField):
    pass
```

3.  在核心应用中创建一个`admin.py`文件，并添加以下内容：

```
# myproject/apps/core/admin.py
from django.conf import settings

def get_multilingual_field_names(field_name):
    lang_code_underscored = settings.LANGUAGE_CODE.replace("-", 
     "_")
    field_names = [f"{field_name}_{lang_code_underscored}"]
    for lang_code, lang_name in settings.LANGUAGES:
        if lang_code != settings.LANGUAGE_CODE:
            lang_code_underscored = lang_code.replace("-", "_")
            field_names.append(
                f"{field_name}_{lang_code_underscored}"
            )
    return field_names
```

现在，我们将考虑如何在应用程序中使用多语言字段，如下所示：

1.  首先，在项目的设置中设置多种语言。比如说，我们的网站将支持欧盟的所有官方语言，默认语言为英语：

```
# myproject/settings/_base.py LANGUAGE_CODE = "en"

# All official languages of European Union
LANGUAGES = [
    ("bg", "Bulgarian"),    ("hr", "Croatian"),
    ("cs", "Czech"),        ("da", "Danish"),
    ("nl", "Dutch"),        ("en", "English"),
    ("et", "Estonian"),     ("fi", "Finnish"),
    ("fr", "French"),       ("de", "German"),
    ("el", "Greek"),        ("hu", "Hungarian"),
    ("ga", "Irish"),        ("it", "Italian"),
    ("lv", "Latvian"),      ("lt", "Lithuanian"),
    ("mt", "Maltese"),      ("pl", "Polish"),
    ("pt", "Portuguese"),   ("ro", "Romanian"),
    ("sk", "Slovak"),       ("sl", "Slovene"),
    ("es", "Spanish"),      ("sv", "Swedish"),
]
```

2.  然后，从`myproject.apps.ideas`应用打开`models.py`文件，为`Idea`模型创建多语言字段，如下所示：

```
# myproject/apps/ideas/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.model_fields import (
    MultilingualCharField,
    MultilingualTextField,
)

class Idea(models.Model):
    title = MultilingualCharField(
        _("Title"),
        max_length=200,
    )
    content = MultilingualTextField(
        _("Content"),
    )

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title
```

3.  为`ideas`应用程序创建`admin.py`文件：

```
# myproject/apps/ideas/admin.py
from django.contrib import admin
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.admin import get_multilingual_field_names

from .models import Idea

@admin.register(Idea)
class IdeaAdmin(admin.ModelAdmin):
    fieldsets = [
        (_("Title and Content"), {
            "fields": get_multilingual_field_names("title") +
                      get_multilingual_field_names("content")
        }),
    ]
```

# 它是如何工作的。。。

`Idea`的示例将生成一个与以下类似的模型：

```
class Idea(models.Model):
    title_bg = models.CharField(
        _("Title (Bulgarian)"),
        max_length=200,
    )
    title_hr = models.CharField(
        _("Title (Croatian)"),
        max_length=200,
    )
    # titles for other languages…
    title_sv = models.CharField(
        _("Title (Swedish)"),
        max_length=200,
    )

    content_bg = MultilingualTextField(
        _("Content (Bulgarian)"),
    )
    content_hr = MultilingualTextField(
        _("Content (Croatian)"),
    )
    # content for other languages…
    content_sv = MultilingualTextField(
        _("Content (Swedish)"),
    )

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title
```

如果有任何带破折号的语言代码，如瑞士德语的“de ch”，则这些语言的字段将替换为下划线，如`title_de_ch`和`content_de_ch`。

除了生成的特定于语言的字段外，还有两个属性-`title`和`content`-将返回当前活动语言中的相应字段。如果没有可用的本地化字段内容，这些字段将返回默认语言。

`MultilingualCharField`和`MultilingualTextField`字段将根据您的`LANGUAGES`设置动态调整模型字段。它们将覆盖 Django 框架创建模型类时使用的`contribute_to_class()`方法。多语言字段为项目的每种语言动态添加字符或文本字段。您需要创建数据库迁移，以便在数据库中添加适当的字段。此外，默认情况下，创建属性以返回当前活动语言或主语言的翻译值。

在管理中，`get_multilingual_field_names()`将返回一个特定于语言的字段名列表，从一种默认语言开始，然后从`LANGUAGES`设置继续使用其他语言。

下面是几个示例，说明如何在模板和视图中使用多语言字段。

如果模板中有以下代码，它将以当前活动语言（比如立陶宛语）显示文本，如果翻译不存在，则返回到英语：

```
<h1>{{ idea.title }}</h1>
<div>{{ idea.content|urlize|linebreaks }}</div>
```

如果您希望您的`QuerySet`按翻译后的标题排序，可以定义如下：

```
>>> lang_code = input("Enter language code: ")
>>> lang_code_underscored = lang_code.replace("-", "_")
>>> qs = Idea.objects.order_by(f"title_{lang_code_underscored}")
```

# 另见

*   *使用模型转换表*配方
*   *使用迁移*配方
*   [第 6 章](06.html)*模型管理*

# 使用模型转换表

处理数据库中多语言内容的第二种方法涉及为每个多语言模型使用模型转换表。

这种方法的特点如下：

*   您可以使用“贡献的管理”将翻译编辑为内联线。
*   更改设置中的语言数量后，无需迁移或其他进一步操作。
*   您可以毫不费力地在模板中显示当前语言的翻译，但在同一页面上以特定语言显示多个翻译会更加困难。
*   您必须知道并使用本配方中描述的特定模式来创建模型转换。
*   在数据库查询中使用这种方法并不是那么简单，但是，正如您将看到的，它仍然是可能的。

# 准备

再次，我们将从`myprojects.apps.core`应用程序开始。

# 怎么做。。。

执行以下步骤以准备多语言模型：

1.  在`core`app 中创建`model_fields.py`，内容如下：

```
# myproject/apps/core/model_fields.py
from django.conf import settings
from django.utils.translation import get_language
from django.utils import translation

class TranslatedField(object):
    def __init__(self, field_name):
        self.field_name = field_name

    def __get__(self, instance, owner):
        lang_code = translation.get_language()
        if lang_code == settings.LANGUAGE_CODE:
            # The fields of the default language are in the main
               model
            return getattr(instance, self.field_name)
        else:
            # The fields of the other languages are in the
               translation
            # model, but falls back to the main model
            translations = instance.translations.filter(
                language=lang_code,
            ).first() or instance
            return getattr(translations, self.field_name)
```

2.  将`admin.py`文件添加到`core`app，内容如下：

```
# myproject/apps/core/admin.py
from django import forms
from django.conf import settings
from django.utils.translation import gettext_lazy as _

class LanguageChoicesForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        LANGUAGES_EXCEPT_THE_DEFAULT = [
            (lang_code, lang_name)
            for lang_code, lang_name in settings.LANGUAGES
            if lang_code != settings.LANGUAGE_CODE
        ]
        super().__init__(*args, **kwargs)
        self.fields["language"] = forms.ChoiceField(
            label=_("Language"),
            choices=LANGUAGES_EXCEPT_THE_DEFAULT, 
            required=True,
        )
```

现在让我们实现多语言模型：

1.  首先，在项目的设置中设置多种语言。比如说，我们的网站将支持所有欧盟官方语言，默认语言为英语：

```
# myproject/settings/_base.py
LANGUAGE_CODE = "en"

# All official languages of European Union
LANGUAGES = [
    ("bg", "Bulgarian"),    ("hr", "Croatian"),
    ("cs", "Czech"),        ("da", "Danish"),
    ("nl", "Dutch"),        ("en", "English"),
    ("et", "Estonian"),     ("fi", "Finnish"),
    ("fr", "French"),       ("de", "German"),
    ("el", "Greek"),        ("hu", "Hungarian"),
    ("ga", "Irish"),        ("it", "Italian"),
    ("lv", "Latvian"),      ("lt", "Lithuanian"),
    ("mt", "Maltese"),      ("pl", "Polish"),
    ("pt", "Portuguese"),   ("ro", "Romanian"),
    ("sk", "Slovak"),       ("sl", "Slovene"),
    ("es", "Spanish"),      ("sv", "Swedish"),
]
```

2.  然后，让我们创建`Idea`和`IdeaTranslations`模型：

```
# myproject/apps/ideas/models.py
from django.db import models
from django.conf import settings
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.model_fields import TranslatedField

class Idea(models.Model):
    title = models.CharField(
        _("Title"),
        max_length=200,
    )
    content = models.TextField(
        _("Content"),
    )
    translated_title = TranslatedField("title")
    translated_content = TranslatedField("content")

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title

class IdeaTranslations(models.Model):
    idea = models.ForeignKey(
        Idea,
        verbose_name=_("Idea"),
        on_delete=models.CASCADE,
        related_name="translations",
    )
    language = models.CharField(_("Language"), max_length=7)

    title = models.CharField(
        _("Title"),
        max_length=200,
    )
    content = models.TextField(
        _("Content"),
    )

    class Meta:
        verbose_name = _("Idea Translations")
        verbose_name_plural = _("Idea Translations")
        ordering = ["language"]
        unique_together = [["idea", "language"]]

    def __str__(self):
        return self.title
```

3.  最后，为`ideas`应用程序创建`admin.py`，如下所示：

```
# myproject/apps/ideas/admin.py
from django.contrib import admin
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.admin import LanguageChoicesForm

from .models import Idea, IdeaTranslations

class IdeaTranslationsForm(LanguageChoicesForm):
    class Meta:
        model = IdeaTranslations
        fields = "__all__"

class IdeaTranslationsInline(admin.StackedInline):
    form = IdeaTranslationsForm
    model = IdeaTranslations
    extra = 0

@admin.register(Idea)
class IdeaAdmin(admin.ModelAdmin):
    inlines = [IdeaTranslationsInline]

    fieldsets = [
        (_("Title and Content"), {
            "fields": ["title", "content"]
        }),
    ]
```

# 它是如何工作的。。。

我们在`Idea`模型本身中保留默认语言的特定于语言的字段。每种语言的翻译都在`IdeaTranslations`模型中，将在管理中作为内联翻译列出。`IdeaTranslations`模型中没有语言选择是有原因的——我们不希望每次添加新语言或删除某些语言时都创建迁移。相反，在管理表单中设置语言选项，同时确保跳过默认语言或不可在列表中选择。使用`LanguageChoicesForm`类限制语言选择。

要获取当前语言中的特定字段，可以使用定义为`TranslatedField`的字段。在模板中，这将如下所示：

```
<h1>{{ idea.translated_title }}</h1>
<div>{{ idea.translated_content|urlize|linebreaks }}</div>
```

要按特定语言的翻译标题订购项目，您可以使用以下`annotate()`方法：

```
>>> from django.conf import settings
>>> from django.db import models
>>> lang_code = input("Enter language code: ")

>>> if lang_code == settings.LANGUAGE_CODE:
...     qs = Idea.objects.annotate(
...         title_translation=models.F("title"),
...         content_translation=models.F("content"),
...     )
... else:
...     qs = Idea.objects.filter(
...         translations__language=lang_code,
...     ).annotate(
...         title_translation=models.F("translations__title"),
...         content_translation=models.F("translations__content"),
...     )

>>> qs = qs.order_by("title_translation")

>>> for idea in qs:
...     print(idea.title_translation)
```

在本例中，我们在 Django shell 中提示输入语言代码。如果语言是默认语言，我们将`title`和`content`存储为`Idea`模型中的`title_translation`和`content_translation`。如果选择了另一种语言，我们使用所选语言将`IdeaTranslations`模型中的`title`和`content`解读为`title_translation`和`content_translation`。

之后，我们可以通过`title_translation`或`content_translation`对`QuerySet`进行过滤或排序。

# 另见

*   *处理多语言字段*配方
*   [第 6 章](06.html)*模型管理*

# 避免循环依赖

在开发 Django 模型时，避免循环依赖非常重要，尤其是在`models.py`文件中。循环依赖关系是在不同的 Python 模块中相互导入的。您不应该从不同的`models.py`文件交叉导入，因为这会导致严重的稳定性问题。相反，如果您具有相互依赖性，则应使用此配方中描述的操作。

# 准备

让我们使用`categories`和`ideas`应用程序来说明如何处理交叉依赖关系。

# 怎么做。。。

使用使用其他应用程序模型的模型时，请遵循以下做法：

1.  对于外键和与其他应用程序模型的多对多关系，请使用`"<app_label>.<model>"`声明，而不是导入模型。在 Django 中，它与`ForeignKey`、`OneToOneField`和`ManyToManyField`一起工作，例如：

```
# myproject/apps/ideas/models.py from django.db import models
from django.conf import settings
from django.utils.translation import gettext_lazy as _

class Idea(models.Model):
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        verbose_name=_("Author"),
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )
    category = models.ForeignKey(
        "categories.Category",
        verbose_name=_("Category"),
        blank=True,
        null=True,
        on_delete=models.SET_NULL,
    )
    # other fields, attributes, properties and methods…
```

这里，`settings.AUTH_USER_MODEL`是具有诸如`"auth.User"`的值的设置：

2.  如果需要从方法中的另一个应用程序访问模型，请在方法中导入该模型，而不是在模块级别导入，例如，如下所示：

```
# myproject/apps/categories/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _

class Category(models.Model):
    # fields, attributes, properties, and methods…

    def get_ideas_without_this_category(self):
        from myproject.apps.ideas.models import Idea
        return Idea.objects.exclude(category=self)
```

3.  如果使用模型继承，例如，对于模型混合，请将基类保留在单独的应用程序中，并将它们放在将在`INSTALLED_APPS`中使用它们的其他应用程序之前，如下所示：

```
# myproject/settings/_base.py

INSTALLED_APPS = [
    # contributed
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # third-party
    # ...
    # local
    "myproject.apps.core",
    "myproject.apps.categories",
    "myproject.apps.ideas",
]
```

此处`ideas`应用程序将使用`core`应用程序中的模型混合器，如下所示：

```
# myproject/apps/ideas/models.py
from django.db import models
from django.conf import settings
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.models import (
 CreationModificationDateBase,
 MetaTagsBase,
 UrlBase,
)

class Idea(CreationModificationDateBase, MetaTagsBase, UrlBase):
    # fields, attributes, properties, and methods…
```

# 另见

*   [第一章](01.html)*中的*为开发、测试、登台和生产环境配置设置*配方，Django 3.0*入门
*   *关于[第一章](01.html)**中 Python 文件*配方中的导入顺序，开始使用 Django 3.0**
*   *使用模型混合*配方
*   *将外键更改为多对多字段*配方

# 添加数据库约束

为了更好的数据库完整性，通常会定义数据库约束，告诉某些字段绑定到其他数据库表的字段，使某些字段唯一或不为空。对于高级数据库约束，例如使用条件使字段唯一或为某些字段的值设置特定条件，Django 有特殊的类：`UniqueConstraint`和`CheckConstraint`。在本食谱中，您将看到如何使用它们的一个实际示例。

# 准备

让我们从`ideas`应用程序和`Idea`模型开始，它们至少有`title`和`author`字段。

# 怎么做。。。

在`Idea`模型的`Meta`类中设置数据库约束，如下所示：

```
# myproject/apps/ideas/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _

class Idea(models.Model):
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        verbose_name=_("Author"),
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
        related_name="authored_ideas",
    )
    title = models.CharField(
        _("Title"),
        max_length=200,
    )

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")
        constraints = [
 models.UniqueConstraint(
 fields=["title"],
 condition=~models.Q(author=None),
 name="unique_titles_for_each_author",
 ),
 models.CheckConstraint(
 check=models.Q(
 title__iregex=r"^\S.*\S$"
 # starts with non-whitespace,
 # ends with non-whitespace,
 # anything in the middle
 ),
 name="title_has_no_leading_and_trailing_whitespaces",
 )
 ]
```

# 它是如何工作的。。。

我们在数据库中定义了两个约束。

第一个是`UniqueConstraint`，它告诉每个作者的标题都是独一无二的。如果未设置作者，则可以重复标题。为了检查作者是否已设置，我们使用否定查找：`~models.Q(author=None)`。请注意，在 Django 中，用于查找的`~`运算符等效于 QuerySet 的`exclude()`方法，因此这些 QuerySet 是等效的：

```
ideas_with_authors = Idea.objects.exclude(author=None)
ideas_with_authors2 = Idea.objects.filter(~models.Q(author=None))
```

第二个约束条件`CheckConstraint`检查标题是否以空白开头和结尾。为此，我们使用正则表达式查找。

# 还有更多。。。

数据库约束不会影响表单验证。在将条目保存到数据库时，如果有任何数据未通过其条件，他们只会引发`django.db.utils.IntegrityError`。

如果您想在表单上验证数据，您还必须自己进行验证，例如，在模型的`clean()`方法中。对于`Idea`型号，看起来是这样的：

```
# myproject/apps/ideas/models.py from django.db import models
from django.conf import settings
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _

class Idea(models.Model):
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        verbose_name=_("Author"),
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
        related_name="authored_ideas2",
    )
    title = models.CharField(
        _("Title"),
        max_length=200,
    )

    # other fields and attributes…

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")
        constraints = [
            models.UniqueConstraint(
                fields=["title"],
                condition=~models.Q(author=None),
                name="unique_titles_for_each_author2",
            ),
            models.CheckConstraint(
                check=models.Q(
                    title__iregex=r"^\S.*\S$"
                    # starts with non-whitespace,
                    # ends with non-whitespace,
                    # anything in the middle
                ),
                name="title_has_no_leading_and_trailing_whitespaces2",
            )
        ]

 def clean(self):
 import re
 if self.author and Idea.objects.exclude(pk=self.pk).filter(
 author=self.author,
 title=self.title,
 ).exists():
 raise ValidationError(
 _("Each idea of the same user should have a unique title.")
 )
 if not re.match(r"^\S.*\S$", self.title):
 raise ValidationError(
 _("The title cannot start or end with a whitespace.")
 )

    # other properties and methods…
```

# 另见

*   [第三章](03.html)*形式与视图*
*   [第 10 章](10.html)*中的*使用数据库查询表达式*配方*

# 使用迁移

在敏捷软件开发中，项目的需求在开发过程中不断发展和更新。随着开发的迭代进行，您必须在开发过程中执行数据库模式更改。使用 Django 迁移，您不必手动更改数据库表和字段，因为大部分操作都是使用命令行界面自动完成的。

# 准备

在命令行工具中激活虚拟环境，并将 active directory 更改为项目的目录。

# 怎么做。。。

要创建数据库迁移，请查看以下步骤：

1.  当您在新的`categories`或`ideas`应用程序中创建模型时，您必须创建一个初始迁移，该迁移将为您的应用程序创建数据库表。这可以通过使用以下命令来完成：

```
(env)$ python manage.py makemigrations ideas
```

2.  第一次要为项目创建所有表时，请运行以下命令：

```
(env)$ python manage.py migrate
```

要为所有应用执行新迁移时，请运行此命令。

3.  如果要执行特定应用程序的迁移，请运行以下命令：

```
(env)$ python manage.py migrate ideas
```

4.  如果在数据库模式中进行了一些更改，则必须为该模式创建迁移。例如，如果我们向 idea 模型添加一个新的字幕字段，我们可以使用以下命令创建迁移：

```
(env)$ python manage.py makemigrations --name=subtitle_added ideas
```

但是，`--name=subtitle_added`字段可以跳过，因为在大多数情况下，Django 会生成相当自解释的默认名称。

5.  有时，您可能必须批量添加或更改现有模式中的数据，这可以通过数据迁移而不是模式迁移来完成。要创建修改数据库表中数据的数据迁移，可以使用以下命令：

```
(env)$ python manage.py makemigrations --name=populate_subtitle \
> --empty ideas
```

`--empty`参数告诉 Django 创建一个骨架数据迁移，在应用它之前，您必须修改它以执行必要的数据操作。对于数据迁移，建议设置名称。

6.  要列出所有可用的已应用和未应用迁移，请运行以下命令：

```
(env)$ python manage.py showmigrations
```

应用的迁移将以[X]前缀列出。未应用的将以[]前缀列出。

7.  要列出特定应用程序的所有可用迁移，请运行相同的命令，但传递应用程序名称，如下所示：

```
(env)$ python manage.py showmigrations ideas
```

# 它是如何工作的。。。

Django 迁移是数据库迁移机制的指令文件。指令文件告诉我们要创建或删除哪些数据库表，要添加或删除哪些字段，以及要插入、更新或删除哪些数据。它们还定义了哪些迁移依赖于哪些其他迁移。

Django 中有两种类型的迁移。一个是模式迁移，另一个是数据迁移。应在添加新模型或添加或删除字段时创建架构迁移。当您希望用一些值填充数据库或从数据库中大量删除值时，应使用数据迁移。应使用命令行工具中的命令创建数据迁移，然后在迁移文件中进行编码。

每个应用程序的迁移都保存在它们的`migrations`目录中。第一次迁移通常被称为`0001_initial.py`，而我们示例应用程序中的其他迁移将被称为`0002_subtitle_added.py`和`0003_populate_subtitle.py`。每次迁移都会获得一个自动递增的数字前缀。对于执行的每个迁移，都有一个条目保存在`django_migrations`数据库表中。

通过指定要迁移到的迁移编号，可以来回迁移，如下命令所示：

```
(env)$ python manage.py migrate ideas 0002

```

要取消应用程序的所有迁移（包括初始迁移），请运行以下操作：

```
(env)$ python manage.py migrate ideas zero
```

取消网格化要求每次迁移同时具有向前和向后操作。理想情况下，后退操作将完全撤消前进操作所做的更改。但是，在某些情况下，这样的更改是不可恢复的，例如当转发操作从模式中删除了一列时，因为它会破坏数据。在这种情况下，向后操作可能会恢复模式，但数据将永远丢失，否则可能根本没有向后操作。

在测试了前向和后向迁移过程并且确信它们在其他开发和公共网站环境中工作良好之前，不要将迁移提交到版本控制。

# 还有更多。。。

在官方的*如何*指南中了解有关编写数据库迁移的更多信息，可在[找到 https://docs.djangoproject.com/en/2.2/howto/writing-migrations/](https://docs.djangoproject.com/en/2.2/howto/writing-migrations/) ​.

# 另见

*   [第一章](01.html)*中的*使用虚拟环境*配方，开始使用 Django 3.0*
*   *在[第 1 章](01.html)*中为 Django、Gunicorn、Nginx 和 PostgreSQL*配方使用 Docker 容器，开始使用 Django 3.0*
*   *在[第 1 章](01.html)*中使用 pip*处理项目依赖关系，开始使用 Django 3.0*
*   在[第 1 章](01.html)*中的*在您的项目*中包含外部依赖项，开始使用 Django 3.0*
*   *将外键更改为多对多字段*配方

# 将外键更改为多对多字段

这是一个如何将多对一关系更改为多对多关系的实际示例，同时保留现有数据。在这种情况下，我们将同时使用模式和数据迁移。

# 准备

假设您有`Idea`模型，外键指向`Category`模型。

1.  让我们在`categories`应用中定义`Category`模型，如下所示：

```
# myproject/apps/categories/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.model_fields import MultilingualCharField

class Category(models.Model):
    title = MultilingualCharField(
        _("Title"),
        max_length=200,
    )

    class Meta:
        verbose_name = _("Category")
        verbose_name_plural = _("Categories")

    def __str__(self):
        return self.title
```

2.  让我们在`ideas`应用中定义`Idea`模型，如下所示：

```
# myproject/apps/ideas/models.py from django.db import models
from django.conf import settings
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.model_fields import (
    MultilingualCharField,
    MultilingualTextField,
)

class Idea(models.Model):
    title = MultilingualCharField(
        _("Title"),
        max_length=200,
    )
    content = MultilingualTextField(
        _("Content"),
    )
 category = models.ForeignKey(
        "categories.Category",
        verbose_name=_("Category"),
        blank=True,
        null=True,
        on_delete=models.SET_NULL,
        related_name="category_ideas",
    ) 
    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title
```

3.  使用以下命令创建并执行初始迁移：

```
(env)$ python manage.py makemigrations categories
(env)$ python manage.py makemigrations ideas
(env)$ python manage.py migrate
```

# 怎么做。。。

以下步骤将演示如何从外键关系切换到多对多关系，同时保留现有数据：

1.  添加一个新的多对多字段，称为`categories`，如下所示：

```
# myproject/apps/ideas/models.py from django.db import models
from django.conf import settings
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.model_fields import (
    MultilingualCharField,
    MultilingualTextField,
)

class Idea(models.Model):
    title = MultilingualCharField(
        _("Title"),
        max_length=200,
    )
    content = MultilingualTextField(
        _("Content"),
    )
    category = models.ForeignKey(
        "categories.Category",
        verbose_name=_("Category"),
        blank=True,
        null=True,
        on_delete=models.SET_NULL,
        related_name="category_ideas",
    )
    categories = models.ManyToManyField(
 "categories.Category",
 verbose_name=_("Categories"),
 blank=True,
 related_name="ideas",
 )

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title
```

2.  创建并运行架构迁移，以便将新关系添加到数据库中，如以下代码段所示：

```
(env)$ python manage.py makemigrations ideas
(env)$ python manage.py migrate ideas
```

3.  创建数据迁移，将类别从外键复制到多对多字段，如下所示：

```
(env)$ python manage.py makemigrations --empty \
> --name=copy_categories ideas
```

4.  打开新创建的迁移文件（`0003_copy_categories.py`，定义正向迁移指令，如下代码段所示：

```
# myproject/apps/ideas/migrations/0003_copy_categories.py from django.db import migrations

def copy_categories(apps, schema_editor):
 Idea = apps.get_model("ideas", "Idea")
 for idea in Idea.objects.all():
 if idea.category:
 idea.categories.add(idea.category)

class Migration(migrations.Migration):

    dependencies = [
        ('ideas', '0002_idea_categories'),
    ]

    operations = [
        migrations.RunPython(copy_categories),
    ]
```

5.  运行新的数据迁移，如下所示：

```
(env)$ python manage.py migrate ideas
```

6.  删除`models.py`文件中的外键`category`字段，只留下新的`categories`多对多字段，如下所示：

```
# myproject/apps/ideas/models.py from django.db import models
from django.conf import settings
from django.utils.translation import gettext_lazy as _

from myproject.apps.core.model_fields import (
    MultilingualCharField,
    MultilingualTextField,
)

class Idea(models.Model):
    title = MultilingualCharField(
        _("Title"),
        max_length=200,
    )
    content = MultilingualTextField(
        _("Content"),
    )

    categories = models.ManyToManyField(
 "categories.Category",
 verbose_name=_("Categories"),
 blank=True,
 related_name="ideas",
 )

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title
```

7.  创建并运行模式迁移，以便从数据库表中删除`Categories`字段，如下所示：

```
(env)$ python manage.py makemigrations ideas
(env)$ python manage.py migrate ideas
```

# 它是如何工作的。。。

首先，我们在`Idea`模型中添加一个新的多对多字段，并生成相应的迁移来更新数据库。然后，我们创建一个数据迁移，将现有关系从外键`category`复制到新的多对多`categories`。最后，我们从模型中删除外键字段，并再次更新数据库。

# 还有更多。。。

我们的数据迁移目前只包括转发操作，复制外部
键类别作为新类别关系中的第一个相关项。虽然我们在这里没有详细说明，但在实际场景中，最好也包括反向操作。这可以通过将第一个相关项复制回`category`外键来实现。不幸的是，任何具有多个类别的`Idea`对象都会丢失额外的数据。

# 另见

*   *使用迁移*配方
*   *处理多语言字段*配方
*   *使用模型转换表*配方
*   *避免循环依赖*配方