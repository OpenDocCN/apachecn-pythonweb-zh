# 八、在我们的犯罪地图项目中验证用户输入

用户将始终以您不打算或预期的方式使用您的应用，无论是出于无知还是恶意。用户可以控制的每一点输入都应该进行验证，以确保它符合预期。

我们将完善我们的第二个项目，确保用户不会意外地或通过恶意创建的输入破坏它。

在本章中，我们将介绍以下主题：

*   选择验证的位置
*   尝试一个 XSS 示例
*   验证和消毒

# 选择验证地点

在验证用户输入和显示反馈以帮助他们纠正任何错误时，可以做出一些选择。主要的选择是在*中*进行验证：在浏览器中，在服务器上，或者两者兼而有之。

我们可以在用户的浏览器中用 JavaScript 来实现。这种方法的优点是，用户将获得更快的反馈（他们不必等待将数据发送到我们的服务器、验证数据并发送回响应），而且还减轻了服务器上的负载；如果我们不使用 CPU 周期和网络带宽来验证用户数据，这意味着运行服务器的成本更低。这种方法的缺点是我们不能保证用户不会绕过这些检查；如果检查在用户的浏览器中运行，则用户可以完全控制这些检查。这意味着通过客户端检查验证的数据仍然不能保证是我们期望的数据。

我们可以在用户提交数据后在服务器上完成。这种方法的优点和缺点与前面描述的相反。我们花费了更多的处理时间，但我们对支票的完整性有额外的保证。另一方面，用户通常需要等待更长的时间才能获得关于合法（非恶意）错误的反馈。

最后一个选择是两者兼而有之。这给了我们最好的世界；我们可以用 JavaScript 向用户提供快速反馈，但随后在服务器端重新检查结果，以确保没有任何内容通过客户端检查。另一方面，我们最终在 CPU 周期上浪费时间检查两次合法数据，我们还必须在开发上投入更多精力，因为我们必须用 JavaScript 和 Python 编写验证检查。

在这个项目中，由于我们将从头开始实施表单管理，我们只在服务器端执行一些非常基本的检查，而不在客户端执行检查。在我们的下一个项目中，当我们使用框架来处理用户输入时，我们将讨论如何轻松地使用一些更复杂的验证方法。

## 识别需要验证的输入

我们已经指出，并非所有浏览器都支持 HTML5`"date"`类型的输入。这意味着，在我们的网站上，一些用户可能会手动输入犯罪日期，这意味着我们需要能够处理用户以各种格式输入日期的问题。我们的数据库要求 yyyy-mm-dd（例如，2015 年 10 月 10 日为 2015-10-10），但我们的用户不一定会遵守此格式，即使我们告诉他们这样做。那么，**日期**字段就是我们想要验证的输入之一。

我们的**纬度**和**经度**字段也可以由用户编辑，因此用户可以在其中输入文本或其他无效坐标。我们可以为这些添加验证检查，但是，由于用户实际上不需要编辑这些值，我们将考虑如何使它们成为 T4。我们将添加一个验证检查，以确保用户没有将其留空。

**描述**是最明显的危险领域。用户可以在此自由输入文本，这意味着用户有机会向我们的应用中*注入*代码。这意味着用户可以在这里输入干扰我们预期运行的代码的 JavaScript 或 HTML 代码，而不是像我们预期的那样填写文本描述。这样做就是所谓的 XSS 或跨站点脚本攻击的一个例子，我们将研究一些用户可能使用的恶意输入。

我们最后输入的是**类别**。这似乎非常安全，因为用户必须从下拉列表中选择它。然而，重要的是，下拉列表仅仅是一种方便，实际上，具有一些非常基本知识的用户也可以在这里使用自由格式的文本。这是因为浏览器使用表单中的信息创建`POST`请求，并将其发送到我们的服务器。因为`POST`请求只是以某种方式构造并通过 HTTP 发送的文本；没有任何东西可以阻止我们的精通技术的用户在不使用 web 浏览器的情况下构建`POST`请求（他们可以使用 Python 或其他编程语言，甚至可以使用一些更专业但免费提供的软件，如 BURP Suite）。

正如我们所看到的，我们所有的输入都需要某种形式的验证。在我们仔细看看如何验证输入之前，让我们简要地看看恶意用户 AUT0TA.如果我们决定不执行验证，它可能会做什么。

# 尝试一个 XSS 示例

恶意用户最受欢迎的攻击之一是所谓的*持续*XSS 攻击。这意味着攻击者不仅成功地将代码注入到您的 web 应用中，而且该注入的代码还会保留一段较长的时间。通常，这是通过欺骗应用将恶意注入的代码存储在数据库中，然后在后续访问时在页面上运行代码来实现的。

### 注

在下面的示例中，我们将*中断*我们的应用，将特定的输入输入到表单中。之后，您需要登录 VPS 上的数据库，以手动清除这些使我们的应用处于中断状态的输入。

根据我们的应用目前的情况，攻击者可以像往常一样填写**类别**、**日期**、**纬度**和**经度**字段，并在**描述**字段中使用以下内容，从而执行持续 XSS 攻击：

```py
</script><script>alert(1);</script>
```

这可能看起来有点奇怪，但试一试。您应该看到以下内容：

![Trying out an XSS example](img/B04312_08_01.jpg)

单击弹出窗口上的**OK**后，您可能会注意到页面顶部有一段奇怪的 JavaScript 摘录（您的`longitude`值会有所不同，具体取决于您放置标记的位置）：

```py
", "longitude": 26.52799}]); } function placeCrimes(crimes) { for (i=0; i
```

让我们看看这里发生了什么。如果我们查看页面的完整源代码，就像浏览器解释的那样，事情会变得更有意义。右键点击页面，点击**查看页面来源**或同等内容。

我们的 JavaScript 代码的`initialize`函数中的`placecrimes()`调用现在可以看到如下内容：

```py
placeCrimes([{"latitude": -33.305645, "date": "2015-10-10", "category": "mugging", "description": "</script><script>alert(1);</script>", "longitude": 26.52799}]);
```

如果您的浏览器使用任何形式的代码高亮显示，将更容易看到发生了什么。我们页面开头附近的`<script>`标签现在被我们第一次犯罪的描述所关闭，因为我们的浏览器知道将`<script>`和`</script>`之间的任何内容解释为 JavaScript 代码。正如我们在`"description"`开头的`</script>`一样，浏览器关闭了 JavaScript 的这一部分。紧接着，`<script>`打开了一个新的 JavaScript 部分，这是我们描述的下一部分。接下来，我们有了`alert(1);`，它只是创建了一个弹出框，其中包含**1**，正如我们前面提到的。这个脚本部分再次关闭，我们的浏览器现在将页面的其余部分解释为一团乱。我们可以看到我们的 JSON（`"longitude": …` ）的其余部分，直到`for`循环的一半显示给用户，并且`i<crimes.length`中的“`<`”符号现在被浏览器解释为另一个开始标记，因此随后的 JavaScript 再次被隐藏。

要修复我们的应用，请使用以下命令（您应该在 VPS 上运行这些命令）清除数据库中的所有犯罪数据：

```py
mysql crimemap –p
<your database password>
delete from crimes;

```

您应该会看到一条关于`crimes`表中删除了多少犯罪记录的消息，类似于下面的屏幕截图：

![Trying out an XSS example](img/B04312_08_02.jpg)

## 持续性 XSS 的潜力

我们的 web 应用坏了，这似乎很糟糕。更糟糕的是，重新加载页面并不是一个解决方案。由于恶意描述存储在我们的数据库中，因此无论我们重新加载页面多少次，都会出现相同的问题。更糟糕的是，“`alert(1);`”示例就是这样一个示例，表明攻击者可以自由运行他或她想要的任何代码。通常，攻击者利用这一点诱使用户访问另一个（恶意）页面，利用用户信任原始页面这一事实，从而更有可能信任该页面上的内容。这种可能性实际上只受到攻击者想象力的限制。

# 验证和消毒

为了防止前面的发生，我们已经选择检查服务器端上的数据，并确保它符合我们的预期。不过，我们还有一些选择要做。

## 白名单和黑名单

我们需要创建一些规则来在可接受的输入和不可接受的输入之间进行选择，主要有两种方法。一种方法是将看起来恶意的*黑名单*输入。使用此方法，我们将创建一个可能被恶意使用的字符列表，如“`<`”和“`>`”，我们将拒绝包含这些字符的输入。替代方案是使用*白名单*方法。这与黑名单相反，因为我们可以选择一个我们*将*允许的字符列表，而不是选择我们不允许的字符。

这似乎是一个吹毛求疵的区别，但它仍然很重要。如果我们采用黑名单方法，我们更有可能被恶意用户智胜，他们只使用我们没有添加到禁止列表中的字符注入代码。

另一方面，使用白名单方法，我们更有可能挫败那些想要使用我们没有想到要添加到白名单中的字符的用户。

由于我们的应用只需要一个`"description"`输入即可成为自由文本，并且因为我们的应用是本地化的（在我们使用的示例中，该应用是针对南非格拉姆镇的，因此我们希望我们的用户只需要普通拉丁字符，而不需要中文字符），我们应该能够在不妨碍用户的情况下使用白名单。

## 验证与消毒

接下来，我们必须决定如何处理无效输入。我们是完全拒绝它并要求用户再试一次，还是仅仅去掉用户输入的无效部分并保留其余部分？删除或修改用户输入（例如，通过添加转义字符）被称为对输入进行*消毒*。这种方法的优点是，用户通常不注意它；如果他或她无意中在犯罪描述中包含了一个特殊的角色，而我们删除了它，那么不太可能让其他描述变得不可理解或一文不值。缺点是，如果用户最终依赖我们列入黑名单的太多字符，它可能会损坏信息，导致无法使用，甚至误解用户的意图。

## 实施验证

考虑到前面提到的所有，我们希望：

*   检查用户提交的类别，确保它在我们期望的类别列表中
*   检查用户提交的日期，确保我们能够正确地将其理解为日期
*   检查用户提交的纬度和经度，并确保它们可以作为浮点数进行解析
*   检查用户提交的说明，除去字母数字或预选基本标点符号列表中的部分字符以外的所有字符

虽然我们会默默地编辑`description`以删除非白名单字符，但我们希望拒绝整个提交，并让用户在其他字段不符合我们预期的情况下重新启动。因此，我们还希望添加一种在用户提交表单后向用户显示自定义错误消息的方法。让我们添加一些 Python 函数来帮助我们完成所有这些。我们还将重组我们的一些代码，使之符合*不要重复自己（干式）*原则。

## 正在验证类别

之前，当我们为`categories`创建下拉列表时，我们将想要的两个`categories`硬编码到模板中。这已经不理想了，因为这意味着如果我们想要添加或编辑`categories`，就必须编写更多的样板代码（例如 HTML 标记）。现在，我们还希望访问 Python 中的`categories`列表，以便验证用户没有偷偷使用不在我们列表中的类别，因此有必要对其进行重新构造，以便我们只定义一次`categories`列表。

我们将在 Python 代码中定义该列表，然后将其传递给模板以构建下拉列表，并在用户提交表单时使用相同的列表进行验证。在`crimemap.py`的顶部，连同我们的其他全局列表，添加以下内容：

```py
categories = ['mugging', 'break-in']
```

在`home()`函数的`return`语句中，将此列表作为命名参数传入。该行现在应类似于以下内容：

```py
return render_template("home.html", crimes=crimes, categories=categories)
```

在`home.html`中，将`<select>`块更改为使用 Jinja`for`循环，如下所示：

```py
<select name="category" id="category">
    {% for category in categories %}
        <option value="{{category}}">{{category}}</option>
    {% endfor %}
</select>
```

通过这些小的修改，我们有了一个更简单的方法来维护我们的`categories`列表。我们现在还可以使用新列表进行验证。由于类别由下拉列表提供，因此一般用户不会在此处输入无效值，因此我们不必太担心提供礼貌的反馈。在这种情况下，我们将忽略提交内容并再次返回主页。

在我们将类别数据加载到`submitcrime()`函数中的变量的正下方添加以下`if`语句：

```py
category = request.form.get("category")
if category not in categories:
    return home()
```

如果触发，这个`return`将在我们向数据库添加任何内容之前发生，并且我们的用户尝试的输入将被丢弃。

## 正在验证位置

由于我们的位置数据应该由用户在地图上放置的标记自动填充，因此我们希望将这些字段`readonly`设置为。这意味着我们的 JavaScript 仍然能够在使用标记时修改值，但字段将拒绝用户键盘的输入或修改。为此，只需在`home.html`模板中定义表单的地方添加`readonly`属性。更新后的`input`定义应如下所示：

```py
<label for="latitude">Latitude</label>
<input name="latitude" id="latitude" type="text" readonly>
<label for="longitude">Longitude</label>
<input name="longitude" id="longitude" type="text" readonly>
```

不过，与下拉列表一样，`readonly`属性仅在浏览器级别强制执行，很容易被忽略。因此，我们也希望添加服务器端检查。要做到这一点，我们将使用 Python 哲学“请求原谅比请求允许更好”，或者，换句话说，假设一切都会好起来，在一个`except`块中处理其他情况，而不是使用太多`if`语句。

如果我们可以将用户的位置数据解析为浮点数，那么几乎肯定是安全的，因为只使用数字修改 HTML、JavaScript 或 SQL 代码是非常困难的。在解析位置输入的`submitcrime()`函数部分添加以下代码：

```py
try:
    latitude = float(request.form.get("latitude"))
    longitude = float(request.form.get("longitude"))
except ValueError:
    return home()
```

如果在`latitude`或`longitude`输入中有任何意外的文本，当我们尝试转换为 float 类型时，将抛出`ValueError`，再次，我们将返回主页，然后将任何潜在危险的数据放入数据库。

## 验证日期

对于`date`输入，我们可以采用与`category`相同的方法。大多数情况下，用户将从日历选择器中选择日期，因此无法输入无效日期。但是，由于并非所有浏览器都支持`date`输入类型，有时普通用户会手动输入日期，这可能会导致意外错误。

因此，在这种情况下，我们不仅要拒绝无效输入。我们希望尽可能地了解用户的意图，如果不能，我们希望向用户显示一条消息，指示需要修复的内容。

为了允许更灵活的输入，我们将使用一个名为`dateparser`的 Python 模块。这个模块允许我们获取格式不一致的日期，并将它们转换为精确的 Python`datetime`对象。我们需要做的第一件事就是通过`pip`安装它。在 VPS 上本地运行以下命令*和*：

```py
pip install --user dateparser
```

如果您以前没有使用过它，您可能会想尝试一下各种可能性。以下独立脚本演示了`dateparser`提供的一些魔力：

```py
import dateparser
print dateparser.parse("1-jan/15")
print dateparser.parse("1 week and 3 days ago")
print(dateparser.parse("3/4/15")
```

前面的所有字符串都正确解析为`datetime`对象，但最后一个除外，因为`dateparser`使用美国格式，并将其解释为 2015 年 3 月 4 日，而不是 2015 年 4 月 3 日。

更多的例子如以及`dateparser`模块的其他信息可以在[的 PyPI 上找到 https://pypi.python.org/pypi/dateparser](https://pypi.python.org/pypi/dateparser) 。

仅仅使用这个包就可以解决我们的很多问题，因为我们现在可以将无效输入转换为有效输入，而无需用户的任何帮助。稍有不便的是，我们已经设置了数据库，接受以“*yyyy mm dd*格式插入的字符串形式的日期；然而，为了利用我们新的`dateparser`模块，我们需要将用户的输入转换为`datetime`对象。稍微违反直觉的解决方法是将从用户接收到的字符串输入转换为`datetime`对象，然后再转换回字符串（始终采用正确的格式），然后将其传递到数据库代码中存储在 MySQL 中。

首先，将以下帮助函数添加到您的`crimemap.py`文件中：

```py
def format_date(userdate):
    date = dateparser.parse(userdate)
    try:
        return datetime.datetime.strftime(date, "%Y-%m-%d")
    except TypeError:
        return None    
```

另外，将`datetime`和`dateparser`模块的导入添加到`crimemap.py`的顶部，如下所示：

```py
import datetime
import dateparser
```

我们将把用户（`userdate`输入的`date`传递到此函数中，并使用`dateparser`模块对其进行解析。如果日期完全不可解析（例如，“`aaaaa`”），`dateparser.parse`函数将不返回任何内容，而不会抛出错误。因此，我们将把对`strftime`的调用放入`try except`块中，该调用将日期格式化为正确格式的字符串；如果我们的`date`变量为空，我们将得到一个`TypeError`，在这种情况下，我们的 helper 函数也将返回`None`。

现在，我们需要决定在无法解析日期的情况下该怎么做。与我们研究的其他验证案例不同，在本例中，我们希望向用户提示一条消息，说明我们无法理解他或她的输入。为此，我们将向`home()`函数添加一个错误消息参数，并从`submitcrime()`函数传入一条相关的错误消息。修改`home()`函数，添加参数并将参数传递到我们的模板中，如下所示：

```py
@app.route("/")
def home(error_message=None):
    crimes = DB.get_all_crimes()
    crimes = json.dumps(crimes)
 return render_template("home.html", crimes=crimes, categories=categories, error_message=error_message)

```

然后，修改`submitcrime()`函数，为解析用户输入的日期添加一些逻辑，如果解析`date`失败，则向`home()`函数传递错误消息，如下所示：

```py
if category not in categories:
    return home()
date = format_date(request.form.get("date"))
if not date:
 return home("Invalid date. Please use yyyy-mm-dd format")

```

我们还需要在模板文件中添加一个部分，以显示错误消息（如果存在）。我们将通过以下代码将其添加到表单顶部，以引起用户的注意：

```py
<div id="newcrimeform">
    <h2>Submit new crime</h2>
 {% if error_message %}
 <div id="error"><p>{{error_message}}</p></div>
 {% endif %}
    <form action="/submitcrime" method="POST">
```

我们将添加前面的`if`语句，否则当`error_message`变量的默认值为`None`时，我们将在表单上方看到单词“`None`”。另外，请注意，消息本身出现在带有错误 ID 的`<div>`标记中。这允许我们在中添加一些 CSS，使错误消息以红色显示。将以下块添加到静态目录中的`style.css`文件中：

```py
#error {
    color: red;
}
```

这就是确认我们约会的原因。如果您的浏览器不支持`date`输入，请尝试创建一个新的犯罪记录，并输入一个连`dateparser`都无法解释为合法日期的字符串，以确保看到预期的错误。其外观应类似于下图：

![Validating the date](img/B04312_08_03.jpg)

### 注

Flask 为信息*闪烁*提供了一些非常漂亮的功能，即在页面的特定位置向用户显示可选文本。与我们讨论的基本示例相比，它具有一些更强大、更灵活的功能，并且在类似的情况下应该考虑。烧瓶内闪烁信息可在[找到http://flask.pocoo.org/docs/0.10/patterns/flashing/](http://flask.pocoo.org/docs/0.10/patterns/flashing/) 。

## 验证描述

我们可以假设用户将能够仅使用数字、字母（大写和小写）和一些基本标点符号来传达有关犯罪的基本信息，因此，让我们创建一个简单的 Python 函数，从字符串中过滤掉所有字符，但我们已确定为安全的字符除外。将以下`sanitize()`函数添加到您的`crimemap.py`文件中：

```py
def sanitize_string(userinput):
    whitelist = string.letters + string.digits + " !?$.,;:-'()&"
    return filter(lambda x: x in whitelist, userinput)
```

然后，将字符串导入添加到`crimemap.py`的导入部分，如下所示：

```py
import string
```

我们的`sanitize_string()`函数非常简洁，并且使用了 Python 的一些函数编程潜力。`filter`函数对列表中的每个元素重复应用另一个函数，并基于“通过”的元素构建一个新的列表。在这种情况下，我们将传递到`filter()`的函数是一个简单的`lambda`函数，用于检查字母是否属于我们的`whitelist`。函数的结果是一个类似于输入字符串的字符串，但删除了所有不属于白名单的字符。

我们的白名单是由所有字母（大写和小写）、数字 1 到 9 以及人们在键入非正式事件描述时可能使用的一些基本标点符号组成的。

要使用我们的新函数，只需将`crimemap.py`中`submitcrime()`函数末尾附近的行从以下内容更改为后续内容：

```py
description = request.form.get("description")
description = sanitize_string(request.form.get("description"))
```

请注意，由于我们的 SQL 驱动程序减轻了 SQL 注入的影响，并且我们的`json.dumps()`函数逃逸了双引号，因此我们应该只通过将尖括号等字符列入黑名单（我们用来演示 XSS 攻击）来在很大程度上是安全的。这将为我们的用户提供更大的灵活性，但恶意用户可以确定并创造性地设计输入，从而绕过我们设置的过滤器。参见[https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet) 对于一些示例。先在本地进行验证更改，然后，如果通过提交`git`一切正常，则将回购推到远程，并将其拉到 VPS 上。重新启动 Apache 并访问您的 IP 地址。尝试使用`description`中的`</script>`提交犯罪记录，当您将光标悬停在该犯罪记录的标记上时，您会注意到，我们存储的只是“【T4]”。我们将去掉斜线和尖括号，从而确保防止 XSS。

我们已经讨论了黑名单和白名单的利弊，但是，为了强调白名单并不是一个完美的方法，请看这里关于开发人员在将用户名输入白名单时经常犯错误的帖子：[http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/](http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/)

我们可以对`dbhelper.py`、`mockdbhelper.py`和`crimemap.py`文件进行的最后一项更改是删除我们不再需要的功能。当我们有一个不特定于犯罪的基本数据库应用时，我们在`DBHelper`类中有`get_all_inputs()`、`add_input()`和`clear_all()`函数，在`crimemap.py`文件中有`add()`和`clear()`函数。所有这些都可以删除。

# 总结

我们花了整整一章的时间来研究验证，但如果你看看过去几年中面临信息安全漏洞的主要公司，你会同意安全性值得花一些时间。我们专门研究了跨站点脚本或 XSS 攻击，但也讨论了输入验证的一些更一般的要点。这将把我们带到第二个项目的末尾。

有一件明显缺失的事情是找出谁增加了哪些罪行。如果一个恶意用户向我们的数据库中添加一堆伪造的犯罪行为，他们可能会破坏我们的整个数据集！

在我们的下一个项目中，我们将研究通过用户帐户控制系统对用户进行身份验证，这将使我们能够更好地控制我们让谁进入我们的网站以及他们可以做什么。