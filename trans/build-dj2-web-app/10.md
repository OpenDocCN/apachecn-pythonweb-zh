# 开始邮件猿

在本章中，我们将开始构建邮件 Ape，这是一个邮件列表管理器，允许用户启动邮件列表，注册邮件列表，然后向用户发送消息。订阅者必须确认他们对邮件列表的订阅，并且能够取消订阅。这将帮助我们确保邮件 Ape 不会被用于向用户发送垃圾邮件。

在本章中，我们将构建 Mail Ape 的核心 Django 功能：

*   我们将构建描述邮件猿的模型，包括`MailingList`和`Subscriber`
*   我们将使用 Django 的基于类的视图来创建网页
*   我们将使用 Django 的内置身份验证功能让用户登录
*   我们将确保只有`MailingList`模型实例的所有者才能向其订户发送电子邮件
*   我们将创建模板来生成 HTML，以显示要订阅的表单并通过电子邮件发送给用户
*   我们将使用 Django 的内置开发服务器在本地运行 Mail Ape

本项目的代码可在[在线获取 https://github.com/tomaratyn/MailApe](https://github.com/tomaratyn/MailApe) 。

Django 遵循**模型视图模板**（**MVT**模式）来分离模型、控制和表示逻辑，并鼓励重用。模型表示我们将存储在数据库中的数据。视图负责处理请求并返回响应。视图不应包含 HTML。模板负责响应的主体并定义 HTML。这种职责分离已被证明可以使编写代码变得容易。

让我们从创建 Mail Ape 项目开始。

# 创建邮件 Ape 项目

在本节中，我们将创建 MailApe 项目：

```
$ mkdir mailape
$ cd mailape
```

本书此部分中的所有路径都将与此目录相关。

# 列出我们的 Python 依赖项

接下来，让我们创建一个`requirements.txt`文件来跟踪 Python 依赖关系：

```
django<2.1
psycopg2<2.8
django-markdownify==0.3.0
django-crispy-forms==1.7.0
```

现在我们了解了我们的需求，可以按如下方式安装它们：

```
$ pip install -r requirements.txt
```

这将安装以下四个库：

*   `Django`：我们最喜欢的 web 应用程序框架
*   `psycopg2`：Python PostgreSQL 库；我们将在生产和开发中使用 PostgreSQL
*   `django-markdownify`：在 Django 模板中轻松呈现标记的库
*   `django-crsipy-forms`：一个库，可以轻松地在模板中创建 Django 表单

安装了 Django 之后，我们可以使用`django-admin`实用程序来创建我们的项目。

# 创建我们的 Django 项目和应用程序

Django 项目由一个配置目录和一个或多个 Django 应用程序组成。项目的实际功能由已安装的应用程序封装。默认情况下，配置目录以项目命名。

web 应用程序通常不仅仅由执行的 Django 代码组成。我们需要配置文件、系统依赖项和文档。为了帮助未来的开发人员（包括我们未来的自己），我们将努力清晰地标记每个目录：

```
$ django-admin startporject config
$ mv config django
$ tree django
django
├── config
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
```

通过这种方法，我们的目录结构可以清楚地知道 Django 代码和配置的位置。

接下来，让我们创建将封装我们的功能的应用程序：

```
$ python manage.py startapp mailinglist
$ python manage.py startapp user
```

对于每个应用程序，我们都应该创建一个 URLConf。URLConf 确保将请求路由到正确的视图。URLConf 是路径列表、为路径提供服务的视图以及路径的名称。URLConfs 的一个优点是它们可以相互包含。当 Django 项目被创建时，它会得到一个根 URLConf（我们的 URLConf 位于`django/config/urls.py`。由于 URLConf 可能包括其他 URLConf，因此该名称提供了一种重要的方式，可以在不知道视图的完整 URL 路径的情况下引用视图的 URL 路径。

# 创建我们应用程序的 URLConf

让我们为`django/mailinglist/urls.py`中的`mailinglist`应用程序创建一个 URLConf：

```
from django.urls import path

from mailinglist import views

app_name = 'mailinglist'

urlpatterns = [
]
```

`app_name`变量用于在名称冲突的情况下确定路径的范围。解析路径名时，我们可以在其前面加上`mailinglist:`前缀，以确保它来自此应用程序。在构建视图时，我们会将`path`添加到`urlpatterns`列表中。

接下来，我们通过创建`django/user/urls.py`在`user`应用程序中创建另一个 URLConf：

```
from django.contrib.auth.views import LoginView, LogoutView
from django.urls import path

import user.views

app_name = 'user'
urlpatterns = [
]
```

伟大的现在，让我们将它们包含在位于`django/config/urls.py`的根 ULRConf 中：

```
from django.contrib import admin
from django.urls import path, include

import mailinglist.urls
import user.urls

urlpatterns = [
    path('admin/', admin.site.urls),
    path('user/', include(user.urls, namespace='user')),
    path('mailinglist/', include(mailinglist.urls, namespace='mailinglist')),
]
```

根 URLConf 就像我们应用程序的 URLConf 一样。它有一个`path()`对象列表。根 URLConf 中的`path()`对象通常没有视图，但有`include()`其他 URLConf。让我们来看看这里的两个新功能：

*   `path()`：这需要一个字符串和一个视图或`include()`的结果。Django 将在 URLConf 中的`path()`上迭代，直到找到一个与请求路径匹配的。Django 然后将请求传递给该视图或 URLConf。如果它是一个 URLConf，那么将检查`path()`的列表。
*   `include()`：这需要一个 URLConf 和一个名称空间名称。名称空间将 URLConf 彼此隔离，这样我们就可以防止名称冲突，确保我们能够区分`appA:index`和`appB:index`。`include()`返回一个元组；`admin.site.urls`处的对象已经是格式正确的元组，因此我们不必使用`include()`。通常，我们总是使用`include()`。

如果 Django 找不到与请求路径匹配的`path()`对象，那么它将返回 404 响应。

此 URLConf 的结果如下：

*   任何以`admin/`开头的请求都将路由到管理员应用程序的 URLConf
*   任何以`mailinglist/`开头的请求都将被路由到`mailinglist`应用程序的 URLConf
*   任何以`user/`开头的请求都将被路由到`user`应用程序的 URLConf

# 安装我们项目的应用程序

让我们更新`django/config/settings.py`来安装我们的应用程序。我们将更改`INSTALLED_APPS`设置，如下代码段所示：

```
INSTALLED_APPS = [
    'user',
    'mailinglist',

    'crispy_forms',
    'markdownify',

    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

现在我们已经配置了项目和应用程序，让我们为`mailinglist`应用程序创建模型。

# 创建邮件列表模型

在本节中，我们将为`mailinglist`应用程序创建模型。Django 提供了一个丰富而强大的 ORM，让我们不用直接处理数据库就可以用 Python 定义模型。ORM 将 Django 类、字段和对象转换为关系数据库概念：

*   模型类映射到关系数据库表
*   字段映射到关系数据库列
*   模型实例映射到关系数据库行

每个型号的`objects`属性中都有一个默认的管理器。管理器为在模型上运行查询提供了起点。管理者最重要的方法之一是`create()`。我们可以使用`create()`在数据库中创建模型的实例。经理也是为我们的模型获得`QuerySet`的起点。

`QuerySet`表示模型的数据库查询。`QuerySet`是惰性的，只有在迭代或转换为`bool`时才会执行。`QuerySet`API 提供了 SQL 的大部分功能，而不受特定数据库的限制。两种特别有用的方法是`QuerySet.filter()`和`QuerySet.exclude()`。`QuerySet.filter()`让我们将`QuerySet`的结果过滤为仅与提供的标准匹配的结果。`QuerySet.exclude()`让我们排除不符合标准的结果。

让我们从第一个模型开始，`MailingList`。

# 创建邮件列表模型

我们的`MailingList`模型将代表一个用户创建的邮件列表。这将是我们系统的一个重要模型，因为许多其他模型都会引用它。我们还可以预计，为了将订阅者与`MailingList`联系起来，必须公开披露`id`的`MailingList`。为了避免让用户枚举 Mail Ape 中的所有邮件列表，我们希望确保我们的`MailingList`ID 不连续。

让我们将我们的`MailingList`模型添加到`django/mailinglist/models.py`：

```
import uuid

from django.conf import settings
from django.db import models
from django.urls import reverse

class MailingList(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=140)
    owner = models.ForeignKey(to=settings.AUTH_USER_MODEL,
                              on_delete=models.CASCADE)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse(
            'mailinglist:manage_mailinglist',
            kwargs={'pk': self.id}
        )

    def user_can_use_mailing_list(self, user):
        return user == self.owner
```

让我们仔细看看我们的 To0t0 模型：

*   `class MailingList(models.Model):`：所有 Django 模型都必须继承`Model`类。
*   `id = models.UUIDField`：这是我们第一次为模型指定`id`字段。通常，我们让 Django 自动为我们提供一个。在本例中，我们需要非序列 ID，因此我们使用了一个提供**通用唯一标识符**（**UUID**的字段）。Django 将在生成迁移时创建适当的数据库字段（请参阅*创建数据库迁移*部分）。但是，我们必须在 Python 中生成 UUID。为了为每个新模型生成新的 UUID，我们使用了`default`参数和 Python 的`uuid4`函数。为了告诉 Django 我们的`id`字段是主键，我们使用了`primary_key`参数。我们进一步通过了`editable=False`来防止`id`属性的更改。
*   `name = models.CharField`：这将代表邮件列表的名称。`CharField`将转换为`VARCHAR`列，因此我们必须为其提供一个`max_length`参数。
*   `owner = models.ForeignKey`：这是 Django 用户模型的外键。在本例中，我们将使用默认的`django.contrib.auth.models.User`类。我们遵循 Django 避免硬编码此模型的最佳实践。通过引用`settings.AUTH_USER_MODEL`，我们不会将我们的应用程序与项目紧密结合。这鼓励了将来的重用。`on_delete=models.CASCADE`参数意味着如果用户被删除，其所有`MailingList`模型实例也将被删除。
*   `def __str__(self)`：定义如何将邮件列表转换为`str`。Django 和 Python 都将在需要打印或显示`MailingList`时使用此选项。
*   `def get_absolute_url(self)`：这是 Django 模型的常用方法。`get_absolute_url()`返回表示模型的 URL 路径。在本例中，我们返回此邮件列表的管理页面。我们不会硬编码路径。相反，我们使用`reverse()`在运行时通过提供 URL 的名称来解析路径。我们将在*创建 URLConf*部分中查看命名 URL。
*   `def user_can_use_mailing_list(self, user)`：这是我们为了方便自己而添加的一种方法。它检查用户是否可以使用（即查看相关项目和/或发送消息）此邮件列表。Django 的*Fat 模型*理念鼓励将类似决策的代码放在模型中，而不是视图中。这为我们的决策提供了一个中心位置，确保您**不会重复自己**（**DRY**。

我们现在有了`MailingList`型号。接下来，让我们创建一个模型来捕获邮件列表的订户。

# 创建订户模型

在本节中，我们将创建一个`Subscriber`模型。一个`Subscriber`型号只能属于一个`MailingList`并且必须确认其订购。因为我们需要为订户的确认和取消订阅页面引用订户，所以我们希望他们的`id`实例也是非连续的。

让我们在`django/mailinglist/models.py`中创建`Subscriber`模型：

```
class Subscriber(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    email = models.EmailField()
    confirmed = models.BooleanField(default=False)
    mailing_list = models.ForeignKey(to=MailingList, on_delete=models.CASCADE)

    class Meta:
        unique_together = ['email', 'mailing_list', ]
```

`Subscriber`模型与`MailingList`模型有一些相似之处。基类和`UUIDField`的功能相同。让我们来看看其中的一些差异：

*   `models.EmailField()`：这是一个专门的`CharField`，但会进行额外的验证，以确保该值是一个有效的电子邮件地址。
*   `models.BooleanField(default=False)`：这允许我们存储`True`/`False`值。我们需要使用它来跟踪用户是否真的打算订阅邮件列表。
*   `models.ForeignKey(to=MailingList...)`：这允许我们在`Subscriber`和`MailingList`模型实例之间创建一个外键。
*   `unique_together`：这是`Subscriber`的`Meta`内部类的属性。`Meta`内部类允许我们指定表上的信息。例如，`unique_together`允许我们在表上添加额外的唯一约束。在这种情况下，我们禁止用户使用同一封电子邮件注册两次。

现在我们可以跟踪`Subscriber`模型实例，让我们跟踪用户希望发送给`MailingList`的消息。

# 创建消息模型

我们的用户将希望向其`MailingList`的`Subscriber`模型实例发送消息。为了知道向这些订阅者发送什么，我们需要将消息存储为 Django 模型。

A`Message`应属于 A`MailingList`且具有非序列`id`。我们需要保存这些消息的主题和正文。我们还希望跟踪发送何时开始和完成。

让我们将`Message`模型添加到`django/mailinglist/models.py`：

```
class Message(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    mailing_list = models.ForeignKey(to=MailingList, on_delete=models.CASCADE)
    subject = models.CharField(max_length=140)
    body = models.TextField()
    started = models.DateTimeField(default=None, null=True)
    finished = models.DateTimeField(default=None, null=True)
```

同样，`Message`模型在基类和字段方面与前面的模型非常相似。我们确实在这个模型中看到了一些新字段。让我们仔细看看这些新领域：

*   `models.TextField()`：用于存储任意长字符数据。所有主要数据库都有一个`TEXT`列类型。这对于存储用户的`Message`的`body`属性很有用。
*   `models.DateTimeField(default=None, null=True)`：用于存储日期和时间值。在博士后，这成为一个`TIMESTAMP`栏。`null`参数告诉 Django 此列应该能够接受`NULL`值。默认情况下，所有字段都有`NOT NULL`约束。

我们现在有了我们的模型。让我们通过数据库迁移在数据库中创建它们。

# 使用数据库迁移

数据库迁移描述如何将数据库迁移到特定状态。在本节中，我们将执行以下操作：

*   为我们的`mailinglist`应用程序模型创建数据库迁移
*   在 Postgres 数据库上运行迁移

当我们对模型进行更改时，我们可以让 Django 生成用于创建这些表、字段和约束的代码。Django 生成的迁移是使用 Django 开发人员也可以使用的 API 创建的。如果我们需要进行复杂的迁移，我们可以自己编写迁移。请记住，正确的迁移包括应用和恢复迁移的代码。如果出现问题，我们希望找到一种方法来撤消迁移。当 Django 生成迁移时，它总是为我们生成两个迁移。

让我们从配置 Django 连接到 PostgreSQL 数据库开始。

# 配置数据库

要配置 Django 连接到我们的 Postgres 数据库，我们需要更新`django/config/settings.py`中的`DATABASES`设置：

```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mailape',
        'USER': 'mailape',
        'PASSWORD': 'development',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```

您不应将密码硬编码到`settings.py`文件中的生产数据库。如果您连接到共享或在线实例，请使用环境变量设置用户名、密码和主机，并使用`os.getenv()`访问它们，就像我们在前面的生产部署章节（[第 5 章](05.html)、*使用 Docker*部署，[第 9 章](09.html)、*中所做的那样应答部署*。

Django 无法单独创建数据库和用户。我们必须自己去做。您可以在本章的代码中找到执行此操作的脚本。

接下来，让我们为模型创建迁移。

# 创建数据库迁移

为了创建数据库迁移，我们将使用 Django 放在 Django 项目顶部的`manage.py`脚本（`django/manage.py`：

```
$ cd django
$ python manage.py makemigrations
Migrations for 'mailinglist':
  mailinglist/migrations/0001_initial.py
    - Create model MailingList
    - Create model Message
    - Create model Subscriber
    - Alter unique_together for subscriber (1 constraint(s))
```

伟大的现在我们有了迁移，可以在本地开发数据库上运行它们了。

# 运行数据库迁移

我们使用`manage.py`将数据库迁移应用于正在运行的数据库。在命令行上，执行以下操作：

```
$ cd django
$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, mailinglist, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying mailinglist.0001_initial... OK
  Applying sessions.0001_initial... OK
```

当我们在不提供应用程序的情况下运行`manage.py migrate`时，它将在所有已安装的 Django 应用程序上运行所有迁移。我们的数据库现在有`mailinglist`应用程序模型和`auth`应用程序模型（包括`User`模型）的表。

现在我们已经建立了模型和数据库，让我们确保可以使用 Django 的 forms API 验证用户对这些模型的输入。

# 邮寄名单表格

开发人员必须解决的一个常见问题是如何验证用户输入。Django 通过其 forms API 提供输入验证。forms API 可以使用与 models API 非常相似的 API 来描述 HTML 表单。如果我们想要创建一个描述 Django 模型的表单，那么 Django 表单的`ModelForm`为我们提供了一个快捷方式。我们只需要描述从模型的默认表单表示更改了什么。

实例化 Django 表单时，可以为其提供以下三个参数中的任意一个：

*   `data`：终端用户请求的原始输入
*   `initial`：我们可以为表单设置的已知安全初始值
*   `instance`：表单描述的实例，仅在`ModelForm`上

如果提供了表格`data`，则称为绑定表格。绑定表单可以通过调用`is_valid()`来验证其`data`。已验证表单的安全使用数据可在`cleaned_data`字典中找到（键入字段名称）。错误可通过返回字典的`errors`属性获得。绑定的`ModelForm`还可以使用`save()`方法创建或更新其模型实例。

即使没有提供任何参数，表单仍然能够将自身打印为 HTML，这使得我们的模板更加简单。这个机制帮助我们实现了*哑模板*的目标。

让我们从创建`SubscriberForm`类开始创建表单。

# 创建订阅服务器窗体

Mail Ape 必须执行的一项重要任务是为`MailingList`接收新`Subscriber`的电子邮件。让我们创建一个表单来为我们进行验证。

`SubscriberForm`必须能够将输入验证为有效电子邮件。我们还希望它保存新的`Subscriber`模型实例，并将其与适当的`MailingList`模型实例相关联。

让我们在`django/mailinglist/forms.py`中创建该表单：

```
from django import forms

from mailinglist.models import MailingList, Subscriber

class SubscriberForm(forms.ModelForm):
    mailing_list = forms.ModelChoiceField(
        widget=forms.HiddenInput,
        queryset=MailingList.objects.all(),
        disabled=True,
    )

    class Meta:
        model = Subscriber
        fields = ['mailing_list', 'email', ]
```

让我们仔细看看我们的观点：

*   `class SubscriberForm(forms.ModelForm):`：这表明我们的形式来源于`ModelForm`。`ModelForm`知道检查我们的内部`Meta`类，以了解可以用作此表单基础的模型和字段的信息。
*   `mailing_list = forms.ModelChoiceField`：这告诉表单使用自定义配置的`ModelChoiceField`，而不是表单 API 将使用的默认值。默认情况下，Django 将显示一个`ModelChoiceField`，该`ModelChoiceField`将作为下拉框呈现。用户可以使用下拉列表选择关联的模型。在我们的例子中，我们不希望用户能够做出这样的选择。当我们显示呈现的`SubscriberForm`时，我们希望将其配置为特定的邮件列表。为此，我们将`widget`参数更改为`HiddenInput`类，并将字段标记为`disabled`。我们的表单需要知道对该表单有效的`MailingList`模型实例。我们提供了一个匹配所有`MailingList`模型实例的`QuerySet`对象。
*   `model = Subscriber`：告知表单的`Meta`内部类该表单基于`Subscriber`模型。
*   `fields = ['mailing_list', 'email', ]`：这告诉表单在表单中只包含来自模型的以下字段。

接下来，让我们制作一个表单来捕获我们的用户想要发送到他们的`MailingList`的`Message`。

# 创建消息表单

我们的用户希望将`Message`发送到他们的`MailingList`上。我们将提供一个带有表单的网页，用户可以在其中创建这些消息。在创建页面之前，让我们先创建表单。

让我们将我们的`MessageForm`类添加到`django/mailinglist/forms.py`：

```
from django import forms

from mailinglist.models import MailingList, Message

class MessageForm(forms.ModelForm):
    mailing_list = forms.ModelChoiceField(
        widget=forms.HiddenInput,
        queryset=MailingList.objects.all(),
        disabled=True,
    )

    class Meta:
        model = Message
        fields = ['mailing_list', 'subject', 'body', ]
```

正如您在前面的代码中所注意到的，`MessageForm`的工作原理与`SubscriberFrom`类似。唯一的区别是我们在`Meta`内部类中列出了不同的模型和不同的字段。

接下来，让我们创建`MailingListForm`类，我们将使用该类接受邮件列表名称的输入。

# 创建邮件列表表单

现在，我们将创建一个`MailingListForm`，它将接受邮件列表的名称和所有者。我们将使用与之前相同的`HiddenInput`和`disabled`场模式，但这次是在`owner`场上。我们希望确保用户不能更改邮件列表的所有者。

让我们将我们的表格添加到`django/mailinglist/forms.py`：

```
from django import forms
from django.contrib.auth import get_user_model

from mailinglist.models import MailingList

class MailingListForm(forms.ModelForm):
    owner = forms.ModelChoiceField(
        widget=forms.HiddenInput,
        queryset=get_user_model().objects.all(),
        disabled=True,
    )

    class Meta:
        model = MailingList
        fields = ['owner', 'name']
```

`MailingListForm`与我们以前的表单非常相似，但引入了一个新函数`get_user_model()`。我们需要使用`get_user_model()`，因为我们不想将自己与特定的用户模型耦合，但我们需要访问该模型的管理器以获得`QuerySet`。

现在我们有了表单，可以为`mailinglist`Django 应用程序创建视图了。

# 创建邮件列表视图和模板

在上一节中，我们创建了可用于收集和验证用户输入的表单。在本节中，我们将创建实际与用户通信的视图和模板。模板定义文档的 HTML。

从根本上说，Django 视图是一个接受请求并返回响应的函数。虽然在本书中我们不会使用这些基于**函数的视图**（**FBV**），但重要的是要记住，视图需要做的就是满足这两个职责。如果处理一个视图也会导致另一个操作发生（例如，发送电子邮件），那么我们应该将该代码放在服务模块中，而不是直接放在视图中。

web 开发人员面临的许多工作是重复的（例如，处理表单、显示特定模型、列出该模型的所有实例等等）。Django 的“电池包含”理念意味着它包含了使这些重复性任务变得更容易的工具。

Django 提供了一套丰富的基于**类的视图**（**CBV**），从而简化了常见的 web 开发人员任务。CBV 使用**面向对象编程**（**OOP**的原则来增加代码重用。Django 附带了一套丰富的 CBV，可以轻松地处理表单或显示模型实例的 HTML 页面。

HTML 视图返回来自呈现模板。Django 中的模板通常用 Django 的模板语言编写。Django 还可以支持其他模板语言（例如，Jinja）。通常，每个视图都与一个模板关联。

让我们从创建许多视图所需的资源开始。

# 共同资源

在本节中，我们将创建视图和模板所需的一些公共资源：

*   我们将创建一个基础模板，所有其他模板都可以扩展它。在我们所有的页面上使用相同的基本模板将给 Mail Ape 一个统一的外观和感觉。
*   我们将创建一个`MailingListOwnerMixin`类，它将允许我们保护邮件列表消息不被未经授权的访问。

让我们先创建一个基础模板。

# 创建基础模板

让我们为 Mail Ape 创建一个基本模板。我们的所有页面都将使用此模板，以使我们的整个 web 应用程序具有一致的外观。

**Django 模板语言**（**DTL**允许我们编写 HTML（或其他基于文本的格式），并允许我们使用*标记*、*变量*和*过滤器*来执行自定义 HTML 的代码。让我们仔细看看这三个概念：

*   *标签*：标签被`{% %}`包围，可能（`{% block body%}{% endblock %}`）也可能不（`{% url "myurl" %}`）包含主体。
*   *变量*：它们被`{{ }}`包围，必须在模板的上下文中设置（例如`{{ mailinglist }}`。虽然 DTL 变量类似于 Python 变量，但也存在差异。最关键的两个是可执行文件和字典。首先，DTL 没有向可执行文件传递参数的语法（您永远不必使用`{{foo(1)}}`。如果您引用了一个变量并且它是可调用的（例如，一个函数），那么 Django 模板语言将调用它并返回结果（例如，`{{mailinglist.get_absolute_url}}`。其次，DTL 不区分对象属性、列表中的项和字典中的项。所有三个都使用点访问：`{{mailinglist.name}}`、`{{mylist.1}}`和`{{mydict.mykey}}`。
*   *过滤器*：它们跟随一个变量并修改其值（例如，`{{ mailinglist.name | upper}}`将返回邮件列表的大写名称）。

在我们继续创建 Mail Ape 时，我们将看看这三个示例。

让我们创建一个公共模板目录-`django/templates`-并将我们的模板放入`django/templates/base.html`：

```
<!DOCTYPE html>
<html lang="en" >
<head >
  <meta charset="UTF-8" >
  <title >{% block title %}{% endblock %}</title >
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/css/bootstrap.min.css"
  />
</head >
<body >
<div class="container" >
  <nav class="navbar navbar-light bg-light" >
    <a class="navbar-brand" href="#" >Mail Ape </a >
    <ul class="navbar-nav" >
      <li class="nav-item" >
        <a class="nav-link"
           href="{% url "mailinglist:mailinglist_list" %}" >
          Your Mailing Lists
        </a >
      </li >
      {% if request.user.is_authenticated %}
        <li class="nav-item" >
          <a class="nav-link"
             href="{% url "user:logout" %}" >
            Logout
          </a >
        </li >
      {% else %}
        <li class="nav-item" >
          <a class="nav-link"
             href="{% url "user:login" %}" >
            Your Mailing Lists
          </a >
        </li >
        <li class="nav-item" >
          <a class="nav-link"
             href="{% url "user:register" %}" >
            Your Mailing Lists
          </a >
        </li >
      {% endif %}
    </ul >
  </nav >
  {% block body %}
  {% endblock %}
</div >
</body >
</html >
```

在我们的基本模板中，我们将注意以下三个标记的示例：

*   `{% url ... %}`：返回视图的路径。它的工作原理与我们前面看到的`reverse()`函数类似，只是在 Django 模板中。
*   `{% if ... %} ... {% else %} ... {% endif %}`：这就像 Python 开发人员所期望的那样。`{% else %}`条款是可选的。如果我们需要在多项选择中进行选择，Django 模板语言也支持`{% elif ... %}`。
*   `{% block ... %}`：这定义了一个块，扩展了`base.html`的模板可以用自己的内容替换该块。我们有两个街区，`body`和`title`。

我们现在有了一个基础模板，其他模板只需提供正文和标题栏即可使用。

现在我们有了模板，我们必须告诉 Django 在哪里可以找到它。让我们更新`django/config/settings.py`让 Django 知道我们新的`django/templates`目录。

在`django/config/settings.py`中，找到以`Templates`开头的行。我们需要将我们的`templates`目录添加到`DIRS`键下的列表中：

```
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates'),
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            # do not change OPTIONS, omitted for brevity
        },
    },
]
```

Django 允许我们通过在运行时将到`django`的路径计算为`BASE_DIR`来避免硬编码到`django/templates`的路径。这样，我们就可以跨环境使用相同的设置。

我们刚才看到的另一个重要场景是`APP_DIRS`。此设置告诉 Django 在 Django 查找模板时，检查每个已安装的应用程序的`templates`目录。这意味着我们不必为每个已安装的应用程序更新`DIRS`键，并允许我们在应用程序下隔离模板（增加可重用性）。最后，重要的是要记住，应用程序是按照它们在`INSTALLED_APPS`中出现的顺序进行搜索的。如果存在模板名称冲突（例如，两个应用程序提供一个名为`registration/login.html`的模板），则将使用`INSTALLED_APPS`中首先列出的模板。

接下来，让我们将项目配置为在 HTML 中呈现表单时使用 Bootstrap4。

# 配置 Django Crispy 表单以使用 Bootstrap 4

在我们的基础模板中，我们包含了 bootstrap4css 模板。为了便于使用 Bootstrap4 呈现表单和设置表单样式，我们将使用第三方 Django 应用程序 Django Crispy Forms。然而，我们必须配置 Django Crispy 表单，让它使用 Bootstrap 4。

让我们在`django/config/settings.py`的底部添加一个新设置：

```
CRISPY_TEMPLATE_PACK = 'bootstrap4'
```

现在，Django Crispy Forms 被配置为在呈现表单时使用 Bootstrap 4。在本章后面的章节中，我们将介绍如何在模板中呈现表单。

接下来，让我们创建一个 mixin，确保只有邮件列表的所有者才能影响他们。

# 创建 mixin 以检查用户是否可以使用邮件列表

Django 使用**基于类的视图**（**CBVs**）使代码更易于重用，简化了重复性任务。在`mailinglist`应用程序中，我们必须做的一项重复任务是保护`MailingList`及其相关模型不被其他用户篡改。我们将创建一个提供保护的 mixin。

mixin 是一个提供有限功能的类，该功能旨在与其他类一起使用。我们以前见过`LoginRequired`mixin，它可以与视图类结合使用，以保护视图不受未经验证的访问。在本节中，我们将创建一个新的 mixin。

让我们在`django/mailinglist/mixins.py`的新文件中创建我们的`UserCanUseMailingList`mixin：

```
from django.core.exceptions import PermissionDenied, FieldDoesNotExist

from mailinglist.models import MailingList

class UserCanUseMailingList:

    def get_object(self, queryset=None):
        obj = super().get_object(queryset)
        user = self.request.user
        if isinstance(obj, MailingList):
            if obj.user_can_use_mailing_list(user):
                return obj
            else:
                raise PermissionDenied()

        mailing_list_attr = getattr(obj, 'mailing_list')
        if isinstance(mailing_list_attr, MailingList):
            if mailing_list_attr.user_can_use_mailing_list(user):
                return obj
            else:
                raise PermissionDenied()
        raise FieldDoesNotExist('view does not know how to get mailing '
                                   'list.')
```

我们的类定义了一个方法`get_object(self, queryset=None)`。此方法与`SingleObjectMixin.get_object()`具有相同的签名，Django 的许多内置 CBV（例如，`DetailView`）都使用了`SingleObjectMixin.get_object()`。我们的`get_object()`实现不做任何检索对象的工作。相反，我们的`get_object`只是检查父对象检索到的对象，以检查它是否为`MailingList`，并确认登录用户可以使用邮件列表。

关于 mixin，一个令人惊讶的事情是它依赖于一个超类，但不从超类继承。在`get_object()`中，我们显式地调用`super()`，但是`UserCanUseMailingList`没有任何基类。Mixin 类不希望自己使用。相反，它们将被类使用，这些类将它们分为*和*一个或多个其他类。

在接下来的几节中，我们将了解它是如何工作的。

# 创建邮件列表视图和模板

现在，我们来看看处理用户请求和返回响应的视图，这些视图显示了从模板创建的 UI。

让我们先创建一个视图来列出我们所有的`MailingList`对象。

# 创建 MailingListView 视图

我们将创建一个视图，显示用户拥有的邮件列表。

让我们在`django/mailinglist/views.py`中创建我们的`MailingListListView`：

```
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import ListView

from mailinglist.models import  MailingList

class MailingListListView(LoginRequiredMixin, ListView):

    def get_queryset(self):
        return MailingList.objects.filter(owner=self.request.user)
```

我们的观点来源于两种观点，`LoginRequiredMixin`和`ListView`。`LoginRequiredMixin`是一个 mixin，它确保未经身份验证的用户发出的请求被重定向到登录视图，而不是被处理。为了帮助`ListView`知道*要列出什么*，我们将覆盖`get_queryset()`方法并返回一个`QuerySet`，其中只包括当前登录用户拥有的`MailingList`。为了显示结果，`ListView`将尝试在`appname/modelname_list.html`处呈现模板。在我们的例子中，`ListView`将尝试呈现`mailinglist/mailinglist_list.html`。

让我们在`django/mailinglist/templates/mailinglist/mailinglist_list.html`中创建该模板：

```
{% extends "base.html" %}

{% block title %}
  Your Mailing Lists
{% endblock %}

{% block body %}
  <div class="row user-mailing-lists" >
    <div class="col-sm-12" >
      <h1 >Your Mailing Lists</h1 >
      <div >
        <a class="btn btn-primary"
           href="{% url "mailinglist:create_mailinglist" %}" >New List</a >
      </div >
      <p > Your mailing lists:</p >
      <ul class="mailing-list-list">
        {% for mailinglist in mailinglist_list %}
          <li class="mailinglist-item">
            <a href="{% url "mailinglist:manage_mailinglist" pk=mailinglist.id %}" >
              {{ mailinglist.name }}
            </a >
          </li >
        {% endfor %}
      </ul >
    </div >
  </div >
{% endblock %}
```

我们的模板扩展了`base.html`。当一个模板扩展另一个模板时，它只能将 HTML 放入先前定义的`block`中。我们还将看到许多新的 Django 模板标记。让我们仔细看看它们：

*   `{% extends "base.html" %}`：这告诉 Django 模板语言我们要扩展哪个模板。
*   `{% block title %}… {% endblock %}`：这告诉 Django，我们正在提供新代码，它应该放在扩展模板的`title`块中。替换该块中以前的代码（如果有）。
*   `{% for mailinglist in mailinglist_list %} ... {% endfor %}`：为列表中的每个项目提供一个 for 循环。
*   `{% url … %}`：`url`标记将为命名的`path`生成 URL 路径。
*   `{% url ... pk=...%}`：其工作原理与前一点类似，但在某些情况下，`path`可以接受参数（例如，`MailingList`的主键显示）。我们可以在`path`名称后面的`url`标记中指定这些额外参数。

我们现在有了一个视图和模板，它们可以一起工作。

任何视图的最后一步是将应用程序的 URLConf 添加到其中。让我们更新一下`django/mailinglist/urls.py`：

```
from django.urls import path

from mailinglist import views

app_name = 'mailinglist'

urlpatterns = [
    path('',
         views.MailingListListView.as_view(),
         name='mailinglist_list'),
]
```

根据我们之前配置根 URLConf 的方式，发送到`/mailinglist/`的任何请求都将路由到我们的`MailingListListView`。

接下来，让我们添加一个视图来创建新的`MailingList`s。

# 创建 CreateMailingListView 和模板

我们将创建一个视图来创建邮件列表。当我们的视图收到`GET`请求时，视图将向用户显示一个表单，用于输入邮件列表的名称。当我们的视图收到`POST`请求时，视图将验证表单，并重新显示有错误的表单，或者创建邮件列表并将用户重定向到列表的管理页面。

现在我们在`django/mailinglist/views.py`中创建视图：

```
class CreateMailingListView(LoginRequiredMixin, CreateView):
    form_class = MailingListForm
    template_name = 'mailinglist/mailinglist_form.html'

    def get_initial(self):
        return {
            'owner': self.request.user.id,
        }
```

`CreateMailingListView`来自两个类别：

*   `LoginRequiredMixin`重定向与登录用户无关的请求，使其不被处理（我们将在本章后面的*创建用户应用程序*部分对此进行配置）
*   `CreateView`知道如何使用`form_class`中指示的表单，并使用`template_name`中列出的模板进行渲染

`CreateView`是完成大部分工作的班级，我们几乎不需要提供任何额外信息。处理表单、验证表单和保存表单都是一样的，`CreateView`有相应的代码。如果我们需要改变一些行为，我们可以为`CreateView`提供的钩子覆盖一个，就像我们对`get_initial()`所做的一样。

当`CreateView`实例化我们的`MailingListForm`时，`CreateView`调用其`get_initial()`方法获取表单的`initial`数据（如果有）。我们使用这个钩子来确保表单的所有者被设置为登录用户的`id`。请记住，`MailingListForm`已禁用其`owner`字段，因此表单将忽略用户提供的任何数据。

接下来，让我们为`django/mailinglist/templates/mailinglist/mailinglist_form.html`中的`CreateView`创建模板：

```
{% extends "base.html" %}

{% load crispy_forms_tags %}

{% block title %}
  Create Mailing List
{% endblock %}

{% block body %}
  <h1 >Create Mailing List</h1 >
  <form method="post" class="col-sm-4" >
    {% csrf_token %}
    {{ form | crispy }}
    <button class="btn btn-primary" type="submit" >Submit</button >
  </form >
{% endblock %}
```

我们的模板扩展了`base.html`。当模板扩展另一个模板时，它只能将 HTML 放入先前由扩展模板定义的块中。我们还采用了许多新的 Django 模板标记。让我们仔细看看它们：

*   `{% load crispy_forms_tags %}`：这告诉 Django 加载一个新的模板标记库。在本例中，我们将从已安装的 Django Crispy Forms 应用程序加载`crispy_from_tags`。这为我们提供了`crispy`过滤器，我们将在本节后面看到。
*   `{% csrf_token %}`：Django 处理的任何表单必须具有有效的 CSRF 令牌才能防止 CSRF 攻击（请参阅[第 3 章](03.html)、*海报、头像和安全*。`csrf_token`标记返回带有正确 CSRF 标记的隐藏输入标记。请记住，如果没有 CSRF 令牌，Django 通常不会处理 POST 请求。
*   `{{ form | crispy }}`：`form`变量是对视图正在处理的表单实例的引用，由`CreateView`传递到此模板的上下文中。`crispy`是`crispy_form_tags`标记库提供的过滤器，将使用引导 4 中使用的 HTML 标记和 CSS 类输出表单。

我们现在有了一个视图和模板，它们可以一起工作。视图可以使用模板创建用户界面，将数据输入表单。然后，视图可以处理表单的数据，并从有效的表单数据创建一个`MailingList`模型，或者在数据有问题时重新显示表单。Django Crispy 表单库使用 Bootstrap 4 CSS 框架中的 HTML 和 CSS 呈现表单。

最后，让我们将视图添加到`mailinglist`应用程序的 URLConf 中。在`django/mailinglist/urls.py`中，我们向 URLConf 添加一个新的`path()`对象：

```
    path('new',
         views.CreateMailingListView.as_view(),
         name='create_mailinglist')
```

根据我们之前配置根 URLConf 的方式，发送到`/mailinglist/new`的任何请求都将路由到我们的`CreatingMailingListView`。

接下来，我们来查看删除一个`MailingList`。

# 创建 DeleteMailingListView 视图

在`MailingList`不再有用后，用户将希望删除它们。让我们创建一个视图，提示用户确认`GET`请求，并删除`POST`上的`MailingList`。

我们将在`django/mailinglist/views.py`中添加我们的视图：

```
class DeleteMailingListView(LoginRequiredMixin, UserCanUseMailingList,
                            DeleteView):
    model = MailingList
    success_url = reverse_lazy('mailinglist:mailinglist_list')
```

让我们仔细研究一下 T0T 的派生类：

*   `LoginRequiredMixin`：这与前面代码中的功能相同，确保未经身份验证的用户的请求不会被处理。用户只是被重定向到登录页面。
*   `UserCanUseMailingList`：这是我们在前面代码中创建的 mixin。`DeleteView`使用`get_object()`方法检索要删除的模型实例。通过将`UserCanUseMailingList`混入`DeleteMailingListView`类，我们保护每个用户的`MailingList`不会被未经授权的用户删除。
*   `DeleteView`：这是一个 Django 视图，知道如何在`GET`请求上呈现确认模板，并在`POST`上删除相关模型。

为了让 Django 的`DeleteView`正常工作，我们需要对其进行正确配置。`DeleteView`知道从其`model`属性中删除哪个模型。`DeleteView`要求我们在向其发送请求时提供`pk`参数。要呈现确认模板，`DeleteView`将尝试使用`appname/modelname_confirm_delete.html`。在`DeleteMailingListView`的情况下，模板将为`mailinglist/mailinglist_confirm_delete.html`。如果模型删除成功，`DeleteView`将重定向到`success_url`值。我们避免了对`success_url`进行硬编码，而是使用`reverse_lazy()`按名称引用 URL。`reverse_lazy()`函数返回的值在用于创建`Response`对象之前不会解析。

让我们创建`DeleteMailingListView`在`django/mailinglist/templates/mailinglist/mailinglist_confirm_delete.html`中需要的模板：

```
{% extends "base.html" %}

{% block title %}
  Confirm delete {{ mailinglist.name }}
{% endblock %}

{% block body %}
  <h1 >Confirm Delete?</h1 >
  <form action="" method="post" >
    {% csrf_token %}
    <p >Are you sure you want to delete {{ mailinglist.name }}?</p >
    <input type="submit" value="Yes" class="btn btn-danger btn-sm ">
    <a class="btn btn-primary btn-lg" href="{% url "mailinglist:manage_mailinglist" pk=mailinglist.id %}">No</a>
  </form >
{% endblock %}
```

在这个模板中，我们不使用任何表单，因为没有任何要验证的输入。表单提交本身就是确认。

最后一步是将我们的视图添加到`django/mailinglist/urls.py`中的`urlpatterns`列表中：

```
 path('<uuid:pk>/delete',
     views.DeleteMailingListView.as_view(),
     name='delete_mailinglist'),
```

这个`path`看起来与我们之前看到的`path()`电话不同。在这个`path`中，我们将包含一个命名参数，该参数将从路径中解析出来并传递给视图。我们使用`<converter:name>`格式指定`path`命名参数。转换器知道如何匹配路径的一部分（例如，`uuid`转换器知道如何匹配 UUID；`int`知道如何匹配数字；`str`将匹配除`/`之外的任何非空字符串）。然后，匹配的文本将作为关键字参数和提供的名称传递给视图。在我们的例子中，要将请求路由到`DeleteMailingListView`，它必须有如下路径：`/mailinglist/bce93fec-f9c6-4ea7-b1aa-348d3bed4257/delete`。

现在我们可以列出、创建和删除`MailingList`了，让我们创建一个视图来管理其`Subscriber`和`Message`视图。

# 创建 MailingListDetailView

让我们创建一个视图，该视图将列出与`MailingList`相关的所有`Subscriber`和`Message`。我们还需要一个地方向用户展示`MailingList`的订阅页面链接。Django 可以轻松创建表示模型实例的视图。

让我们在`django/mailinglist/views.py`中创建我们的`MailingListDetailView`：

```
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import DetailView

from mailinglist.mixins import UserCanUseMailingList
from mailinglist.models import MailingList

class MailingListDetailView(LoginRequiredMixin, UserCanUseMailingList,
                            DetailView):
    model = MailingList
```

我们使用`LoginRequiredMixin`和`UserCanUseMailingList`的方式和目的与之前相同。这一次，我们将它们与`DetailView`一起使用，这是最简单的视图之一。它只是为其配置的模型的实例呈现一个模板。它通过接收来自`path`的`pk`参数来检索模型实例，就像`DeleteView`一样。此外，我们不必显式配置它将使用的模板，因为按照惯例，它使用`appname/modelname_detail.html`。在我们的情况下，它将是`mailinglist/mailinglist_detail.html`。

让我们在`django/mailinglist/templates/mailinglist/mailinglist_detail.html`中创建我们的模板：

```
{% extends "base.html" %}

{% block title %}
  {{ mailinglist.name }} Management
{% endblock %}

{% block body %}
  <h1 >{{ mailinglist.name }} Management
    <a class="btn btn-danger"
       href="{% url "mailinglist:delete_mailinglist" pk=mailinglist.id %}" >
      Delete</a >
  </h1 >

  <div >
    <a href="{% url "mailinglist:create_subscriber" mailinglist_pk=mailinglist.id %}" >Subscription
      Link</a >

  </div >

  <h2 >Messages</h2 >
  <div > Send new
    <a class="btn btn-primary"
       href="{% url "mailinglist:create_message" mailinglist_pk=mailinglist.id %}">
      Send new Message</a >
  </div >
  <ul >
    {% for message in mailinglist.message_set.all %}
      <li >
        <a href="{% url "mailinglist:view_message" pk=message.id %}" >{{ message.subject }}</a >
      </li >
    {% endfor %}
  </ul >

  <h2 >Subscribers</h2 >
  <ul >
    {% for subscriber in mailinglist.subscriber_set.all %}
      <li >
        {{ subscriber.email }}
        {{ subscriber.confirmed|yesno:"confirmed,unconfirmed" }}
        <a href="{% url "mailinglist:unsubscribe" pk=subscriber.id %}" >
          Unsubscribe
        </a >
      </li >
    {% endfor %}
  </ul >
{% endblock %}
```

前面的代码模板只引入了一个新项（`yesno`过滤器），但实际上展示了 Django 模板语言的所有工具是如何结合在一起的。

`yesno`过滤器获取一个值，如果该值计算为`True`，则返回`yes`；如果该值计算为`False`，则返回`no`，如果该值计算为`None`，则返回`maybe`。在我们的例子中，我们传递了一个参数，告诉`yesno`返回`confirmed`if`True`和`unconfirmed`if`False`。

`MailingListDetailView`类和模板演示了 Django 如何让我们简洁地完成一项常见的 web 开发人员任务：在数据库中显示一行的页面。

接下来，让我们在`mailinglist`URLConf 中为我们的视图创建一个新的`path()`对象：

```
    path('<uuid:pk>/manage',
         views.MailingListDetailView.as_view(),
         name='manage_mailinglist')
```

接下来，让我们为`Subscriber`模型实例创建视图。

# 创建订阅服务器视图和模板

在本节中，我们将创建视图和模板，让用户与我们的`Subscriber`模型交互。这些视图与`MailingList`和`Message`视图之间的主要区别之一是，它们不需要任何 mixin，因为它们将被公开。它们防止篡改的主要保护措施是，`Subscriber`由一个具有较大密钥空间的 UUID 标识，这意味着篡改不太可能发生。

让我们从`SubscribeToMailingListView`开始。

# 创建 SubscribeTomAlingListView 和模板

我们需要一个收集`Subscriber`s 到`MailingList`s 的视图。让我们用`django/mailinglist/views.py`创建一个`SubscribeToMailingListView`类：

```
class SubscribeToMailingListView(CreateView):
    form_class = SubscriberForm
    template_name = 'mailinglist/subscriber_form.html'

    def get_initial(self):
        return {
            'mailing_list': self.kwargs['mailinglist_id']
        }

    def get_success_url(self):
        return reverse('mailinglist:subscriber_thankyou', kwargs={
            'pk': self.object.mailing_list.id,
        })

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        mailing_list_id = self.kwargs['mailinglist_id']
        ctx['mailing_list'] = get_object_or_404(
            MailingList,
            id=mailing_list_id)
        return ctx
```

我们的`SubscribeToMailingListView`与`CreateMailingListView`类似，但覆盖了两个新方法：

*   `get_success_url()`：由`CreateView`调用，获取 URL，将用户重定向到已创建的模型。在`CreateMailingListView`中，我们不需要覆盖它，因为默认行为使用模型的`get_absolute_url`。我们使用`reverse()`函数解析到感谢页面的路径。
*   `get_context_data()`：这允许我们向模板的上下文添加新变量。在这种情况下，我们需要访问用户可以订阅的`MailingList`以显示`MailingList`的名称。我们使用 Django 的`get_object_or_404()`快捷方式函数通过其 ID 检索`MailingList`或引发 404 异常。我们将让此视图的`path`解析请求路径之外的`mailinglist_id`（请参阅本节末尾的）。

接下来，我们在`mailinglist/templates/mailinglist/subscriber_form.html`中创建我们的模板：

```
{% extends "base.html" %}
{% load crispy_forms_tags %}
{% block title %}
Subscribe to {{ mailing_list }}
{% endblock %}

{% block body %}
<h1>Subscribe to {{ mailing_list }}</h1>
<form method="post" class="col-sm-6 ">
  {% csrf_token %}
  {{ form | crispy }}
  <button class="btn btn-primary" type="submit">Submit</button>
</form>
{% endblock %}
```

该模板没有引入任何标记，但展示了另一个示例，说明如何使用 Django 的模板语言和 Django Crispy Forms API 快速构建漂亮的 HTML 表单。我们像以前一样扩展了`base.html`，以使我们的页面具有一致的外观和感觉。`base.html`还提供了我们将要将内容放入的块。在任何块之外，我们`{% load %}`使用 Django Crispy Forms 标记库，这样我们就可以使用表单上的`crispy`过滤器生成与 Bootstrap 4 兼容的 HTML。

接下来，让我们通过在`mailinglist`应用程序的 URLConf`urlpatterns`列表中添加`path()`到`SubscribeToMailingListView`来确保 Django 知道如何将请求路由到我们的新视图：

```
    path('<uuid:mailinglist_id>/subscribe',
         views.SubscribeToMailingListView.as_view(),
         name='subscribe'),
```

在这个`path()`中，我们需要匹配传递给视图的`uuid`参数`mailinglist_pk`。这是我们的`get_context_data()`方法引用的关键字参数。

接下来，让我们创建一个感谢页面，感谢订阅邮件列表的用户。

# 创建“感谢您订阅”视图

用户订阅邮件列表后，我们希望向他们显示一个*感谢*页面。对于订阅同一邮件列表的所有用户，此页面可以是相同的，因为它只显示邮件列表的名称（而不是订阅者的电子邮件）。为了创建这个视图，我们将使用我们以前见过的`DetailView`，但这次没有任何额外的混合（这里没有要保护的信息）。

让我们在`django/mailinglist/views.py`中创建我们的`ThankYouForSubscribingView`：

```
from django.views.generic import DetailView

from mailinglist.models import  MailingList

class ThankYouForSubscribingView(DetailView):
    model = MailingList
    template_name = 'mailinglist/subscription_thankyou.html'
```

Django 在`DetailView`中为我们完成所有工作，只要我们提供`model`属性。`DetailView`知道如何查找模型，然后为该模型呈现模板。我们还提供了一个`template_name`属性，因为`MailingListDetailView`已经在使用`mailinglist/mailinglist_detail.html`模板（默认情况下`DetailView`将使用该模板）。

让我们在`django/mailinglist/templates/mailinglist/subscription_thankyou.html`中创建我们的模板：

```
{% extends "base.html" %}

{% block title %}
  Thank you for subscribing to {{ mailinglist }}
{% endblock %}

{% block body %}
  <div class="col-sm-12" ><h1 >Thank you for subscribing
    to {{ mailinglist }}</h1 >
    <p >Check your email for a confirmation email.</p >
  </div >
{% endblock %}
```

我们的模板只显示感谢和模板名称。

最后，让我们在`mailinglist`应用程序的 URLConf 的`urlpatterns`列表中添加`path()`到`ThankYouForSubscribingView`：

```
    path('<uuid:pk>/thankyou',
         views.ThankYouForSubscribingView.as_view(),
         name='subscriber_thankyou'),
```

我们的`path`需要匹配 UUID，以便将请求路由到`ThankYouForSubscribingView`。UUID 将作为关键字参数`pk`传递到视图中。此`pk`将被`DetailView`用于查找更正的`MailingList`。

接下来，我们需要让用户确认他们想要在这个地址接收电子邮件。

# 创建订阅确认视图

为了防止垃圾邮件发送者滥用我们的服务，我们需要向我们的订户发送电子邮件，以确认他们确实想要订阅我们用户的邮件列表。我们将介绍发送这些电子邮件，但我们现在将创建确认页面。

这个确认页面的行为会有点奇怪。只需访问页面即可将`Subscriber.confirmed`修改为`True`。这是邮件列表确认页面工作方式的标准（我们希望避免为订阅者创建额外的工作），但根据 HTTP 规范，这很奇怪，该规范规定`GET`请求不应修改资源。

让我们在`django/mailinglist/views.py`中创建我们的`ConfirmSubscriptionView`：

```
from django.views.generic import DetailView

from mailinglist.models import  Subscriber

class ConfirmSubscriptionView(DetailView):
    model = Subscriber
    template_name = 'mailinglist/confirm_subscription.html'

    def get_object(self, queryset=None):
        subscriber = super().get_object(queryset=queryset)
        subscriber.confirmed = True
        subscriber.save()
        return subscriber
```

`ConfirmSubscriptionView`是另一个`DetailView`，因为它显示了单个模型实例。在这种情况下，我们重写`get_object()`方法，以便在返回对象之前修改它。由于`Subscriber`不是我们系统的用户，所以我们不需要使用`LoginRequiredMixin`。我们的视图不受暴力枚举的影响，因为`Subscriber.id`的密钥空间很大，并且是非顺序分配的。

接下来，我们在`django/mailinglist/templates/mailinglist/confirm_subscription.html`中创建我们的模板：

```
{% extends "base.html" %}

{% block title %}
  Subscription to {{ subscriber.mailing_list }} confirmed.
{% endblock %}

{% block body %}
  <h1 >Subscription to {{ subscriber.mailing_list }} confirmed!</h1 >
{% endblock %}
```

我们的模板使用`base.html`中定义的块来简单地通知用户他们已确认的订阅。

最后，让我们在`mailinglist`应用程序的 URLConf 的`urlpatterns`列表中添加`path()`到`ConfirmSubscriptionView`：

```
    path('subscribe/confirmation/<uuid:pk>',
         views.ConfirmSubscriptionView.as_view(),
         name='confirm_subscription')
```

我们的`confirm_subscription`路径定义要匹配的路径，以便将请求路由到我们的视图。我们的匹配表达式包含 UUID 的要求，它将作为关键字参数`pk`传递给我们的`ConfirmSubscriptionView`。然后`ConfirmSubscriptionView`的父项（`DetailView`将使用该项检索正确的`Subscriber`。

接下来，让`Subscribers`自行退订。

# 创建取消订阅视图

作为一个道德邮件提供商的一部分是让我们的`Subscriber`取消订阅。接下来，我们将创建一个`UnsubscribeView`，在他们确认确实要取消订阅后，它将删除一个`Subscriber`模型实例。

让我们将我们的观点添加到`django/mailinglist/views.py`：

```
from django.views.generic import DeleteView

from mailinglist.models import Subscriber

class UnsubscribeView(DeleteView):
    model = Subscriber
    template_name = 'mailinglist/unsubscribe.html'

    def get_success_url(self):
        mailing_list = self.object.mailing_list
        return reverse('mailinglist:subscribe', kwargs={
            'mailinglist_pk': mailing_list.id
        })
```

我们的`UnsubscribeView`让 Django 的内置`DeleteView`工具呈现模板，并找到并删除正确的`Subscriber`。`DeleteView`要求接收`Subscriber`的`pk`作为从路径解析的关键字参数（很像`DetailView`。当删除成功时，我们将使用`get_success_url()`方法将用户重定向到订阅页面。当`get_success_url()`正在执行时，我们的`Subscriber`实例已经从数据库中删除，但相应对象的副本将在`self.object`下可用。我们将使用仍在内存中（但不在数据库中）的实例来获取相关邮件列表的`id`属性。

为了提交确认表，我们需要在`django/mailinglist/templates/mailinglist/unsubscribe.html`中创建一个模板：

```
{% extends "base.html" %}

{% block title %}
  Unsubscribe?
{% endblock %}

{% block body %}
  <div class="col">
    <form action="" method="post" >
      {% csrf_token %}
      <p >Are you sure you want to unsubscribe
        from {{ subscriber.mailing_list.name }}?</p >
      <input class="btn btn-danger" type="submit"
             value="Yes, I want to unsubscribe " >
    </form >
  </div >
{% endblock %}
```

此模板呈现一个`POST`表单，它将作为`subscriber`取消订阅愿望的确认。

接下来，让我们将`path()`添加到`UnsubscribeView`到`mailinglist`应用程序的 URLConf 的`urlpatterns`列表中：

```
     path('unsubscribe/<uuid:pk>',
         views.UnsubscribeView.as_view(),
         name='unsubscribe'),
```

在处理源自`DetailView`或`DeleteView`的视图时，务必记住将路径匹配器命名为`pk`。

太好了，现在，让我们允许用户开始创建他们将发送给他们的`Subscriber`的`Message`。

# 创建消息视图

我们跟踪用户希望发送给`Message`模式中`Subscriber`的电子邮件。为了确保我们准确记录用户发送给他们的`Subscribers`的内容，我们将限制`Message`上的可用操作。我们的用户只能创建和查看`Message`s。支持编辑是没有意义的，因为已发送的电子邮件无法修改。我们也不支持删除消息，以便我们和用户都能准确记录请求发送的内容。

让我们从做一个`CreateMessageView`开始！

# 创建 CreateMessageView

我们的`CreateMessageView`将遵循类似于我们为 Answerly 创建的降价形式的模式。用户将获得一个表单，他们可以提交该表单进行保存或预览。如果提交是预览，则表单将与`Message`的已呈现标记预览一起呈现。如果用户选择保存，则他们将创建新消息。

因为我们正在创建一个新的模型实例，所以我们将使用 Django 的`CreateView`。

让我们在`django/mailinglist/views.py`中创建我们的视图：

```
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import CreateView

from mailinglist.models import Message

class CreateMessageView(LoginRequiredMixin, CreateView):
    SAVE_ACTION = 'save'
    PREVIEW_ACTION = 'preview'

    form_class = MessageForm
    template_name = 'mailinglist/message_form.html'

    def get_success_url(self):
        return reverse('mailinglist:manage_mailinglist',
                       kwargs={'pk': self.object.mailing_list.id})

    def get_initial(self):
        mailing_list = self.get_mailing_list()
        return {
            'mailing_list': mailing_list.id,
        }

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        mailing_list = self.get_mailing_list()
        ctx.update({
            'mailing_list': mailing_list,
            'SAVE_ACTION': self.SAVE_ACTION,
            'PREVIEW_ACTION': self.PREVIEW_ACTION,
        })
        return ctx

    def form_valid(self, form):
        action = self.request.POST.get('action')
        if action == self.PREVIEW_ACTION:
            context = self.get_context_data(
                form=form,
                message=form.instance)
            return self.render_to_response(context=context)
        elif action == self.SAVE_ACTION:
            return super().form_valid(form)

    def get_mailing_list(self):
        mailing_list = get_object_or_404(MailingList,
                                         id=self.kwargs['mailinglist_pk'])
        if not mailing_list.user_can_use_mailing_list(self.request.user):
            raise PermissionDenied()
        return mailing_list
```

我们的观点继承自`CreateView`和`LoginRequiredMixin`。我们使用`LoginRequiredMixin`来防止未经验证的用户向邮件列表发送邮件。为了防止已登录但未经授权的用户发送消息，我们将创建一个中心`get_mailing_list()`方法，检查已登录用户是否可以使用此邮件列表。`get_mailing_list()`希望将`mailinglist_pk`作为关键字参数提供给视图。

让我们更仔细地看一下，看看这一切是如何一起工作的：

*   `form_class = MessageForm`：这是我们希望`CreateView`呈现、验证并用于创建`Message`模型的表单。
*   `template_name = 'mailinglist/message_form.html'`：这是我们接下来要创建的模板。
*   `def get_success_url()`：成功创建`Message`后，我们会将用户重定向到`MailingList`的管理页面。
*   `def get_initial():`：我们的`MessageForm`已禁用其`mailing_list`字段，因此用户无法尝试为其他用户的`MailingList`秘密创建`Message`。相反，我们使用`get_mailing_list()`方法根据`mailinglist_pk`参数获取邮件列表。使用`get_mailing_list()`检查登录用户是否可以使用`MailingList`。
*   `def get_context_data()`：这为模板的上下文提供了额外的变量。我们提供了`MailingList`以及保存和预览常量。
*   `def form_valid()`：定义表单有效时的行为。我们重写了`CreateView`的默认行为来检查`action`POST 参数。`action`将告诉我们是呈现`Message`的预览还是让`CreateView`保存一个新的`Message`模型实例。如果我们正在预览消息，那么我们会将表单构建的未保存的`Message`实例传递给模板的上下文。

接下来，让我们在`django/mailinglist/templates/mailinglist/message_form.html`中制作我们的模板：

```
{% extends "base.html" %}
{% load crispy_forms_tags %}
{% load markdownify %}
{% block title %}
  Send a message to {{ mailing_list }}
{% endblock %}

{% block body %}
  <h1 >Send a message to {{ mailing_list.name }}</h1 >
  {% if message %}
    <div class="card" >
      <div class="card-header" >
        Message Preview
      </div >
      <div class="card-body" >
        <h5 class="card-title" >{{ message.subject }}</h5 >
        <div>{{ message.body|markdownify }}</div>
      </div >
    </div >
  {% endif %}
  <form method="post" class="col-sm-12 col-md-9" >
    {% csrf_token %}
    {{ form | crispy }}
    <button type="submit" name="action"
            value="{{ SAVE_ACTION }}"
            class="btn btn-primary" >Save
    </button >
    <button type="submit" name="action"
            value="{{ PREVIEW_ACTION }}"
            class="btn btn-primary" >Preview
    </button >
  </form >
{% endblock %}
```

此模板加载第三方 Django Markdownify 标记库和 Django Crispy Forms 标记库。前者为我们提供`markdownify`过滤器，后者为我们提供`crispy`过滤器。`markdownify`过滤器将接收到的标记文本转换为 HTML。我们之前在第 2 部分的 Answerly 项目中使用了 Django Markdownify。

此模板表单有两个提交按钮，一个用于保存表单，另一个用于预览表单。仅当我们传入`message`进行预览时，才会渲染预览块。

现在我们有了视图和模板，让我们在`mailinglist`应用程序的 URLConf 中向`CreateMessageView`添加一个`path()`：

```
     path('<uuid:mailinglist_ipk>/message/new',
         views.CreateMessageView.as_view(),
         name='create_message'),
```

现在我们可以创建消息了，让我们创建一个视图来查看我们已经创建的消息。

# 创建消息详细视图

为了让用户查看他们发送到`Subscriber`的`Message`，我们需要一个`MessageDetailView`。此视图仅显示一个`Message`，但应仅允许已登录并可以使用`Message`的`MailingList`的用户访问该视图。

让我们在`django/mailinglist/views.py`中创建我们的视图：

```
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import DetailView

from mailinglist.mixins import UserCanUseMailingList
from mailinglist.models import Message

class MessageDetailView(LoginRequiredMixin, UserCanUseMailingList,
                        DetailView):
    model = Message
```

顾名思义，我们将使用 Django 的`DetailView`。为了提供我们所需要的保护，我们将添加 Django 的`LoginRequiredMixin`和`UserCanUseMailingList`mixin。正如我们之前所看到的，我们不需要指定模板的名称，因为`DetailView`将根据应用程序和模型的名称来假定它。在我们的例子中，`DetailView`希望模板被称为`mailinglist/message_detail.html`。

让我们在`mailinglist/message_detail.html`中创建我们的模板：

```
{% extends "base.html" %}
{% load markdownify %}

{% block title %}
  {{ message.subject }}
{% endblock %}

{% block body %}
  <h1 >{{ message.subject }}</h1 >
  <div>
    {{ message.body|markdownify }}
  </div>
{% endblock %}
```

我们的模板扩展了`base.html`并在`body`块中显示消息。在显示`Message.body`时，我们使用第三方 Django Markdownify 标记库的`markdownify`过滤器将任何标记文本呈现为 HTML。

最后，我们需要在`mailinglist`应用程序的 URLConf 的`urlpatterns`列表中添加`path()`到`MessageDetailView`：

```
    path('message/<uuid:pk>', 
         views.MessageDetailView.as_view(), 
         name='view_message')
```

我们现在已经完成了`mailinglist`应用程序的模型、视图和模板。我们甚至创建了一个`UserCanUseMailingList`来让我们的视图轻松防止未经授权访问`MailingList`或其相关视图。

接下来，我们将创建一个`user`应用程序来封装用户注册和身份验证。

# 创建用户应用程序

要在 Mail Ape 中创建`MailingList`，用户需要有一个帐户并登录。在本节中，我们将为我们的`user`Django 应用程序编写代码，它将封装与用户相关的所有内容。请记住，Django 应用程序应该严格限定范围。我们不想把这种行为放在我们的`mailinglist`应用程序中，因为这是两个独立的关注点。

我们的`user`应用程序将与 MyMDB（第 1 部分）和 Answerly（第 2 部分）中的`user`应用程序非常相似。由于这种相似性，我们将略过一些话题。关于本主题的深入探讨，请参考[第 2 章](02.html)*向 MyMDb*添加用户。

Django 通过其内置的`auth`应用程序（`django.contrib.auth`，使用户管理和身份验证变得更加容易。`auth`应用程序提供了一个默认用户模型，一个用于创建新用户的`Form`，以及登录和注销视图。这意味着我们的`user`应用程序只需填补几个空白，就可以在本地完成完整的用户管理。

让我们首先在`django/user/urls.py`中为我们的`user`应用程序创建一个 URLConf：

```
from django.contrib.auth.views import LoginView, LogoutView
from django.urls import path

import user.views

app_name = 'user'

urlpatterns = [
    path('login', LoginView.as_view(), name='login'),
    path('logout', LogoutView.as_view(), name='logout'),
    path('register', user.views.RegisterView.as_view(), name='register'),
]
```

我们的 URLConf 由三个视图组成：

*   `LoginView.as_view()`：这是`auth`应用的登录视图。`auth`应用程序提供接受凭证的视图，但没有模板。我们需要创建一个名为`registration/login.html`的模板。默认情况下，登录时会将用户重定向到`settings.LOGIN_REDIRECT_URL`。我们还可以传递一个`next``GET`参数来替代设置。
*   `LogoutView.as_view()`：这是 auth 应用程序的注销视图。`LogoutView`是为数不多的修改`GET`请求状态、注销用户的视图之一。该视图返回重定向响应。我们可以使用`settings.LOGOUT_REDIRECT_URL`配置我们的用户在注销时将被重定向到的位置。同样，我们使用`GET`参数`next`来定制此行为。
*   `user.views.RegisterView.as_view()`：这是我们要写的用户注册视图。Django 为我们提供了一个`UserCreationForm`而不是一个视图。

我们还需要添加一些设置，以使 Django 正确使用我们的`user`视图。让我们用一些新的设置来更新`django/config/settings.py`：

```
LOGIN_URL = 'user:login'
LOGIN_REDIRECT_URL = 'mailinglist:mailinglist_list'
LOGOUT_REDIRECT_URL = 'user:login'
```

这三个设置告诉 Django 如何在不同的身份验证场景中重定向用户：

*   `LOGIN_URL`：当未经身份验证的用户试图访问需要身份验证的页面时，`LoginRequiredMixin`使用此设置。
*   `LOGIN_REDIRECT_URL`：当用户登录时，我们应该将其重定向到哪里？通常，我们会将他们重定向到个人资料页面；在我们的例子中，显示`MailingList`列表的页面。
*   `LOGOUT_REDIRECT_URL`：当用户注销时，我们应该将其重定向到哪里？在我们的例子中，是登录页面。

我们现在还剩下两项任务：

*   创建登录模板
*   创建用户注册视图和模板

让我们从制作登录模板开始。

# 创建登录模板

让我们在`django/user/templates/registration/login.html`中制作我们的登录模板：

```
{% extends "base.html" %}
{% load crispy_forms_tags %}

{% block title %} Login - {{ block.super }} {% endblock %}

{% block body %}
  <h1>Login</h1>
  <form method="post" class="col-sm-6">
    {% csrf_token %}
    {{ form|crispy }}
    <button type="submit" id="log_in" class="btn btn-primary">Log in</button>
  </form>
{% endblock %}
```

此表单遵循我们以前表单的所有实践。我们使用`csrf_token`来抵御 CSRF 攻击。我们使用`crsipy`过滤器使用 Bootstrap 4 样式的标记和类打印表单。

记住，我们不需要创建视图来处理登录请求，因为我们使用的是`django.contrib.auth`附带的视图。

接下来，让我们创建一个视图和模板来注册新用户。

# 创建用户注册视图

Django 没有提供创建新用户的视图，但它提供了一个捕获新用户注册的表单。我们可以将`UserCreationForm`与`CreateView`组合，快速创建`RegisterView`。

让我们将我们的观点添加到`django/user/views.py`：

```
from django.contrib.auth.forms import UserCreationForm
from django.views.generic.edit import CreateView

class RegisterView(CreateView):
    template_name = 'user/register.html'
    form_class = UserCreationForm
```

这是一个非常简单的`CreateView`，就像我们在本章中已经看到的几次一样。

让我们在`django/user/templates/user/register.html`中创建我们的模板：

```
{% extends "base.html" %}
{% load crispy_forms_tags %}
{% block body %}
  <div class="col-sm-12">
    <h1 >Register for Mail Ape</h1 >
    <form method="post" >
      {% csrf_token %}
      {{ form | crispy }}
      <button type="submit" class="btn btn-primary" >
        Register
      </button >
    </form >
  </div >
{% endblock %}
```

同样，该模板遵循与我们之前的`CreateView`模板相同的模式。

现在，我们准备在本地运行 Mail Ape。

# 在本地运行 Mail Ape

Django 附带了一个开发服务器。此服务器不适合于生产（甚至登台）部署，但适合于本地开发。

让我们使用 Django 项目的`manage.py`脚本启动服务器：

```
$ cd django
$ python manage.py runserver
Performing system checks...

System check identified no issues (0 silenced).
January 29, 2018 - 23:35:15
Django version 2.0.1, using settings 'config.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

我们现在可以访问`http://127.0.0.1:8000`上的服务器。

# 总结

在本章中，我们开始了 Mail Ape 项目。我们创建了 Django 项目并启动了两个 Django 应用程序。`mailinglist`应用程序包含我们的邮件列表代码模型、视图和模板。`user`应用程序包含与用户相关的视图和模板。`user`应用程序更简单，因为它利用了 Django 的`django.contrib.auth`应用程序。

接下来，我们将构建一个 API，以便用户可以轻松地与 Mail Ape 集成。