# 十三、部署 MailApe

在本章中，我们将在**亚马逊网络服务**（**AWS**云中的虚拟机上部署 Mail Ape。AWS 由许多不同的服务组成。我们已经讨论过使用 S3 和在 AWS 中启动容器。在本章中，我们将使用更多的 AWS 服务。我们将为 PostgreSQL 数据库服务器使用**关系数据库服务（RDS）**。对于芹菜消息队列，我们将使用**简单队列服务（SQS）**。我们将使用**弹性计算云（EC2）**在云中运行虚拟机。最后，我们将使用 CloudFormation 将我们的基础设施定义为代码。

在本章中，我们将做以下事情：

*   独立的生产和开发设置
*   使用 Packer 创建我们版本的亚马逊机器映像
*   使用 CloudFormation 将基础结构定义为代码
*   使用命令行将 Mail Ape 启动到 AWS 中

让我们从分离生产开发设置开始。

# 开发与生产分离

到目前为止，我们保存了一个需求文件和一个`settings.py`文件。这为开发提供了便利。但是，我们不能在生产中使用我们的开发设置。

当前的最佳实践是每个环境有一个单独的文件。然后，每个环境的文件导入一个具有共享值的公共文件。我们将在需求和设置文件中使用此模式。

让我们从分解需求文件开始。

# 分离我们的需求文件

为了分离我们的需求，我们将删除现有的`requirements.txt`文件，并将其替换为通用、开发和生产需求文件。删除`requirements.txt`后，我们在项目的根目录下创建`requirements.common.txt`：

```py
django<2.1
psycopg2<2.8
django-markdownify==0.3.0
django-crispy-forms==1.7.0
celery<4.2
django-celery-results<2.0
djangorestframework<3.8
factory_boy<3.0
```

接下来，我们为`requirements.development.txt`创建一个需求文件：

```py
-r requirements.common.txt
celery[redis]
```

因为我们只在开发设置中使用 Redis，所以我们将把包保存在开发需求文件中。

我们将把我们的生产要求放在`requirements.production.txt`项目的根本部分：

```py
-r requirements.common.txt
celery[sqs]
boto3
pycurl
```

为了使芹菜能够与 SQS（AWS 消息队列服务）一起工作，我们需要安装芹菜 SQS 库（`celery[sqs]`。我们还将安装 Python AWS 库`boto3`和 Python`curl`实现`pycurl`。

接下来，让我们分离 Django 设置文件。

# 创建通用、开发和生产设置

与前面的章节一样，在我们将设置分为三个文件之前，我们将通过重命名当前的`settings.py`来创建`common_settings.py`，然后进行一些更改。

让我们更改`DEBUG = False`以便新设置文件不会*意外*处于调试模式。然后，我们通过更新`SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')`来更改要从环境变量获取的密钥。

在数据库配置中，我们可以删除所有凭证，但保留`ENGINE`（明确表示我们打算在任何地方使用 Postgres）：

```py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
    }
}
```

接下来，我们在`django/config/development_settings.py`中创建一个开发设置文件：

```py
from .common_settings import *

DEBUG = True

SECRET_KEY = 'secret key'

DATABASES['default']['NAME'] = 'mailape'
DATABASES['default']['USER'] = 'mailape'
DATABASES['default']['PASSWORD'] = 'development'
DATABASES['default']['HOST'] = 'localhost'
DATABASES['default']['PORT'] = '5432'

MAILING_LIST_FROM_EMAIL = 'mailape@example.com'
MAILING_LIST_LINK_DOMAIN = 'http://localhost'

EMAIL_HOST = 'smtp.example.com'
EMAIL_HOST_USER = 'username'
EMAIL_HOST_PASSWORD = os.getenv('EMAIL_PASSWORD')
EMAIL_PORT = 587
EMAIL_USE_TLS = True

CELERY_BROKER_URL = 'redis://localhost:6379/0'
```

请记住，您需要将`MAILING_LIST_FROM_EMAIL`、`EMAIL_HOST`和`EMAIL_HOST_USER`更改为正确的开发值。

接下来，我们将生产设置放在`django/config/production_settings.py`中：

```py
from .common_settings import *

DEBUG = False

assert SECRET_KEY is not None, (
    'Please provide DJANGO_SECRET_KEY environment variable with a value')

ALLOWED_HOSTS += [
    os.getenv('DJANGO_ALLOWED_HOSTS'),
]

DATABASES['default'].update({
    'NAME': os.getenv('DJANGO_DB_NAME'),
    'USER': os.getenv('DJANGO_DB_USER'),
    'PASSWORD': os.getenv('DJANGO_DB_PASSWORD'),
    'HOST': os.getenv('DJANGO_DB_HOST'),
    'PORT': os.getenv('DJANGO_DB_PORT'),
})

LOGGING['handlers']['main'] = {
    'class': 'logging.handlers.WatchedFileHandler',
    'level': 'DEBUG',
    'filename': os.getenv('DJANGO_LOG_FILE')
}

MAILING_LIST_FROM_EMAIL = os.getenv('MAIL_APE_FROM_EMAIL')
MAILING_LIST_LINK_DOMAIN = os.getenv('DJANGO_ALLOWED_HOSTS')

EMAIL_HOST = os.getenv('EMAIL_HOST')
EMAIL_HOST_USER = os.getenv('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = os.getenv('EMAIL_HOST_PASSWORD')
EMAIL_PORT = os.getenv('EMAIL_HOST_PORT')
EMAIL_USE_TLS = os.getenv('EMAIL_HOST_TLS', 'false').lower() == 'true'

CELERY_BROKER_TRANSPORT_OPTIONS = {
    'region': 'us-west-2',
    'queue_name_prefix': 'mailape-',
CELERY_BROKER_URL = 'sqs://'
}
```

我们的生产设置文件从环境变量获取其大部分值，这样我们就不会将生产值签入服务器。我们需要检查以下三种设置：

*   `MAILING_LIST_LINK_DOMAIN`：这是我们电子邮件中的链接指向的域。在我们的例子中，在前面的代码片段中，我们使用了添加到`ALLOWED_HOSTS`列表中的同一个域，确保我们为链接指向的域提供服务。
*   `CELERY_BROKER_TRANSPORT_OPTIONS`：这是一个选项字典，用于配置芹菜以使用正确的 SQS 队列。我们需要将区域设置为`us-west-2`，因为我们的整个生产部署将在该区域。默认情况下，芹菜将使用名为`celery`的队列。然而，我们不希望这个名称与我们可能部署的其他芹菜项目相冲突。为了防止名称冲突，我们将芹菜配置为使用`mailape-`前缀。
*   `CELERY_BROKER_URL`：这会告诉芹菜该用哪个经纪人。在我们的例子中，我们使用 SQS。我们将使用 AWS 基于角色的授权授予虚拟机对 SQS 的访问权限，这样我们就不必提供任何凭据。

现在我们已经创建了生产设置，让我们在 AWS 云中创建基础设施。

# 在 AWS 中创建基础结构堆栈

为了在 AWS 上托管应用程序，我们需要确保设置了一些基础设施。我们需要做以下几件事：

*   PostgreSQL 服务器
*   安全组打开网络端口，以便我们可以访问数据库和 web 服务器
*   一个 InstanceProfile，让我们部署的 VM 能够访问 SQS

我们可以使用 AWS web 控制台或命令行界面创建所有这些。然而，随着时间的推移，如果我们依赖于运行时调整，就很难跟踪我们的基础设施是如何配置的。如果我们可以在版本控制中跟踪的文件中描述我们所需的基础设施，就像跟踪代码一样，那就更好了。

AWS 提供了一个名为 CloudFormation 的服务，它让我们可以将基础设施视为代码。我们将使用 YAML 在 CloudFormation 模板中定义我们的基础设施（JSON 也可用，但我们将使用 YAML）。然后，我们将执行 CloudFormation 模板来创建 CloudFormation 堆栈。CloudFormation 堆栈将与 AWS 云中的实际资源相关联。如果我们删除 CloudFormation 堆栈，相关资源也将被删除。这使我们能够简单地控制 AWS 资源的使用。

让我们在`cloudformation/infrastructure.yaml`中创建我们的 CloudFormation 模板。每个 CloudFormation 模板都以`Description`开头，模板格式版本信息。让我们从以下内容开始我们的文件：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape Infrastructure
```

我们的 CloudFormation 模板将包含以下三个部分：

*   `Parameters`：我们将在这里描述我们将在运行时传递的值。此块是可选的，但很有用。在本例中，我们将传入主数据库密码，而不是在模板中对其进行硬编码。
*   `Resources`：我们将在这里描述我们的堆栈将包含的特定资源。这将描述我们的数据库服务器、SQS 队列、安全组和 InstanceProfile。
*   `Outputs`：在这里，我们将描述要输出的值，以便更容易地引用我们创建的资源。此块是可选的，但很有用。我们将提供数据库服务器的地址和我们创建的 InstanceProfile 的 ID。

让我们首先创建 CloudFormation 模板的`Parameters`块。

# 接受 CloudFormation 模板中的参数

为了避免在 CloudFormation 模板中硬编码值，我们可以接受参数。这有助于我们避免在模板中硬编码敏感值（如密码）。

让我们添加一个参数以接受数据库服务器主用户的密码：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape Infrastructure
Parameters:
  MasterDBPassword:
    Description: Master Password for the RDS instance
    Type: String
```

这将向我们的模板添加一个`MasterDBPassword`参数。稍后我们将能够引用此值。CloudFormation 模板允许我们为参数添加两条信息：

*   `Description`：这不是 CloudFormation 所使用的，但对于需要维护我们的基础设施的人员非常有用。
*   `Type`：CloudFormation 在执行我们的模板之前，使用此选项检查我们提供的值是否有效*。在我们的例子中，密码是一个`String`。*

接下来，让我们添加一个`Resources`块来定义我们在基础设施中需要的 AWS 资源。

# 在我们的基础设施中列出资源

接下来，我们将在`cloudformation/infrastructure.yaml`中的 CloudFormation 模板中添加一个`Resources`块。我们的基础架构模板将定义五种资源：

*   安全组，它将打开网络端口，允许我们访问数据库和 web 服务器
*   我们的数据库服务器
*   我们的 SQS 队列
*   允许访问 SQS 的角色
*   InstanceProfile，让我们的 web 服务器承担上述角色

让我们从创建安全组开始，它将打开网络端口，我们将通过这些端口访问数据库和 web 服务器。

# 添加安全组

在 AWS 中，SecurityGroup 定义了一组网络访问规则，非常类似于网络防火墙。默认情况下，启动的虚拟机可以*在任何网络端口上发送*数据，但不能*在任何网络端口上接受*连接。这意味着我们无法使用 SSH 或 HTTP 进行连接；让我们来解决这个问题。

让我们用三个新的安全组更新`cloudformation/infrastructure.yaml`中的 CloudFormation 模板：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape Infrastructure
Parameters:
  ...
Resources:
  SSHSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupName: ssh-access
      GroupDescription: permit ssh access
      SecurityGroupIngress:
        -
          IpProtocol: "tcp"
          FromPort: "22"
          ToPort: "22"
          CidrIp: "0.0.0.0/0"
  WebSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupName: web-access
      GroupDescription: permit http access
      SecurityGroupIngress:
        -
          IpProtocol: "tcp"
          FromPort: "80"
          ToPort: "80"
          CidrIp: "0.0.0.0/0"
  DatabaseSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupName: db-access
      GroupDescription: permit db access
      SecurityGroupIngress:
        -
          IpProtocol: "tcp"
          FromPort: "5432"
          ToPort: "5432"
          CidrIp: "0.0.0.0/0"
```

在前面的代码块中，我们定义了三个新的安全组来打开端口`22`（SSH）、`80`（HTTP）和`5432`（默认 Postgres 端口）。

让我们仔细看看云计算资源的语法。每个资源块必须有一个`Type`和`Properties`属性。`Type`属性告诉 CloudFormation 这个资源描述了什么。`Properties`属性描述此特定资源的设置。

我们的 SecurityGroup 使用了以下属性：

*   `GroupName`：这给了人类友好的名字。这是可选的，但建议使用。CloudFormation 可以为我们生成名称。对于给定的帐户，SecurityGroup 名称必须是唯一的（例如，我不能有两个`db-access`组，但您和我可以各有一个`db-access`组）。
*   `GroupDescription`：这是对集团宗旨的人性化描述。必须在场。
*   `SecurityGroupIngress`：这是一个端口列表，用于接受此组中 VM 的传入连接。
*   `FromPort`/`ToPort`：通常，这两个设置将具有相同的值，即您希望能够连接到的网络端口。`FromPort`是我们将连接的端口。`ToPort`是服务正在侦听的 VM 端口。
*   `CidrIp`：这是一个可以接受连接的 IPv4 范围。`0.0.0.0/0`表示接受所有连接。

接下来，让我们在资源列表中添加一个数据库服务器。

# 添加数据库服务器

AWS 将关系数据库服务器作为一种称为**关系数据库服务**（**RDS**的服务提供。要在 AWS 上创建数据库服务器，我们将创建一个新的 RDS VM（称为*实例*。需要注意的一点是，当我们启动 RDS 实例时，我们可以连接到服务器上的 PostgreSQL 数据库，但我们没有 shell 访问权限。我们必须在不同的 VM 上运行 Django。

让我们在`cloudformation/infrastructure.yaml`中为我们的 CloudFormation 模板添加一个 RDS 实例：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape Infrastructure
Parameters:
  ...
Resources:
  ...
  DatabaseServer:
    Type: AWS::RDS::DBInstance
    Properties:
      DBName: mailape
      DBInstanceClass: db.t2.micro
      MasterUsername: master
      MasterUserPassword: !Ref MasterDBPassword
      Engine: postgres
      AllocatedStorage: 20
      PubliclyAccessible: true
      VPCSecurityGroups: !GetAtt DatabaseSecurityGroup.GroupId
```

我们新的 RDS 实例条目为`AWS::RDS::DBInstance`类型。让我们回顾一下我们设置的属性：

*   `DBName`：这是*服务器*的名称，不是其上运行的任何数据库的名称。
*   `DBInstanceClass`：定义服务器虚拟机的内存和处理能力。在写这本书的时候，`db.t2.micro`是账户第一年免费等级的一部分。
*   `MasterUsername`：这是服务器上特权管理员帐户的用户名。
*   `MasterUserPassword`：这是特权管理员帐户的密码
*   `!Ref MasterDBPassword`：这是引用`MasterDBPassword`参数的快捷语法。这可以避免硬编码数据库服务器的管理员密码。
*   `Engine`：这是我们想要的数据库服务器类型；在我们的例子中，`postgres`将为我们提供一个 PostgreSQL 服务器。
*   `AllocatedStorage`：表示服务器应有多少存储空间，单位为 GB。
*   `PubliclyAccessible`：表示是否可以从 AWS 云外部访问服务器。
*   `VPCSecurityGroups`：这是 SecurityGroup 的列表，指示哪些端口是开放的和可访问的。
*   `!GetAtt DatabaseSecurityGroup.GroupId`：返回`DatabaseSecurityGroup`安全组的`GroupID`属性。

这个模块还向我们介绍了 CloudFormation 的`Ref`和`GetAtt`函数。这两个函数都允许我们参考 CloudFormation 堆栈的其他部分，这一点非常重要。`Ref`让我们使用`MasterDBPassword`参数作为数据库服务器的`MasterUserPassword`值。`GetAtt`允许我们在数据库服务器的`VPCSercurityGroups`列表中引用`DatabaseSecurityGroup`的 AWS 生成的`GroupId`属性。

AWS CloudFormation 提供了多种不同的功能，使构建模板更容易。它们记录在 AWS 在线文件（[中 https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html) ）。

接下来，让我们创建芹菜将使用的 SQS 队列。

# 添加芹菜队列

SQS 是 AWS 消息队列服务。使用 SQS，我们可以创建一个不必维护的芹菜兼容的消息队列。SQS 可以快速扩展以处理我们发送的任意数量的请求。

要定义队列，请将其添加到`cloudformation/infrastructure.yaml`中的`Resources`块：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape Infrastructure
Parameters:
  ...
Resources:
  ...
  MailApeQueue:
    Type: "AWS::SQS::Queue"
    Properties:
      QueueName: mailape-celery
```

我们的新资源属于`AWS::SQS::Queue`类型，并具有单一属性`QueueName`。

接下来，让我们创建一个角色和 InstanceProfile，以允许生产服务器访问 SQS 队列。

# 为队列访问创建角色

前面，在*添加安全组*一节中，我们讨论了创建安全组以打开网络端口，以便建立网络连接。为了管理 AWS 资源之间的访问，我们需要使用基于角色的授权。在基于角色的授权中，我们定义一个角色，可以为谁分配该角色（假定该角色），以及该角色可以执行哪些操作。为了让 web 服务器使用该角色，我们需要创建一个与该角色关联的 EC2 实例概要文件。

让我们先在`cloudformation/infrastructure.yaml`中添加一个角色：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape Infrastructure
Parameters:
  ...
Resources:
  ...
   SQSAccessRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          -
            Effect: "Allow"
            Principal:
              Service:
                - "ec2.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      Policies:
        -
          PolicyName: "root"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              -
                Effect: Allow
                Action: "sqs:*"
                Resource: !GetAtt MailApeQueue.Arn
              -
                Effect: Allow
                Action: sqs:ListQueues
                Resource: "*"
```

我们的新大楼是`AWS::IAM::Role`型的。IAM 是 AWS 身份和访问管理服务的缩写。我们的角色由以下两个属性组成：

*   `AssumeRolePolicyDocument`：定义谁可以被分配这个角色。在我们的例子中，我们说这个角色可以由 Amazon 的 EC2 服务中的任何对象承担。稍后，我们将在 EC2 实例中使用它。
*   `Policies`：这是此角色允许（或拒绝）操作的列表。在我们的例子中，我们允许在先前定义的 SQS 队列上执行所有 SQS 操作（`sqs:*`。我们通过获取队列的`Arn`、**亚马逊资源名**（**ARN**）以及`GetAtt`功能来引用队列。ARN 是亚马逊为亚马逊云上的每种资源提供全球唯一 ID 的方式。

现在我们有了我们的角色，我们可以将其与一个`InstanceProfile`资源相关联，该资源可以与我们的 web 服务器相关联：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape Infrastructure
Parameters:
  ...
Resources:
  ...
  SQSClientInstance:
    Type: "AWS::IAM::InstanceProfile"
    Properties:
      Roles:
        - !Ref SQSAccessRole
```

我们的新 InstanceProfile 为`AWS::IAM::InstanceProfile`类型，需要关联角色列表。在我们的例子中，我们只是引用先前使用`Ref`函数创建的`SQSAccessRole`。

现在我们已经创建了基础设施资源，让我们输出数据库的地址和`InstanceProfile`资源的 ARN。

# 输出我们的资源信息

CloudFormation 模板可以有一个输出块，以便更容易地引用创建的资源。在本例中，我们将输出数据库服务器的地址和`InstanceProfile.`的 ARN

让我们在`cloudformation/infrastructure.yaml`中更新我们的云信息模板：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape Infrastructure
Parameters:
  ...
Resources:
  ...
Outputs:
  DatabaseDNS:
    Description: Public DNS of RDS database
    Value: !GetAtt DatabaseServer.Endpoint.Address
  SQSClientProfile:
    Description: Instance Profile for EC2 instances that need SQS Access
    Value: !GetAtt SQSClientInstance.Arn
```

在前面的代码中，我们使用`GetAtt`函数返回`DatabaseServer`资源的地址和`SQSClientInstance``InstanceProfile`资源的 ARN。

# 执行模板以创建资源

现在我们已经创建了`CloudFormation`模板，我们可以创建`CloudFormation`堆栈。当我们告诉 AWS 创建我们的`CloudFormation`堆栈时，它将在我们的模板中创建所有相关资源。

要创建模板，我们需要以下两件事：

*   AWS**命令行界面**（**CLI**）
*   AWS 访问密钥/秘密密钥对

我们可以使用`pip`安装 AWS CLI：

```py
$ pip install awscli
```

要获取（或创建）您的访问密钥/密钥对，您需要访问安全凭据（[https://console.aws.amazon.com/iam/home?region=us-AWS 控制台的 west-2#/security#u 凭证](https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential)部分。

然后，我们需要使用密钥和区域配置 AWS 命令行工具。`aws`命令提供了一个交互`configure`子命令来完成此操作。让我们在命令行上运行它：

```py
$ aws configure
AWS Access Key ID [None]: <Your ACCESS key>
AWS Secret Access Key [None]: <Your secret key>
Default region name [None]: us-west-2
Default output format [None]: json
```

`aws configure`命令将您在主目录的`.aws`目录中输入的值存储起来。

通过这些设置，我们现在可以创建堆栈：

```py
$ aws cloudformation create-stack \
    --stack-name "infrastructure" \
    --template-body "file:///path/to/mailape/cloudformation/infrastrucutre.yaml" \
    --capabilities CAPABILITY_NAMED_IAM \
    --parameters \
      "ParameterKey=MasterDBPassword,ParameterValue=password" \
    --region us-west-2
```

创建堆栈可能需要一些时间，因此命令将返回而不等待成功。让我们仔细看看我们的 To0t0 命令：

*   `--stack-name`：这是我们正在创建的堆栈的名称。每个帐户的堆栈名称必须是唯一的。
*   `--template-body`：这要么是模板本身，要么是模板文件的`file://`URL。记住，`file://`URL 需要文件的绝对路径。
*   `--capabilities CAPABILITY_NAMED_IAM`：这是创建或影响**身份和访问管理**（**IAM**服务的模板所必需的。这可以防止意外影响访问管理服务。
*   `--parameters`：这允许我们传入模板参数的值。在本例中，我们将数据库的主密码设置为`password`，这不是一个安全值。
*   `--region`：AWS 云组织为世界各地的区域集合。在我们的例子中，我们使用的是`us-west-2`，它位于美国俄勒冈州周围的一系列数据中心。

请记住，您需要为数据库设置一个安全的主密码。

要了解堆栈创建是如何进行的，我们可以使用 AWS Web 控制台（[进行检查 https://us-west-2.console.aws.amazon.com/cloudformation/home?region=us-west-2](https://us-west-2.console.aws.amazon.com/cloudformation/home?region=us-west-2)或使用命令行：

```py
$ aws cloudformation describe-stacks \
    --stack-name "infrastructure" \
    --region us-west-2
```

当堆栈创建完相关资源后，它将返回与以下类似的结果：

```py
{
    "Stacks": [
        {
            "StackId": "arn:aws:cloudformation:us-west-2:XXX:stack/infrastructure/NNN",
            "StackName": "infrastructure",
            "Description": "Mail Ape Infrastructure",
            "Parameters": [
                {
                    "ParameterKey": "MasterDBPassword",
                    "ParameterValue": "password"
                }
            ],
            "StackStatus": "CREATE_COMPLETE",
            "Outputs": [
                {
                    "OutputKey": "SQSClientProfile",
                    "OutputValue": "arn:aws:iam::XXX:instance-profile/infrastructure-SQSClientInstance-XXX",
                    "Description": "Instance Profile for EC2 instances that need SQS Access"
                },
                {
                    "OutputKey": "DatabaseDNS",
                    "OutputValue": "XXX.XXX.us-west-2.rds.amazonaws.com",
                    "Description": "Public DNS of RDS database"
                }
            ],
        }
    ]
}
```

`describe-stack`结果中需要特别注意的两件事如下：

*   `Parameters`键下的对象，它将以纯文本形式显示我们的主数据库密码
*   对象`Outputs`键，显示我们`InstanceProfile`资源的 ARN 和数据库服务器的地址

在前面的所有代码中，我将特定于我的帐户的值替换为 XXX。您的输出将不同。

如果要删除与堆栈关联的资源，只需删除堆栈：

```py
$ aws cloudformation delete-stack --stack-name "infrastructure"
```

接下来，我们将构建一个 Amazon 机器映像，用于在 AWS 中运行 Mail Ape。

# 使用 Packer 构建亚马逊机器形象

现在我们已经在 AWS 中运行了我们的基础设施，让我们构建我们的 MailApe 服务器。在 AWS 中，我们可以启动一个官方的 Ubuntu 虚拟机，按照[第 9 章](09.html)中的步骤，*应答部署*，并运行我们的 MailApe。然而，AWS 将 EC2 实例视为*短暂的*。如果一个 EC2 实例被终止，那么我们将不得不启动一个新实例并重新配置它。有几种方法可以缓解此问题。我们将通过为我们的发行版构建一个新的**亚马逊机器映像**（**AMI**）来解决短暂 EC2 实例的问题。然后，无论何时我们使用该 AMI 启动 EC2 实例，它都将得到完美配置。

我们将使用 HashiCorp 的打包工具自动构建 AMI。Packer 为我们提供了一种从 Packer 模板创建 AMI 的方法。打包器模板是一个 JSON 文件，它定义了将 EC2 实例配置为所需状态并保存 AMI 所需的步骤。为了运行我们的打包器模板，我们还将编写一组 shell 脚本来配置我们的 AMI。使用像 Packer 这样的工具，我们可以自动构建新的版本 AMI。

让我们先在机器上安装 Packer。

# 安装封隔器

从[上取封隔器 https://www.packer.io](https://www.packer.io) 下载页面。封隔器适用于所有主要平台。

接下来，我们将创建一个脚本，以创建我们在生产中所依赖的目录。

# 创建脚本以创建目录结构

我们将编写的第一个脚本将为所有代码创建目录。让我们在`scripts/make_aws_directories.sh`中为我们的项目添加以下脚本：

```py
#!/usr/bin/env bash
set -e

sudo mkdir -p \
    /mailape/ubuntu \
    /mailape/apache \
    /mailape/django \
    /var/log/celery \
    /etc/mailape \
    /var/log/mailape

sudo chown -R ubuntu /mailape
```

在前面的代码中，我们使用`mkdir`生成目录。接下来，我们想让`ubuntu`用户可以写入`/mailape`目录，这样我们就可以递归地`chown`到`/mailape`目录。

所以，让我们创建一个脚本来安装我们需要的 Ubuntu 软件包。

# 创建脚本以安装所有软件包

在我们的生产环境中，我们必须安装 Ubuntu 软件包以及我们已经列出的 Python 软件包。首先，让我们在`ubuntu/packages.txt`中列出我们所有的 Ubuntu 软件包：

```py
python3
python3-pip
python3-dev
virtualenv
apache2
libapache2-mod-wsgi-py3
postgresql-client
libcurl4-openssl-dev
libssl-dev
```

接下来，我们创建一个脚本来安装`scripts/install_all_packages`中的所有软件包：

```py
#!/usr/bin/env bash
set -e

sudo apt-get update
sudo apt install -y $(cat /mailape/ubuntu/packages.txt | grep -i '^[a-z]')

virtualenv -p $(which python3) /mailape/virtualenv
source /mailape/virtualenv/bin/activate

pip install -r /mailape/requirements.production.txt

sudo chown -R www-data /var/log/mailape \
    /etc/mailape \
    /var/run/celery \
    /var/log/celery
```

在前面的脚本中，我们将安装上面列出的 Ubuntu 软件包，然后创建一个`virtualenv`来隔离我们的 Mail Ape Python 环境和软件包。最后，我们给 Apache（即`www-data`用户）一些目录的所有权，以便它可以写入这些目录。我们无法给`www-data`用户所有权，因为在我们安装`apache2`软件包之前，他们可能不存在。

接下来，让我们配置运行 Apache2 以使用 mod_wsgi 运行 MailApe。

# 配置 Apache

现在，我们将添加 Apache mod_wsgi 配置，就像我们在[第 9 章](09.html)中所做的一样，*应答部署*。mod_wsgi 配置不是本章的重点，因此请参阅[章](09.html)第 9 节*应答部署*，了解此配置的工作原理。

让我们在`apache/mailape.apache.conf`中为 Mail Ape 创建一个虚拟主机配置文件：

```py
LogLevel info
WSGIRestrictEmbedded On

<VirtualHost *:80>

    WSGIDaemonProcess mailape \
        python-home=/mailape/virtualenv \
        python-path=/mailape/django \
        processes=2 \
        threads=2

    WSGIProcessGroup mailape

    WSGIScriptAlias / /mailape/django/config/wsgi.py
    <Directory /mailape/django/config>
        <Files wsgi.py>
            Require all granted
        </Files>
    </Directory>

    Alias /static/ /mailape/django/static_root
    <Directory /mailape/django/static_root>
        Require all granted
    </Directory>
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

</VirtualHost>
```

正如我们在[第 9 章](09.html)、*应答部署*中所讨论的，没有一种方法可以将环境变量传递给我们的 mod_wsgi Python 进程，因此我们需要更新项目的`wsgi.py`，就像我们在[第 9 章](09.html)、*应答部署*中所做的一样。

这是我们的新`django/config/wsgi.py`：

```py
import os
import configparser

from django.core.wsgi import get_wsgi_application

if not os.environ.get('DJANGO_SETTINGS_MODULE'):
    parser = configparser.ConfigParser()
    parser.read('/etc/mailape/mailape.ini')
    for name, val in parser['mod_wsgi'].items():
        os.environ[name.upper()] = val

application = get_wsgi_application()
```

我们在第 9 章*中讨论了前面的脚本*。这里唯一的区别是我们解析的文件，即`/etc/mailape/mailape.ini`。

接下来，我们需要将虚拟主机配置添加到 Apache`sites-enabled`目录中。让我们在`scripts/configure_apache.sh`中创建一个脚本：

```py
#!/usr/bin/env bash

sudo rm /etc/apache2/sites-enabled/*
sudo ln -s /mailape/apache/mailape.apache.conf /etc/apache2/sites-enabled/000-mailape.conf
```

现在我们已经有了在生产环境中配置 Apache 的脚本，让我们配置芹菜工人开始。

# 配置芹菜

既然 Apache 运行了 Mail Ape，我们就需要配置芹菜来启动和处理 SQS 队列。为了启动芹菜工人，我们将使用 Ubuntu 的 systemd 进程管理工具。

首先，让我们创建一个芹菜服务文件，告诉 SystemD 如何启动芹菜。我们将在`ubuntu/celery.service`中创建服务文件：

```py
[Unit]
Description=Mail Ape Celery Service
After=network.target

[Service]
Type=forking
User=www-data
Group=www-data
EnvironmentFile=/etc/mailape/celery.env
WorkingDirectory=/mailape/django
ExecStart=/bin/sh -c '/mailape/virtualenv/bin/celery multi start worker \
    -A "config.celery:app" \
    --logfile=/var/log/celery/%n%I.log --loglevel="INFO" \
    --pidfile=/run/celery/%n.pid'
ExecStop=/bin/sh -c '/mailape/virtualenv/bin/celery multi stopwait worker \
    --pidfile=/run/celery/%n.pid'
ExecReload=/bin/sh -c '/mailape/virtualenv/bin/celery multi restart worker \
   -A "config.celery:app" \
   --logfile=/var/log/celery/%n%I.log --loglevel="INFO" \
   --pidfile=/run/celery/%n.pid'

[Install]
WantedBy=multi-user.target
```

让我们仔细看看这个文件中的一些选项：

*   `After=network.target`：这意味着在我们的服务器连接到网络之前，SystemD 不应该启动此功能。
*   `Type=forking`：这意味着`ExecStart`命令最终将启动一个新进程，该进程将继续在其自己的进程 ID（PID）下运行。
*   `User`：表示将拥有芹菜流程的用户。在我们的例子中，我们将重用 Apache 的`www-data`用户。
*   `EnvironmentFile`：列出一个文件，该文件将读取环境变量和为所有`Exec`命令设置的值。我们列出了一个芹菜配置（`/mailape/ubuntu/celery.systemd.conf`）和一个 MailApe 配置（`/etc/mailape/celery.env`）。
*   `ExecStart`：这是启动芹菜的命令。在我们的例子中，我们开始多个芹菜工人。我们所有的芹菜命令都将基于工人创建的进程 ID 文件对他们进行操作。芹菜将用工人 ID 替换`%n`。
*   `ExecStop`：根据芹菜工人的 PID 文件，这是停止芹菜工人的命令。
*   `ExecReload`：这是重启芹菜工人的命令。芹菜支持`restart`命令，所以我们将使用它来执行重启。但是，此命令必须接收与我们的`ExecStart`命令相同的选项。

我们将把 PID 文件放在`/var/run/celery`中，但我们需要确保创建了目录。`/var/run`是一个特殊目录，不使用常规文件系统。我们需要创建一个配置文件来告诉 Ubuntu 创建`/var/run/celery`。让我们在`ubuntu/tmpfiles-celery.conf`中创建此文件：

```py
d    /run/celery   0755 www-data www-data - -
```

这告诉 Ubuntu 创建一个目录`/run/celery`，由 Apache 用户（`www-data`拥有。

最后，让我们创建一个脚本，将所有这些文件放在服务器的正确位置。我们将此脚本命名为`scripts/configure_celery.sh`：

```py
#!/usr/bin/env bash

sudo ln -s /mailape/ubuntu/celery.service /etc/systemd/system/celery.service
sudo ln -s /mailape/ubuntu/celery.service /etc/systemd/system/multi-user.target.wants/celery.service
sudo ln -s /mailape/ubuntu/tmpfiles-celery.conf /etc/tmpfiles.d/celery.conf
```

现在芹菜和 Apache 已经配置好了，让我们确保它们具有运行 Mail Ape 的正确环境配置

# 创建环境配置文件

我们的芹菜和 mod_wsgi Python 进程都需要从环境中提取配置信息，以连接到正确的数据库、SQS 队列和许多其他服务。这些是我们不想在版本控制系统中检查的设置和值（例如，密码）。但是，我们仍然需要在生产环境中设置它们。要创建定义流程将在其中运行的环境的文件，我们将在`scripts/make_mailape_environment_ini.sh`中创建脚本：

```py
#!/usr/bin/env bash

ENVIRONMENT="
DJANGO_ALLOWED_HOSTS=${WEB_DOMAIN}
DJANGO_DB_NAME=mailape
DJANGO_DB_USER=mailape
DJANGO_DB_PASSWORD=${DJANGO_DB_PASSWORD}
DJANGO_DB_HOST=${DJANGO_DB_HOST}
DJANGO_DB_PORT=5432
DJANGO_LOG_FILE=/var/log/mailape/mailape.log
DJANGO_SECRET_KEY=${DJANGO_SECRET}
DJANGO_SETTINGS_MODULE=config.production_settings
MAIL_APE_FROM_EMAIL=admin@blvdplatform.com
EMAIL_HOST=${EMAIL_HOST}
EMAIL_HOST_USER=mailape
EMAIL_HOST_PASSWORD=${EMAIL_HOST_PASSWORD}
EMAIL_HOST_PORT=587
EMAIL_HOST_TLS=true

INI_FILE="[mod_wsgi]
${ENVIRONMENT}
"

echo "${INI_FILE}" | sudo tee "/etc/mailape/mailape.ini"
echo "${ENVIRONMENT}" | sudo tee "/etc/mailape/celery.env"
```

我们的`make_mailape_environment_ini.sh`脚本有一些硬编码的值，但引用其他值（例如密码）作为环境变量。我们将在运行时将这些变量的值传递给 Packer。然后，Packer 将这些值传递给我们的脚本。

接下来，让我们制作打包器模板来构建 AMI。

# 制作封隔器模板

打包器根据打包器模板文件中列出的说明创建 AMI。打包器模板是由三个顶级键组成的 JSON 文件：

*   `variables`：这将允许我们在运行时设置值（如密码）
*   `builders`：指定特定于云平台的详细信息，如 AWS 凭证
*   `provisioners`：这是 Packer 为制作我们的图像而执行的指令

让我们在`packer/web_worker.json`中创建打包器模板，从`variables`部分开始：

```py
{
  "variables": {
    "aws_access_key": "",
    "aws_secret_key": "",
    "django_db_password":"",
    "django_db_host":"",
    "django_secret":"",
    "email_host":"",
    "email_host_password":"",
    "mail_ape_aws_key":"",
    "mail_ape_secret_key":"",
    "sqs_celery_queue":"",
    "web_domain":""
  }
}
```

在`variables`键下，我们将列出希望模板作为 JSON 对象键的所有变量。如果变量有一个默认值，那么我们可以提供它作为该变量的键的值。

接下来，让我们添加一个`builders section`来配置 Packer 以使用 AWS：

```py
{
  "variables": {...},
  "builders": [
    {
      "type": "amazon-ebs",
      "access_key": "{{user `aws_access_key`}}",
      "secret_key": "{{user `aws_secret_key`}}",
      "region": "us-west-2",
      "source_ami": "ami-78b82400",
      "instance_type": "t2.micro",
      "ssh_username": "ubuntu",
      "ami_name": "mailape-{{timestamp}}",
      "tags": {
        "project": "mailape"
      }
    }
  ]
}
```

`builders`是一个数组，因为我们可以使用相同的模板在多个平台（例如 AWS 和谷歌云）上构建机器映像。让我们仔细看看每一个选项：

*   `"type": "amazon-ebs"`：告诉 Packer 我们正在创建一个带有弹性块存储的亚马逊机器映像。这是首选配置，因为它提供了灵活性。
*   `"access_key": "{{user aws_access_key }}"`：这是封隔器应使用的访问密钥，用于向 AWS 进行身份验证。Packer 包含自己的模板语言，因此可以在运行时生成值。`{{ }}`之间的任何值都由打包机模板引擎生成。模板引擎提供了一个`user`函数，它接受用户提供的变量的名称并返回其值。例如，`{{user aws_access_key }}`将替换为用户在运行打包机时提供给`aws_access_key`的值。
*   `"secret_key": "{{user aws_secret_key }}"`：AWS 密钥也是如此。
*   `"region": "us-west-2"`：指定 AWS 区域。我们所有的工作都将在`us-west-2`中完成。
*   `"source_ami": "ami-78b82400"`：这是我们将要定制的图像，以制作我们的图像。在我们的例子中，我们使用的是官方的 Ubuntu AMI。Ubuntu 提供了一个 EC2 AMI 定位器（[http://cloud-images.ubuntu.com/locator/ec2/](http://cloud-images.ubuntu.com/locator/ec2/) 帮助找到他们的办公室 AMI。
*   `"instance_type": "t2.micro"`：这是一个便宜的小例子，在撰写本书时，它属于 AWS 免费层。
*   `"ssh_username": "ubuntu"`：Packer 通过 SSH 在虚拟机上执行其所有操作。这是用于身份验证的用户名。Packer 将为身份验证生成自己的密钥对，因此我们不必担心指定密码或密钥。
*   `"ami_name": "mailape-{{timestamp}}"`：生成的 AMI 的名称。`{{timestamp}}`是一个函数，返回自 Unix 纪元以来的 UTC 时间（以秒为单位）。
*   `"tags": {...}`：标记资源使 AWS 中的资源更容易识别。这是可选的，但建议使用。

现在我们已经指定了 AWS 生成器，我们需要指定供应器。

打包器供应器是定制服务器的指令。在我们的案例中，我们将使用以下两种类型的供应器：

*   `file`供应商将我们的代码上传到服务器
*   `shell`提供程序来执行我们的脚本和命令

首先，让我们添加我们的`make_aws_directories.sh`脚本，因为我们需要它首先运行：

```py
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    {
      "type": "shell",
      "script": "{{template_dir}}/../scripts/make_aws_directories.sh"
    }
  ]
}
```

具有`script`属性的`shell`供应器将上载、执行和删除脚本。打包器提供`{{template_dir}}`功能，返回模板目录的目录。这可以避免硬编码绝对路径。我们执行的第一个 provisioner 将执行我们在本节前面创建的`make_aws_directories.sh`脚本。

现在我们的目录已经存在，让我们使用`file`供应器复制代码和文件：

```py
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    ...,
    {
      "type": "file",
      "source": "{{template_dir}}/../requirements.common.txt",
      "destination": "/mailape/requirements.common.txt"
    },
    {
      "type": "file",
      "source": "{{template_dir}}/../requirements.production.txt",
      "destination": "/mailape/requirements.production.txt"
    },
    {
      "type": "file",
      "source": "{{template_dir}}/../ubuntu",
      "destination": "/mailape/ubuntu"
    },
    {
      "type": "file",
      "source": "{{template_dir}}/../apache",
      "destination": "/mailape/apache"
    },
    {
      "type": "file",
      "source": "{{template_dir}}/../django",
      "destination": "/mailape/django"
    },
  ]
}
```

`file`供应商将`source`定义的本地文件或目录上传到`destination`服务器。

因为我们从工作目录上传了 Python 代码，所以我们需要小心旧的`.pyc`文件。让我们确保删除生产服务器上的内容：

```py
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    ...,
   {
      "type": "shell",
      "inline": "find /mailape/django -name '*.pyc' -delete"
   },
   ]
}
```

`shell`供应器可以接收`inline`属性。然后，供应器将在服务器上执行`inline`命令。

最后，让我们执行我们创建的其余脚本：

```py
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    ...,
    {
      "type": "shell",
      "scripts": [
        "{{template_dir}}/../scripts/install_all_packages.sh",
        "{{template_dir}}/../scripts/configure_apache.sh",
        "{{template_dir}}/../scripts/make_mailape_environment_ini.sh",
        "{{template_dir}}/../scripts/configure_celery.sh"
        ],
      "environment_vars": [
        "DJANGO_DB_HOST={{user `django_db_host`}}",
        "DJANGO_DB_PASSWORD={{user `django_db_password`}}",
        "DJANGO_SECRET={{user `django_secret`}}",
        "EMAIL_HOST={{user `email_host`}}",
        "EMAIL_HOST_PASSWORD={{user `email_host_password`}}",
        "WEB_DOMAIN={{user `web_domain`}}"
      ]
}
```

在此情况下，`shell`提供人已收到`scripts`和`environment_vars`。`scripts`是指向 shell 脚本的路径数组。将上载并执行阵列中的每个项目。在执行每个脚本时，此`shell`供应器将添加`environment_vars`中列出的环境变量。`environment_vars`参数可供所有`shell`供应器选择，以提供额外的环境变量。

随着我们的最终供应器添加到我们的文件中，我们现在已经完成了打包器模板。让我们使用 Packer 来执行模板并构建 Mail Ape 生产服务器。

# 运行 Packer 构建亚马逊机器形象

安装了 Packer 并创建了 Mail Ape 生产服务器 Packer 模板后，我们准备构建我们的**亚马逊机器映像**（**AMI**。

让我们运行 Packer 来构建我们的 AMI：

```py
$ packer build \
    -var "aws_access_key=..." \
    -var "aws_secret_key=..." \
    -var "django_db_password=..." \
    -var "django_db_host=A.B.us-west-2.rds.amazonaws.com" \
    -var "django_secret=..." \
    -var "email_host=smtp.example.com" \
    -var "email_host_password=..." \
    -var "web_domain=mailape.example.com" \
    packer/web_worker.json
Build 'amazon-ebs' finished.

==> Builds finished. The artifacts of successful builds are:
--> amazon-ebs: AMIs were created:
us-west-2: ami-XXXXXXXX
```

打包器将输出新 AMI 映像的 AMI ID。我们将能够使用此 AMI 在 AWS 云中启动 EC2 实例。

如果模板由于缺少 Ubuntu 包而失败，请重试构建。在撰写本书时，Ubuntu 软件包存储库并不总是能够成功更新。

现在我们有了 AMI，我们可以部署它了。

# 在 AWS 上部署可扩展的自愈 web 应用程序

既然我们有了基础设施和可部署的 AMI，我们就可以在 AWS 上部署 Mail Ape 了。我们将使用 CloudFormation 部署应用程序，而不是从 AMI 启动单个 EC2 实例。我们将定义一组资源，使我们能够根据需要上下扩展应用程序。我们将定义以下三种资源：

*   在 EC2 实例之间分配请求的弹性负载平衡器
*   用于启动和终止 EC2 实例的自动缩放组
*   一个 LaunchConfig，用于描述要启动的 EC2 实例类型

首先，如果我们需要访问任何 EC2 实例来解决部署后的任何问题，那么让我们确保我们有一个 SSH 密钥。

# 创建 SSH 密钥对

要在 AWS 中创建 SSH 密钥对，我们可以使用以下 AWS 命令行：

```py
$ aws ec2 create-key-pair --key-name mail_ape_production --region us-west-2
{
    "KeyFingerprint": "XXX",
    "KeyMaterial": "-----BEGIN RSA PRIVATE KEY-----\nXXX\n-----END RSA PRIVATE KEY-----",
    "KeyName": "tom-cli-test"
}
```

确保将`KeyMaterial`值复制到 SSH 客户端的配置目录（通常为`~/.ssh`）——记住用实际的新行替换`\n`。

接下来，让我们开始我们的 Mail Ape 部署 CloudFormation 模板。

# 创建 web 服务器云信息模板

接下来，让我们创建一个 CloudFormation 模板，将 MailApe 服务器部署到云中。我们将使用 CloudFormation 告诉 AWS，如果发生灾难，如何扩展我们的服务器并重新启动它们。我们将告诉 CloudFormation 创建以下三种资源：

*   一个**弹性负载平衡器**（**ELB**），能够在我们的服务器之间分配请求
*   一个 LaunchConfig，它将描述我们想要使用的 EC2 实例的 AMI、实例类型和其他细节。
*   一个自动缩放组，它将进行监视，以确保我们拥有正确数量的正常 EC2 实例。

这三种资源是构建任何类型的可伸缩自愈 AWS 应用程序的核心。

让我们在`cloudformation/web_worker.yaml`中开始构建我们的 CloudFormation 模板。我们的新模板将具有与`cloudformation/infrastracture.yaml`相同的三个部分：`Parameters`、`Resources`和`Outputs`。

让我们从添加`Parameters`部分开始。

# 接受 web worker CloudFormation 模板中的参数

我们的 web worker CloudFormation 模板将接受要启动的 AMI 和要用作参数的 InstanceProfile。这意味着我们不必分别对使用 Packer 和基础结构堆栈创建的资源的名称进行硬编码。

让我们在`cloudformation/web_worker.yaml`中创建我们的模板：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape web worker
Parameters:
  WorkerAMI:
    Description: Worker AMI
    Type: String
  InstanceProfile:
    Description: the instance profile
    Type: String
```

现在我们有了 EC2 实例的 AMI 和 InstanceProfile，让我们创建 CloudFormation 堆栈的资源。

# 在我们的 web worker CloudFormation 模板中创建资源

接下来，我们将确定**弹性负载平衡器**（**ELB**）、启动配置和自动校准组。这三种资源是大多数可伸缩 AWS web 应用程序的核心。在构建模板时，我们将了解它们是如何交互的。

首先，让我们添加负载平衡器：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape web worker
Parameters:
  ...
Resources:
  LoadBalancer:
    Type: "AWS::ElasticLoadBalancing::LoadBalancer"
    Properties:
      LoadBalancerName: MailApeLB
      Listeners:
        -
          InstancePort: 80
          LoadBalancerPort: 80
          Protocol: HTTP
```

在前面的代码中，我们添加了一个名为`LoadBalancer`的`AWS::ElasticLoadBalancing::LoadBalancer`类型的新资源。ELB 需要名称（`MailApeLB`和`Listeners`列表。每个`Listeners`条目应定义我们的 ELB 正在侦听的端口（`LoadBalancerPort`、请求将转发到的实例端口（`InstancePort`）以及端口将使用的协议（在我们的示例中为`HTTP`）。

ELB 将负责跨我们为处理负载而启动的多个 EC2 实例分发 HTTP 请求。

接下来，我们将创建一个 LaunchConfig 来告诉 AWS 如何启动新的 Mail Ape web worker：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape web worker
Parameters:
  ...
Resources:
  LoadBalancer:
    ...
  LaunchConfig:
    Type: "AWS::AutoScaling::LaunchConfiguration"
    Properties:
      ImageId: !Ref WorkerAMI
      KeyName: mail_ape_production
      SecurityGroups:
        - ssh-access
        - web-access
      InstanceType: t2.micro
      IamInstanceProfile: !Ref InstanceProfile
```

启动配置为`AWS::AutoScaling::LaunchConfiguration`类型，描述自动缩放组应启动的新 EC2 实例的配置。让我们通过所有的`Properties`来确保我们理解它们的含义：

*   `ImageId`：这是我们希望实例运行的 AMI 的 ID。在本例中，我们使用`Ref`函数从`WorkerAMI`参数获取 AMI ID。
*   `KeyName`：这是将添加到此计算机的 SSH 密钥的名称。这是有用的，如果我们需要解决一些生活。在本例中，我们使用本章前面创建的 SSH 密钥对的名称。
*   `SecurityGroups`：这是定义 AWS 要打开哪些端口的安全组名称列表。在本例中，我们列出了在基础架构堆栈中创建的 web 组和 SSH 组的名称。
*   `InstanceType`：表示我们 EC2 实例的实例类型。实例类型定义了 EC2 实例可用的计算和内存资源。在我们的例子中，我们使用的是一个非常小的价格合理的实例（在撰写本书时），在第一年 AWS 免费层就涵盖了这个实例。
*   `IamInstanceProfile`：表示 EC2 实例的`InstanceProfile`。这里，我们使用`Ref`函数来引用`InstanceProfile`参数。当我们创建堆栈时，我们将使用前面创建的 InstanceProfile 的 ARN，该文件允许 EC2 实例访问 SQS。

接下来，我们将定义自动缩放组，该组启动启动配置中描述的 EC2 实例，以服务 ELB 转发的请求：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape web worker
Parameters:
  ...
Resources:
  LoadBalancer:
    ...
  LaunchConfig:
    ...
  WorkerGroup:
    Type: "AWS::AutoScaling::AutoScalingGroup"
    Properties:
      LaunchConfigurationName: !Ref LaunchConfig
      MinSize: 1
      MaxSize: 3
      DesiredCapacity: 1
      LoadBalancerNames:
        - !Ref LoadBalancer
```

我们新的**自动缩放组**（**ASG**为`AWS::AutoScaling::AutoScalingGroup`型。让我们看看它的属性：

*   `LaunchConfigurationName`：这是 ASG 在启动新实例时应该使用的`LaunchConfiguration`名称。在我们的例子中，我们使用`Ref`函数来引用`LaunchConfig`，即我们在上面创建的启动配置。
*   `MinSize`/`MaxSize`：这些是设置此组可能包含的最大和最小实例数所需的属性。这些值保护我们避免意外部署过多实例，从而对系统或每月账单产生负面影响。在我们的例子中，我们确保至少有一个（`1`）实例，但不超过三个（`3`）。
*   `DesiredCapacity`：这告诉我们的系统应该有多少 ASG 和多少健康的 EC2 实例运行这个 ASG。如果一个实例失败，并且健康实例的数量低于`DesiredCapacity`值，那么 ASG 将使用其启动配置来启动更多实例。
*   `LoadBalancerNames`：这是一个 ELB 列表，可以将请求路由到此 ASG 启动的实例。当一个新的 EC2 实例成为该 ASG 的一部分时，它也将被添加到命名 ELBs 路由请求的实例列表中。在我们的例子中，我们使用`Ref`函数来引用我们在本模板前面定义的 ELB。

这三个工具共同帮助我们快速、顺利地扩展 Django 应用程序。ASG 为我们提供了一种方式，告诉我们需要运行多少 Mail Ape EC2 实例。启动配置描述如何启动新的 Mail Ape EC2 实例。然后，ELB 将请求分发到 ASG 启动的所有实例。

现在我们有了资源，让我们输出一些最相关的数据，以简化其余的部署。

# 输出资源名称

我们将添加到 CloudFormation 模板的最后一部分是`Outputs`，以便更容易地记录我们的 ELB 地址和 ASG 名称。我们需要我们的 ELB 地址才能将 CNAME 记录添加到`mailape.example.com`。如果需要访问实例（例如，运行迁移），我们需要 ASG 的名称。

让我们用`Outputs`部分更新`cloudformation/web_worker.yaml`：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape web worker
Parameters:
  ...
Resources:
  LoadBalancer:
    ...
  LaunchConfig:
    ...
  WorkerGroup:
    ...
Outputs:
  LoadBalancerDNS:
    Description: Load Balancer DNS name
    Value: !GetAtt LoadBalancer.DNSName
  AutoScalingGroupName:
    Description: Auto Scaling Group name
    Value: !Ref WorkerGroup
```

`LoadBalancerDNS`的值将是我们在上面创建的 ELB 的 DNS 名称。`AutoScalingGroupName`的值将是我们的 ASG，它返回 ASG 的名称。

接下来，让我们为 Mail Ape 1.0 版本创建一个堆栈。

# 创建 Mail Ape 1.0 发行版堆栈

现在我们有了 Mail Ape web worker CloudFormation 模板，我们可以创建一个 CloudFormation 堆栈。当我们创建堆栈时，堆栈将创建其相关资源，如 ELB、ASG 和启动配置。我们将使用 AWS CLI 创建堆栈：

```py
$ aws cloudformation create-stack \
    --stack-name "mail_ape_1_0" \
    --template-body "file:///path/to/mailape/cloudformation/web_worker.yaml" \
    --parameters \
      "ParameterKey=WorkerAMI,ParameterValue=AMI-XXX" \
      "ParameterKey=InstanceProfile,ParameterValue=arn:aws:iam::XXX:instance-profile/XXX" \
    --region us-west-2
```

前面的命令看起来与我们创建基础架构堆栈时执行的命令非常相似，但有两个不同之处：

*   `--stack-name`：这是我们正在创建的堆栈的名称。
*   `--template-body "file:///path/..."`：这是一个`file://`URL，具有指向我们 CloudFormation 模板的绝对路径。由于路径前缀以两个`/`结尾，Unix 路径以一个`/`开头，因此我们在这里得到了一个奇怪的三元组`/`。
*   `--parameters`：此模板有两个参数。我们可以按任何顺序提供，但我们必须同时提供。
*   `"ParameterKey=WorkerAMI, ParameterValue=`：对于`WorkerAMI`，我们必须提供 Packer 给我们的 AMI ID。
*   `"ParameterKey=InstanceProfile,ParameterValue`：对于 InstanceProfile，我们必须提供基础架构堆栈输出的实例配置文件 ARN。
*   `--region us-west-2`：我们在`us-west-2`区域开展所有工作。

要查看堆栈的输出，我们可以使用 AWS CLI 中的`describe-stack`命令：

```py
$ aws cloudformation describe-stacks \
    --stack-name mail_ape_1_0 \
    --region us-west-2
```

结果是一个大的 JSON 对象；下面是一个略为截断的示例版本：

```py
{
    "Stacks": [
        {
            "StackId": "arn:aws:cloudformation:us-west-2:XXXX:stack/mail_ape_1_0/XXX",
            "StackName": "mail_ape_1_0",
            "Description": "Mail Ape web worker",
            "Parameters": [
                {
                    "ParameterKey": "InstanceProfile",
                    "ParameterValue": "arn:aws:iam::XXX:instance-profile/XXX"
                },
                {
                    "ParameterKey": "WorkerAMI",
                    "ParameterValue": "ami-XXX"
                }
            ],
            "StackStatus": "CREATE_COMPLETE",
            "Outputs": [
                {
                    "OutputKey": "AutoScalingGroupName",
                    "OutputValue": "mail_ape_1_0-WebServerGroup-XXX",
                    "Description": "Auto Scaling Group name"
                },
                {
                    "OutputKey": "LoadBalancerDNS",
                    "OutputValue": "MailApeLB-XXX.us-west-2.elb.amazonaws.com",
                    "Description": "Load Balancer DNS name"
                }
            ],
        }
    ]
}
```

我们的资源（例如 EC2 实例）在`StackStatus`为`CREATE_COMPLETE`之前不会准备就绪。创建所有相关资源可能需要几分钟的时间。

我们对`Outputs`数组中的对象特别感兴趣：

*   第一个值给出了 ASG 的名称。有了 ASG 的名称，我们将能够在该 ASG 中找到 EC2 实例，以防需要 SSH 将其整合到一个实例中。
*   第二个值为我们提供 ELB 的 DNS 名称。我们将使用 ELB 的 DNS 为生产 DNS 记录创建 CNAME 记录，以便在此处重定向流量（例如，为`mailape.example.com`创建 CNAME 记录以将流量重定向到 ELB）。

让我们看看如何使用 SSH 连接到 ASG 启动的 EC2 实例中。

# SSHing 到 Mail Ape EC2 实例中

AWS CLI 为我们提供了许多获取 EC2 实例信息的方法。让我们查找已启动的 EC2 实例的地址：

```py
$ aws ec2 describe-instances \
 --region=us-west-2 \
 --filters='Name=tag:aws:cloudformation:stack-name,Values=mail_ape_1_0' 
```

`aws ec2 describe-instances`命令将返回有关所有 EC2 实例的大量信息。我们可以使用`--filters`命令来限制返回的 EC2 实例。当我们创建一个堆栈时，许多相关的资源都被标记为堆栈名。这让我们只过滤`mail_ape_1_0`堆栈中的那些 EC2 实例。

以下是输出的（大幅）缩短版本：

```py
{
  "Reservations": [
    {
      "Groups": [],
      "Instances": [
        {
          "ImageId": "ami-XXX",
          "InstanceId": "i-XXX",
          "InstanceType": "t2.micro",
          "KeyName": "mail_ape_production",
          "PublicDnsName": "ec2-XXX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com",
          "PublicIpAddress": "XXX",
          "State": {
            "Name": "running"
          },
          "IamInstanceProfile": {
            "Arn": "arn:aws:iam::XXX:instance-profile/infrastructure-SQSClientInstance-XXX"
          },
          "SecurityGroups": [
            {
              "GroupName": "ssh-access"
            },
            {
              "GroupName": "web-access"
            }
          ],
          "Tags": [
            {
              "Key": "aws:cloudformation:stack-name",
              "Value": "mail_ape_1_0"
            } ] } ] } ] }
```

在前面的输出中，注意`PublicDnsName`和`KeyName`。由于我们在本章前面创建了该密钥，因此我们可以使用 SSH 连接到此实例：

```py
$ ssh -i /path/to/saved/ssh/key ubuntu@ec2-XXX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com
```

请记住，您在前面的输出中看到的`XXX`将被系统中的实际值替换。

现在我们可以使用 SSH 连接到系统中，我们可以创建和迁移数据库。

# 创建和迁移数据库

对于我们的第一个版本，我们首先需要创建数据库。为了创建我们的数据库，我们将在`database/make_database.sh`中创建一个脚本：

```py
#!/usr/bin/env bash

psql -v ON_ERROR_STOP=1 postgresql://$USER:$PASSWORD@$HOST/postgres <<-EOSQL
    CREATE DATABASE mailape;
    CREATE USER mailape;
    GRANT ALL ON DATABASE mailape to "mailape";
    ALTER USER mailape PASSWORD '$DJANGO_DB_PASSWORD';
    ALTER USER mailape CREATEDB;
EOSQL
```

此脚本使用其环境中的三个变量：

*   `$USER`：Postgres master 用户用户名。我们在`cloudformation/infrastructure.yaml`中将其定义为`master`。
*   `$PASSWORD`：Postgres master 用户密码。我们在创建`infrastructure`堆栈时提供了这个参数。
*   `$DJANGO_DB_PASSWORD`：这是 Django 数据库的密码。我们在创建 AMI 时将其作为参数提供给 Packer。

接下来，我们将通过将值作为变量提供，在本地执行此脚本：

```py
$ export USER=master
$ export PASSWORD=...
$ export DJANGO_DB_PASSWORD=...
$ bash database/make_database.sh
```

我们的 MailApe 数据库现在已创建。

接下来，让我们使用 SSH 连接到新的 EC2 实例并运行数据库迁移：

```py
$ ssh -i /path/to/saved/ssh/key ubuntu@ec2-XXX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com
$ source /mailape/virtualenv/bin/activate
$ cd /mailape/django
$ export DJANGO_DB_NAME=mailape
$ export DJANGO_DB_USER=mailape
$ export DJANGO_DB_PASSWORD=...
$ export DJANGO_DB_HOST=XXX.XXX.us-west-2.rds.amazonaws.com
$ export DJANGO_DB_PORT=5432
$ export DJANGO_LOG_FILE=/var/log/mailape/mailape.log
$ export DJANGO_SECRET_KEY=...
$ export DJANGO_SETTINGS_MODULE=config.production_settings
$ python manage.py migrate
```

我们的`manage.py migrate`命令与前面章节中使用的非常相似。这里的主要区别是，我们需要先将 SSH 连接到生产 EC2 实例中。

当`migrate`返回成功时，我们的数据库已准备就绪，我们可以发布我们的应用程序。

# 发布邮件 APE1.0

现在我们已经迁移了数据库，我们准备更新`mailape.example.com`的 DNS 记录，以指向我们的 ELB 的 DNS 记录。一旦 DNS 记录传播，MailApe 将处于活动状态。

祝贺

# 使用更新堆栈进行上下缩放

使用 CloudFormation 和自动缩放组的一个好处是可以轻松地上下缩放系统。在本节中，让我们更新系统以使用两个运行 Mail Ape 的 EC2 实例。

我们可以在`cloudformation/web_worker.yaml`中更新我们的云信息模板：

```py
AWSTemplateFormatVersion: "2010-09-09"
Description: Mail Ape web worker
Parameters:
  ..
Resources:
  LoadBalancer:
    ...
  LaunchConfig:
    ...
  WorkerGroup:
    Type: "AWS::AutoScaling::AutoScalingGroup"
    Properties:
      LaunchConfigurationName: !Ref LaunchConfig
      MinSize: 1
      MaxSize: 3
      DesiredCapacity: 2
      LoadBalancerNames:
        - !Ref LoadBalancer
Outputs:
  ..
```

我们已将`DesiredCapacity`从 1 更新为 2。现在，让我们更新现有堆栈，而不是创建新堆栈：

```py
$ aws cloudformation update-stack \
    --stack-name "mail_ape_1_0" \
    --template-body "file:///path/to/mailape/cloudformation/web_worker.yaml" \
    --parameters \
      "ParameterKey=WorkerAMI,UsePreviousValue=true" \
      "ParameterKey=InstanceProfile,UsePreviousValue=true" \
    --region us-west-2
```

前面的命令看起来很像我们的`create-stack`命令。一个方便的区别是，我们不需要再次提供参数值，我们可以简单地通知`UsePreviousValue=true`让 AWS 像以前一样重复使用相同的值。

同样，`describe-stack`将在更新完成时告诉我们：

```py
aws cloudformation describe-stacks \
    --stack-name mail_ape_1_0 \
    --region us-west-2
```

结果是一个大型 JSON 对象，这里是一个被截断的示例版本：

```py
{
    "Stacks": [
        {
            "StackId": "arn:aws:cloudformation:us-west-2:XXXX:stack/mail_ape_1_0/XXX",
            "StackName": "mail_ape_1_0",
            "Description": "Mail Ape web worker",
            "StackStatus": "UPDATE_COMPLETE"
        }
    ]
}
```

一旦我们的`StackStatus`为`UPDATE_COMPLETE`，我们的 ASG 将更新为新设置。ASG 启动新的 EC2 实例可能需要几分钟的时间，但我们可以使用之前创建的`describe-instances`命令来查找它：

```py
$ aws ec2 describe-instances \
 --region=us-west-2 \
 --filters='Name=tag:aws:cloudformation:stack-name,Values=mail_ape_1_0'
```

最终，它将返回两个实例。以下是该输出的高度截断版本：

```py
{
  "Reservations": [
    {
      "Groups": [],
      "Instances": [
        {
          "ImageId": "ami-XXX",
          "InstanceId": "i-XXX",
          "PublicDnsName": "ec2-XXX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com",
          "State": { "Name": "running" }
        },
        {
          "ImageId": "ami-XXX",
          "InstanceId": "i-XXX",
          "PublicDnsName": "ec2-XXX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com",
          "State": { "Name": "running" }
        } ] } ] }
```

要缩小到一个实例，只需更新`web_worker.yaml`模板并再次运行`update-stack`。

祝贺现在，您知道了如何向上扩展 Mail Ape 以处理更高的负载，然后在非高峰时段向下扩展。

请记住，亚马逊的收费是以使用量为基础的。如果你在阅读这本书的过程中按比例放大，请记住缩小比例，否则你可能会被收取比预期更多的费用。确保您阅读了[上 AWS 自由层的限制 https://aws.amazon.com/free/](https://aws.amazon.com/free/) 。

# 总结

在本章中，我们使用了 Mail Ape 应用程序，并将其发布到 AWS 云中的生产环境中。我们已经使用 AWS CloudFormation 将我们的 AWS 资源声明为代码，使跟踪我们需要的内容和更改的内容与跟踪代码库其余部分一样容易。我们已经构建了使用 Packer 运行的 Mail Ape 服务器的映像，再次使我们能够以代码形式跟踪服务器配置。最后，我们将 Mail Ape 发布到云中，并学习如何上下扩展它。

现在，我们已经结束了学习构建 Django web 应用程序的旅程，让我们回顾一下我们所学到的一些内容。在三个项目中，我们看到了 Django 如何将代码组织到模型、视图和模板中。我们已经学习了如何使用 Django 的表单类和 Django Rest 框架的序列化程序类进行输入验证。我们已经研究了安全最佳实践、缓存以及如何发送电子邮件。我们已经了解了如何将代码部署到 Linux 服务器、Docker 容器和 AWS 云中。

您已经准备好接受您的想法并与 Django 一起发布它！去争取吧