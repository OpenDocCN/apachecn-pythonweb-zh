# 第一章即时烧瓶 Web 开发

欢迎来到*即时烧瓶网站开发*。我们将使用 Flask 逐步了解 Python 编程语言中的 web 开发，Flask 是一个小型但具有表达能力的框架，它提供了基本要素并使您能够构建自己的代码模式。我们将构建一个简单的日程安排应用程序来跟踪约会，包括一个数据库和一个用户界面，我们将一次构建一个。我们将自下而上构建我们的应用程序，您将在后面的章节中看到所有内容是如何组合在一起的。这种自下而上的方法将为您提供使用 Flask 增长项目所需的构建块。

# 准备开发（简单）

我们开始探索 Flask web 编程，将一切都放在它的位置上，用 Python 建立一个开发环境。

## 准备好了吗

请访问[python.org](http://python.org)获取 python。我们的应用程序将在 Python2.7 和 Python3.3+上运行。一旦拥有 Python，您就不需要对开发机器进行管理访问，甚至可以根据[Python.org](http://python.org)上的安装说明为您的用户安装 Python。

## 怎么做。。。

Python 项目可以使用**virtualenv**管理包，这是机器上专用于特定项目的用户可写区域。您可以在 Unix/Unix 类系统、Mac OS X 和 Windows 上使用 virtualenv。

我们将使用命令行启动并运行 virtualenv，然后讨论开发环境中需要的工具。在开始之前，请注意*中的*常见错误以及如何解决这些错误*小节还有更多。。。*部分，以防遇到问题。

Unix 风格的系统附带一个终端仿真器，我们将在本书中使用它。在 Unix、类 Unix 系统和 Mac OS X 上安装 Flask 所需的步骤如下：

1.  在您希望项目所在的目录中打开终端。
2.  从`pypi.python.org/pypi/virtualenv/1.9.1`下载 virtualenv。在终端中，您可以使用`curl -O https://pypi.python.org/packages/source/v/virtualenv/virtualenv-1.9.1.tar.gz`进行此操作。
3.  使用`tar xvzf virtualenv-1.9.1.tar.gz`解包 virtualenv。
4.  使用`python virtualenv-1.9.1/virtualenv.py env`创建一个名为`env`的 virtualenv 工具。你可以用任何你喜欢的名字；只需确保根据您选择的名称在此处的命令中进行更改。
5.  使用`. env/bin/activate`激活 virtualenv 工具。
6.  用`pip install Flask`安装烧瓶。
7.  验证烧瓶是否安装了简单的烟雾测试`python -m flask.config`。如果安装了烧瓶，则不会显示任何内容。

您可以通过`deactivate`关闭 VirtualNV，继续将终端用于其他项目。在您恢复 Flask 项目的任何时候，使用`. path/to/env/bin/activate`再次激活 virtualenv。`.`命令源于激活脚本，以设置指向 virtualenv 中`python`可执行文件的环境变量，并启用安装在其中的包的导入。

对于 Windows，我们将使用`cmd.exe`。在 Windows 上安装 Flask 的步骤如下：

1.  确保 Python 安装及其`scripts`目录（默认为`C:\Python33\`和`C:\Python33\Scripts\`在您当前的`PATH`变量中。如果您使用的是 Python 2.7，请使用`Python27`，并注意 Windows 在`PATH`中的目录之间使用分号。使用`echo %PATH%`查看您的`PATH`变量。一般情况下，导航到**计算机****属性****高级****环境变量**编辑`PATH`。
2.  在希望项目所在的目录中打开 shell。从历史上看，您可能会遇到在文件路径中的空格上失败的脚本，这就是为什么`C:\Python27\`优先于`C:\Program Files\Python27\`；如果您看到奇怪的错误，请记住这一点。
3.  从[下载`virtualenv.py`https://raw.github.com/pypa/virtualenv/1.9.1/virtualenv.py](https://raw.github.com/pypa/virtualenv/1.9.1/virtualenv.py) 到同一目录。
4.  用`python virtualenv.py env`创建一个名为`env`的 virtualenv。你可以用任何你喜欢的名字；只需确保根据您选择的名称在此处的命令中进行更改。
5.  使用`env\Scripts\activate.bat`激活 virtualenv。
6.  用`pip install Flask`安装烧瓶。
7.  验证烧瓶是否安装了简单的烟雾测试`python -m flask.config`。如果安装了烧瓶，则不会显示任何内容。

您可以通过`deactivate`关闭 virtualenv 工具，继续对其他项目使用命令提示符。在恢复 Flask 项目的工作时，请使用`env\Scripts\activate.bat`再次激活 virtualenv 工具，这是一个批处理文件，用于设置指向 virtualenv 中 python 可执行文件的环境变量，并启用安装在其中的包的导入。

### 提示

如果您使用的是 Windows，您可以通过参考[technet.microsoft.com/en-us/library/bb978526.aspx](http://technet.microsoft.com/en-us/library/bb978526.aspx)来使用 PowerShell 以获得更丰富的命令行环境，或者如果您没有访问 PowerShell 的权限，可以通过参考[docs.python.org/2/using/Windows.html](http://docs.python.org/2/using/windows.html)来使用`cmd.exe`。

## 它是如何工作的。。。

Python 本身在其标准库中附带了大量实用程序。有了现成的 Python，您可以立即使用[docs.Python.org/2/library/](http://docs.python.org/2/library/)中列出的任何代码。Python 解释器有几个始终可用的函数和对象，还有几个函数和对象在导入语句中可用，如图所示：

```py
import antigravity
```

Python 社区通过在发布到 Python 包索引 PyPI（发音为“pie p.i.”）的框架（包括 Flask）和工具包上的协作，添加了更多的模块以导入到[PyPI.Python.org](http://pypi.python.org)上。打包变得复杂，pip 和 virtualenv 的目标是围绕在 PyPI 上使用第三方包制定一个可管理的工作流程。

## 还有更多。。。

可以实现的还有很多，如下所示：

### 开发环境检查表

以下是开发 web 应用程序所需的项目：

*   用于添加和编辑源代码的文本编辑器。我使用 emacs 和 vim，它们有高效的键盘快捷键，升华文本是一种流行的选择。有很多选择；只需确保编辑器是为代码设计的。
*   使用本章中的说明，使用 virtualenv 工具编写 Python。
*   一个终端控制台，用于运行您的 Flask 代码，一个用于您运行的每个 Flask 应用程序，如下一节所述。
*   运行 Python 交互式解释器的终端控制台。在这里，您可以浏览 API、实验代码、验证单元功能，并使用 Python 的内置`help(arg)`函数获取在线文档。
*   现代网络浏览器。Firefox 和 Chrome 具有易于访问的 JavaScript 控制台和网页文档检查器。JavaScript 控制台和文档检查器对于 web 用户界面开发至关重要。
*   烧瓶文件可在以下网址获得：[Flask.pocoo.org/docs/](http://flask.pocoo.org/docs/)。
*   Werkzeug 文件可在以下网址获得：[Werkzeug.pocoo.org/docs/](http://werkzeug.pocoo.org/docs/)。Werkzeug 是 Flask 的底层 web 服务实现。
*   Jinja 文件可在以下网址获得：[Jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/)。Jinja 是 Flask 的默认模板引擎。
*   Python 文档可在以下网址获得：[docs.Python.org/2/](http://docs.python.org/2/)。
*   版本控制系统。跟踪对项目的更改。我个人推荐 git，请访问[git-scm.com](http://git-scm.com)。

集成开发环境（IDE）可以将这些工具捆绑在一个应用程序中，Python 可以使用几种工具。就我个人而言，我为清单中的每个项目找到了最好的工具，并将我自己的环境作为一个独立工具和应用程序的集合放在一起。我强烈建议为代码交互提供一个独立的命令行，这样即使您有自己喜欢的 IDE，也可以始终访问代码的核心。

（我发现自己在命令行和终端上做任何事情都更有效率，但这是个人偏好的问题。一定要热爱自己的开发环境，这样才能清楚地思考自己的工作。）

### 常见错误及解决方法

在使用 Python virtualenv 时，您将看到两个常见错误：

*   尝试运行 Python 时未找到 `python`命令
*   当您尝试在代码中导入 flask 时，“没有名为 flask 的模块”

这两个问题都是由命令行会话中名为**PATH**的不正确环境变量引起的，该变量是加载命令时系统应搜索的目录的有序列表。如果未找到`python`，则说明安装 Python 时未更新路径，应重新访问 Python 安装程序。如果未找到`flask`，则表示您未激活 virtualenv 或未安装 Flask，您应该重新查看此处的安装说明。

# 运行简单应用程序（简单）

让我们从运行一个最简单的 Flask 应用程序开始。

## 准备好了吗

确保您已按照上一节中的说明激活了 virtualenv 工具。

## 怎么做。。。

1.  将此代码放入名为`hello.py`：

    ```py
    from flask import Flask

    app = Flask(__name__)

    @app.route('/')
    def hello():
        return 'Hello, world!'

    if __name__ == '__main__':
        app.run()
    ```

    的文件中
2.  从控制台运行此应用程序：

    ```py
    $ python hello.py
    ```

3.  If this runs correctly, you will see:

    ***正在运行 http://127.0.0.1:5000/**

    这是一个 URL，您可以在浏览器中访问它。当您这样做时，您的浏览器将显示一个普通页面，上面写着“**你好，世界！**”（不带引号）。请注意，地址`127.0.0.1`指的是本地主机，因此 Flask 将只响应来自运行代码的主机的请求。

## 它是如何工作的。。。

一行一行，下面是这段代码的作用：

```py
app = Flask(__name__)
```

这将创建一个 Python 对象`app,`，它是一个**WSGI**应用程序。WSGI 代表**Web 服务网关接口**，是 Python 社区托管 Web 项目的标准接口。任何您找到的 WSGI 资源或工具，都可以应用于此`app`对象，包括 WSGI 中间件（如果您找到了，请将`app.wsgi_app`和 HTTP 服务器（如 gunicorn 或 Apache`httpd`与`mod_wsgi`一起包装）。

`Flask`类的参数告诉 Flask 如何查找与应用程序关联的资源：静态文件和模板。传递`__name__`告诉 Flask 查看当前 Python 模块包含此代码的`.py`文件。您的大多数应用程序将使用`__name__`；如果您怀疑`__name__`无法满足您的需求，则本文件将详细描述此参数。

下一个块设置一个函数来处理对`'/'`URL 的 web 请求：

```py
@app.route('/')
def hello():
  return 'Hello, world!'
```

每次 Flask 收到对`'/'`URL 的请求时，它都会调用`hello`函数。Python web 社区调用这些路由函数**视图**函数。通常，Flask 中的 view 函数会返回 web 响应的字符串，这里我们为所有请求提供一个简单的“Hello，world！”响应，以证明一切正常。

最后一个块告诉 Python 运行开发 web 服务器，但只有在直接调用当前`.py`文件时才这样做：

```py
if __name__ == '__main__':
  app.run()
```

也就是说，如果您运行命令`python hello.py`，则此代码块将运行，但如果您从另一个 Python 模块使用`import hello`，则不会运行此代码块。

## 还有更多。。。

一旦您对 helloworld 应用程序感到满意，让我们来构建我们的项目。

### 项目布局

我们将构建一个简单的日程安排应用程序来管理和显示约会。让我们将一个文件应用程序移动到一个较大应用程序的目录设置中。在项目中创建以下文件布局，其中包含子目录`static`和`templates`的`sched`目录当前均为空。

```py
manage.py
requirements.txt
sched/
  app.py
  config.py
  filters.py
  forms.py
  __init__.py
  models.py
  static/
  templates/
```

将`hello.py`移动到`sched`目录内的`app.py`。`__init__.py`文件是一个空文件，告诉 Python`sched`是一个包含 Python 文件的包。`config.py`、`filters.py`、`forms.py`和`models.py`文件目前为空文件，我们将在接下来的部分中进行填充。

### 开发服务器

如果需要从网络上的另一台计算机访问 Flask 应用程序，请使用：

```py
app.run('0.0.0.0')
```

Flask 开发服务器的默认端口为`5000`，在本书中，我们将在端口`5000`上使用`localhost`。如果这已经在使用中，或者您想使用其他端口，您可以通过第二个参数将其设置为`run`方法，如下所示。

```py
app.run('0.0.0.0', 8080)
```

`app.run`给出的开发服务器仅供开发使用。当您准备发布应用程序时，请使用 industrial strength web 服务器，如稍后关于部署和日志记录的部分所述。因为我们使用`app.run`仅用于开发，所以让我们打开调试模式，当出现未捕获的异常时，它将在 web 浏览器中提供一个交互式调试器，并将在项目中现有 Python 文件的更改中重新加载代码。您只能在受信任的网络上使用`'0.0.0.0'`和/或调试模式。将`debug=True`添加到运行行，保留已添加的任何其他参数：

```py
app.run(debug=True)
```

### 带 Flask 脚本的命令行界面

我们将使用`manage.py`使用**烧瓶脚本**管理我们的应用程序，内容如下：

```py
from flask.ext.script import Manager
from sched.app import app

manager = Manager(app)
app.config['DEBUG'] = True # Ensure debugger will load.

if __name__ == '__main__':
  manager.run()
```

`requirements.txt`文件是跟踪所有第三方 Python 包的常规方法。使用以下列表设置文件，即每行一个包名。在 virtualenv 处于活动状态且 internet 连接正常的情况下运行`pip install -r requirements.txt`以安装这些依赖项。

```py
Flask
Flask-Script
```

现在您可以使用`python manage.py runserver`运行应用程序。运行`python manage.py -h`获取开发服务器选项的帮助，运行`python manage.py runserver -h`获取开发服务器选项的帮助。使用`python manage.py shell`获得一个加载了 Flask 应用程序的交互式 Python 解释器，您可以使用它检查代码并以交互方式尝试新事物。默认情况下，Flask 脚本会提供`runserver`和`shell`命令；可以添加自定义`manage.py`子命令；请参阅 Flask 脚本文档。

正如我们所讨论的，您可以从网络上的另一台机器访问开发服务器并更改端口；以下是命令模式：

```py
$ python manage.py runserver –t 0.0.0.0 –p 8080

```

### 提示

Flask 脚本在本月早些时候添加了对 Python 3 的支持。本书现在完全支持 Python 2 和 Python 3。

# 路由 URL 和接受请求（简单）

本节将把 URL 连接到 web 服务中的 Python 函数。

## 准备好了吗

使用*运行简单应用程序*配方中*项目布局*部分列出的项目布局。

## 怎么做。。。

1.  The Flask `app` object includes a `route` decorator to specify URL rules to use for a view function conveniently, which provides a declarative style for routing requests to Python callables. The following code routes five URL handling functions for the list, detail, creation, updating, and deletion of appointment records in our scheduling application. For now, we simply return a string describing what the handler is going to do, which we'll implement later, so that you can see the URL routing in action from your browser. Place into `app.py`:

    ```py
    @app.route('/appointments/')
    def appointment_list():
      return 'Listing of all appointments we have.'

    @app.route('/appointments/<int:appointment_id>/')
    def appointment_detail(appointment_id):
      return 'Detail of appointment     #{}.'.format(appointment_id)

    @app.route( 
      '/appointments/<int:appointment_id>/edit/',
      methods=['GET', 'POST'])

    @app.route(...) and def appointment_edit(...).

    def appointment_edit(appointment_id):
      return 'Form to edit appointment #.'.format(appointment_id)

    @app.route(
      '/appointments/create/', 
      methods=['GET', 'POST'])
    def appointment_create():
      return 'Form to create a new appointment.'

    @app.route(
      '/appointments/<int:appointment_id>/delete/,
      methods=['DELETE'])
    def appointment_delete(appointment_id):
        raise NotImplementedError('DELETE')
    ```

    ### 提示

    **下载示例代码**

    您可以下载您在[账户购买的所有 Packt 书籍的示例代码文件 http://www.packtpub.com](http://www.packtpub.com) 。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册，将文件直接通过电子邮件发送给您。

2.  Using `python manage.py runserver`, you can visit these URLs at:
    *   `http://localhost:5000/appointments/`
    *   `http://localhost:5000/appointments/1/`
    *   `http://localhost:5000/appointments/1/edit/`
    *   `http://localhost:5000/appointments/create/`
    *   `http://localhost:5000/appointments/1/delete/`

    ### 注

    如果您在浏览器中测试这些 URL，您会发现删除 URL 会响应一个**405 方法不允许**错误。这是有意的，因为默认情况下浏览器发送`GET`reuest，我们只允许`DELETE`方法。我们不想在`GET`请求中删除记录，但只有在按下删除按钮时（在后面的部分中内置）才可以删除记录。

3.  您可以使用`flask.url_for`函数构建视图函数的 URL，该函数返回 URL 的字符串表示形式。这允许您在 URL 更改时使用干净的标识符进行编程，使用目标函数的名称及其参数：

    ```py
    from flask import url_for

    @app.route('/appointments/<int:appointment_id>/')
    def appointment_detail(appointment_id):
      edit_url = url_for('appointment_edit',
        appointment_id=appointment_id)
      # Return the URL string just for demonstration.
      return edit_url
    ```

4.  `url_for`的第一个参数称为端点，默认情况下，端点是由`app.route`修饰符包装的 Python 函数的名称。您可以使用`endpoint`关键字参数将默认值改写为`app.route`：

    ```py
    @app.route(
      '/appointments/<int:appointment_id>/',
      endpoint='some_name')
    def appointment_detail(appointment_id):
      # Use url_for('some_name', appointment_id=x)
      # to build a URL for this.
      return 'Just to demonstrate...'
    ```

## 它是如何工作的。。。

`app.route`的主要参数是由**Werkzeug**实现的字符串 URL 规则，Flask 的所有东西 WSGI 底层工具包。尖括号`<argument>`中列出的项被解析为命名参数，以传递到视图函数中。Flask 在 URL 规则中使用约定`<converter:argument>`来解析参数值，然后再将其传递给视图函数，并且仅在正确解析值的情况下路由 URL。默认情况下，Flask 将参数视为字符串。其他内置转换器包括：

*   `int`：此转换器的值为整数
*   `float`：此转换器的值为浮点数
*   `path`：此转换器的值是一个字符串，例如默认值，但也接受斜杠

您可以定义自己的转换器，如 Flask 的`app.url_map`文档所示，但您可能不需要这样做，这样您的 view 函数就可以检查字符串参数并解析它所需要的内容。

默认情况下，如果 URL 规则以尾随斜杠`/`结尾，Flask 将不带尾随斜杠的请求重定向到包含它的处理程序。

## 还有更多。。。

一旦您启动并开始路由，您应该了解一些关于 HTTP 和 Flask 路由的事情。

### 处理 HTTP 方法

`app.route`最常见的关键字参数是`methods`，为 Flask 提供了一个路由时要接受的 HTTP 方法列表，如果没有，则默认为`GET`。有效值为`GET`、`POST`、`PUT`、`DELETE`、`HEAD`和`OPTIONS`。RFC2068 是定义这些方法的标准文件。简而言之，它们是：

*   `GET`：此选项用于回复资源信息，最常用
*   `POST`：此选项用于从浏览器/客户端接收资源的更新信息
*   `PUT`：此选项类似于`POST`，但对资源重复`PUT`调用应该没有效果
*   `DELETE`：使用此选项将删除资源
*   `HEAD`：该选项类似于`GET`，但只回复 HTTP 头，不回复内容
*   `OPTIONS`：此选项用于确定资源可用的方法

### 注

如果`GET`存在，烧瓶工具`HEAD`为您提供，并且在所有情况下`OPTIONS`为您提供。HTTP 浏览器的旧实现只支持`GET`和`POST`，但我们将在后面的小节中通过 JavaScript 添加`DELETE`请求。使用其他 HTTP 方法取决于您和您的项目，特别是在方法的语义非常重要的情况下。

### 装饰功能的替代品

`@app.route`方法是 Python 装饰器，在定义函数时使用它。或者，您可以使用与`app.route`完全相同的`app.add_url_rule,`，但它是一个简单的方法调用，而不是装饰器。您可以为`app.add_url_rule`提供任何可调用的 Python，接受 URL 规则中的参数，在请求时将成为`request.view_args`。如果您对如何指定应用程序的 URL 路由有自己的想法，您可以使用`app.add_url_rule`中您喜欢的任何工具作为工具来连接您的 Flask 应用程序。

### 路线碰撞

当 Flask 将您的请求路由到意外的地方时，请在您的`app.route`调用中查找冲突。也就是说，如果您有`/<path:foopath>`和`/foo/bar/baz/`两条路线，它们都将在`/foo/bar/baz/`上匹配。解决方案是在路线参数中尽可能具体，并避免过度通用的参数。

### 带子域的路由

您可以使用`subdomain`关键字参数将子域路由到`app.route`：

```py
@app.route('/', subdomain='<spam_eggs>')
def subdomain_example(spam_eggs):
  return '...'
```

此子域参数使用与其他 URL 相同的参数方法，但请注意，适当的子域在其可接受的范围内受到限制。简单的名称很简单，但如果您有特定的要求，请参阅 RFC2181 了解名称语法，并注意一些 HTTP 客户端不支持子域中的完整规范。

使用子域时，Flask 需要知道服务器名称，以便从 URL 解析子域。提供`SERVER_NAME`至`app.config`，如配置部分所述。

在您的机器上进行本地开发时，您也会遇到限制，因为`localhost`不接受子域。您可以设置操作系统的主机文件（通常为`/etc/hosts`）。如果您的`SERVER_NAME`为`example.com`且您的子域参数为`foo`，则可以设置：

```py
127.0.0.1    localhost local.example.com foo.local.example.com
```

`hosts`文件不接受通配符。如果您有权访问域名服务，主机文件的另一种选择是将 DNS 中的 a 记录及其所有子域（通配符）设置为`127.0.0.1`，如以下示例所示。这将把所有机器上的`local.example.com`的所有子域路由到本地主机。

```py
local.example.com A 127.0.0.1
*.local.example.com A 127.0.0.1
```

这种技术需要一个 DNS 网络调用，因此，如果您正在脱机工作，则需要返回主机文件。

# 处理请求和响应（简单）

本节将演示 Flask 如何处理 HTTP 请求上的传入数据，以及如何发送响应。

## 准备好了吗

将调度应用程序放在一边，打开一个新的 Python 文件来探索 Flask。

## 怎么做。。。

1.  在核心部分，Flask 和 Werkzeug 提供请求和响应对象来表示 web 应用程序的传入和传出数据。Flask 为视图函数的返回值提供了三种不同的模式：
    *   字符串，可以选择使用模板引擎（稍后介绍）
    *   一个响应实例，一个具有表示 HTTP 响应详细信息的属性的对象
    *   `(string, status)`或`(string, status, http_headers)`的元组，为方便起见，不必创建响应实例
2.  让我们看看每个响应模式的实际效果。每个回应都会说**你好，世界！**带有 200 OK 状态码（成功时的典型 HTTP 响应），后两个功能告诉浏览器以纯文本形式显示响应。第一个函数的响应显示为 HTML，因为纯字符串返回对象无法告诉 Flask 如何设置响应的内容类型。

    ```py
    from flask import Flask, make_response

    app = Flask(__name__)

    @app.route('/string/')
    def return_string():
      return 'Hello, world!'

    @app.route('/object/')
    def return_object():
      headers = {'Content-Type': 'text/plain'}
      return make_response('Hello, world!', status=200,
        headers=headers)

    @app.route('/tuple/')
    def return_tuple():
      return 'Hello, world!', 200, {'Content-Type':
        'text/plain'}
    ```

3.  当 Flask 准备调用 view 函数并接受其返回值时，它将遍历您提供的每个请求前回调和请求后回调。在这里，我们设置了请求前函数和请求后函数，纯粹是为了演示 Flask 的请求和响应处理。当您想要与 Flask 文档所说的内容交互时，可以使用这些处理程序来探索 Flask 行为。运行此代码时，请记住浏览器通常会自动查找`/favicon.ico`，这可能会在测试时导致对应用程序的额外请求。

    ```py
    from flask import request

    def dump_request_detail(request):
      request_detail = """
    # Before Request #
    request.endpoint: {request.endpoint}
    request.method: {request.method}
    request.view_args: {request.view_args}
    request.args: {request.args}
    request.form: {request.form}
    request.user_agent: {request.user_agent}
    request.files: {request.files}
    request.is_xhr: {request.is_xhr}

    ## request.headers ##
    {request.headers}
      """.format(request=request).strip()
      return request_detail

    @app.before_request
    def callme_before_every_request():
      # Demo only: the before_request hook.
      app.logger.debug(dump_request_detail(request))

    @app.after_request
    def callme_after_every_response(response):
      # Demo only: the after_request hook.
      app.logger.debug('# After Request #\n' + repr(response))
      return response
    ```

## 它是如何工作的。。。

以下是请求对象的常用功能。有关传入请求数据的完整列表，请参见 Flask 文档。为了提供一个示例，每个描述都包含一个示例值，用于从我们的浏览器中点击`/string/?foo=bar&foo=baz`的请求。

*   `endpoint`：请求对象的此功能指定路由的请求端点的名称，例如`return_string`。
*   `method`：请求对象的这个特性指定了当前请求的 HTTP 方式，例如`GET`。
*   `view_args`：request 对象的这个特性指定了从 URL 路由规则解析的 dict of view 函数参数，例如`{}`。
*   `args`：请求对象的这个特性指定了从 URL 查询字符串解析的参数的 dict，例如，`request.args['foo']`是`'bar'`，而`request.args.getlist('foo')`是`['bar', 'baz']`。
*   `form`：请求对象的这个特性指定了`POST`或`PUT`请求的表单数据的 dict，例如`{}`。
*   `user_agent`：请求对象的这个特性指定了浏览器提供的版本标识。
*   `files`：请求对象的这个特性指定了从`POST`或`PUT`请求上传文件的 dict，它们在这里代替`request.form`，例如`{}`。dict 中的每个值都是一个`FileStorage`对象，其行为类似于 Python`file`对象，但也包括一个`save(filepath)`方法来存储上传的文件（在验证目标路径后）。
*   `is_xhr`：`True`：请求对象的此特性指定传入请求何时为 JavaScript`XMLHttpRequest`，何时为 JavaScript`False`。这适用于提供设置为`XMLHttpRequest`的`X-Requested-With`HTTP 头的 JavaScript 库。

Flask 使用一个自定义的`dict`类型`ImmutableMultiDict`，它支持每个键有多个值（通过`getlist`方法访问），在 HTTP 允许给定参数有多个值的情况下，例如 URL 中的查询字符串，例如`?foo=bar&foo=baz`。

## 还有更多。。。

我们在演示代码中使用了`app.before_request`和`app.after_request`。最终，您会希望对象在代码中停留在请求处理程序之前和之后。

### 请求前后

如果需要在前后请求挂钩之间保留对象，可以在`flask.g`对象上设置属性。`g`对象仅在请求期间有效，您可以在`g`对象上设置任何您想要的内容。这是为了方便，为了你在整个请求过程中需要的东西，但还没有一个家。不要滥用`g`对象，给它提供属于其他地方的对象，例如数据库系统。

以下是正在运行的`g`对象，其中在`g.x`上设置了一个介于 0 和 9 之间的随机整数，并在请求前后记录：

```py
import random

from flask import g

@app.before_request
def set_on_g_object():
  x = random.randint(0, 9)
  app.logger.debug('before request: g.x is {x}'.format(x=x))
  g.x = x

@app.after_request
def get_on_g_object(response):
  app.logger.debug(
    'after request: g.x is {g.x}'.format(g=g))
  return response
```

# 处理静态文件（简单）

Flask 已准备好从您提供第一个请求的那一刻起提供磁盘上的文件。

## 准备好了吗

转到您的调度程序项目，查看`sched`目录中的`static`文件夹。

## 怎么做。。。

1.  将文件放入`static`文件夹中。
2.  使用`flask.url_for('static', filename='path/to/filename')`为它们构建 URL，其中`path/to/filename`是静态文件夹中的文件路径，使用`/`无论您使用的是什么操作系统。

## 它是如何工作的。。。

按照惯例，Flask 会在应用程序旁边查找名为`static`的文件夹，并在`/static/<path:filename>`URL 处提供文件，匹配`static`文件夹及其子目录中的所有文件。也就是说，如果您的应用程序位于`app.py`，那么默认情况下，Flask 将查看`app.py`旁边的`static`文件夹。在`app.py`旁边的`/static/img/favicon.ico`中放置一个文件，可以在默认开发服务器中的`http://localhost:5000/static/img/favicon.ico`URL`/static/img/favicon.ico`中使用。（这个 favicon 将在下一节关于模板的内容中介绍。）

## 还有更多。。。

您可以自定义 Flask 处理静态文件的方式。

### 在生产中提供静态文件服务

部署应用程序时，您可能希望从工业级 HTTP 服务器（如 nginx 或 Apache httpd）提供静态文件，这些服务器针对静态文件进行了高度优化。您可以将这些服务器配置为从项目中相同的`/static/`文件夹提供`/static/`URL。如果您没有访问这些服务器的权限，如果需要，可以在生产中使用 Flask 的静态文件处理。

### 在其他地方托管静态文件

如果您使用的静态文件由另一台服务器提供，URL 不是`/static/`，那么您可以使用`build_only`选项向 Flask 应用程序添加路由。这告诉 Flask 如何使用`flask.url_for`函数构建 URL，而不需要`view`函数，也不需要 Flask 尝试为这些文件提供服务。

```py
app.add_url_rule('/attachments/<path:filename>', endpoint='attachments', build_only=True)
```

### 自定义静态文件处理程序

如果从文件系统提供文件时需要进行任何自定义处理（例如，仅向付费用户提供文件），以便在静态文件夹外的静态文件中使用（例如，`/robots.txt`，或者覆盖 Flask 的内置静态视图功能，则可以构建自己的静态文件处理程序：

```py
import os.path
from flask import Flask, send_from_directory

# Setting static_folder=None disables built-in static handler.
app = Flask(__name__, static_folder=None)
# Use folder called 'assets' sitting next to app.py module.
assets_folder = os.path.join(app.root_path, 'assets')

@app.route('/assets/<path:filename>')
def assets(filename):
  # Add custom handling here.
  # Send a file download response.
  return send_from_directory(assets_folder, filename)
```

使用硬编码目录和`send_from_directory`将减轻目录遍历攻击，因为底层实现使用`flask.safe_join(directory, filename)`对输入进行清理，在处理作为用户输入传入的文件名时，您可以在自己的代码中使用这些内容。

使用自定义静态视图功能对静态文件进行自定义处理，不更改`static`文件夹的配置。如果您只需要重命名`static`文件夹，请使用：

```py
app = Flask(__name__, static_folder='foldername')
```

默认情况下，Flask 在`/static/`处提供静态文件，其中`static`是`static_folder`参数中提供的文件夹名称，默认为`static`。如果要使用与文件夹名称不同的 URL 路径，请使用：

```py
app = Flask(__name__, static_url_path='/assets')
```

### HTTP 缓存

默认情况下，Flask 发送一个带有静态文件的 HTTP 头，通知浏览器缓存该文件 43200 秒，即 12 小时。您可以使用`SEND_FILE_MAX_AGE_DEFAULT`配置变量对此进行配置。例如，如果要对所有静态文件进行主动缓存，可以将此值设置为 2592000 秒或 30 天：

```py
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 2592000
```

增加 HTTP 缓存长度时要小心，因为在部署更改时，浏览器将有过时的文件。要解决该问题，请在重新部署时更改静态 URL 路径：

```py
app = Flask(__name__, static_url_path='/static/v2')
```

### 目录索引

Flask 不在静态目录中列出文件内容供用户浏览；您必须直接链接到静态文件。如果需要目录索引视图，请考虑使用工业强度静态文件 Web 服务器（如 NGIX 或 Apache HTTPD）。

# 使用数据库（简单）

我们的调度程序应用程序需要数据，我们希望正确地存储这些数据，以便在不丢失约会的情况下停止和启动应用程序。

## 准备好了吗

我们正在从项目的`sched`目录中的`models.py`文件开始工作。

## 怎么做。。。

**SQLAlchemy**为使用 SQL 的关系数据库提供了 Python 工具包和对象关系管理器。不管您使用什么 web 框架，SQLAlchemy 都是独立的，我们可以将它集成到 Flask 和 Flask SQLAlchemy 中，后者将通过 Flask 请求生命周期管理数据库连接。

更新`requirements.txt`：

```py
Flask
Flask-Script
Flask-SQLAlchemy
```

然后：

```py
$ pip install -r requirements.txt

```

让我们使用 SQLAlchemy 的声明性扩展为约会数据结构建模，它允许我们编写 Python 类来表示数据库表。请注意，Flask SQLAlchemy 包含一些声明性功能，但我们的应用程序使用纯 SQLAlchemy 使代码可移植到任何 Python 项目，并允许您引用核心 SQLAlchemy 文档[docs.SQLAlchemy.org](http://docs.sqlalchemy.org)。

我们正在建模一个`Appointment`类，该类将对象映射到`appointment`表。从一个`Base`类开始，定义一个`Appointment`子类。当使用底层数据库系统时，SQLAlchemy 将找到`Base`的所有子类。然后我们在`Appointment`类上定义列，该类将映射我们在代码中使用的每个`Appointment`对象的属性，并将值作为列存储和检索到数据库中的`appointment`表中。在`models.py`中：

```py
from datetime import datetime

from sqlalchemy import Boolean, Column
from sqlalchemy import DateTime, Integer, String, Text
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()

class Appointment(Base):
  """An appointment on the calendar."""
  __tablename__ = 'appointment'

  id = Column(Integer, primary_key=True)
  created = Column(DateTime, default=datetime.now)
  modified = Column(DateTime, default=datetime.now,
    onupdate=datetime.now)

  title = Column(String(255))
  start = Column(DateTime, nullable=False)
  end = Column(DateTime, nullable=False)
  allday = Column(Boolean, default=False)
  location = Column(String(255))
  description = Column(Text)
```

为了在我们的应用程序中加载我们的域模型，我们在 Flask 应用程序上配置我们的数据库，并在`app.py`中设置一个`db`对象，以准备在我们的请求处理程序中进行查询：

```py
from flask import Flask
from flask.ext.sqlalchemy import SQLAlchemy

from sched.models import Base
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///sched.db'

# Use Flask-SQLAlchemy for its engine and session
# configuration. Load the extension, giving it the app object,
# and override its default Model class with the pure
# SQLAlchemy declarative Base class.
db = SQLAlchemy(app)
db.Model = Base
```

我们可以在`Appointment`类上添加几个助手作为方法。`duration`属性使用`appointment`对象的开始和结束时间，以秒为单位计算约会的长度。`__repr__`方法告诉 Python 在打印`appointment`对象时如何表示它。这个实现将使用`<Appointment: 1>`，而不是 Python 的默认形式`<__main__.Appointment object at 0x26cf2d0>`。

回到`models.py`中，在`Appointment`类声明中添加：

```py
  @property
  def duration(self):
    delta = self.end - self.start
      return delta.days * 24 * 60 * 60 + delta.seconds

  def __repr__(self):
    return (u'<{self.__class__.__name__}: {self.id}>'
      .format(self=self))
```

## 它是如何工作的。。。

每个`Column`都有一个类型，它为`appointment`记录提供了结构。我们为`Column`提供关键字参数来定义如下行为：

*   `primary_key`：`True`表示该字段为记录标识符。
*   `default`：当没有给出数据时，使用该值。这可以是一个返回值的函数，例如，将`created`设置为`datetime.now()`的输出，以提供创建数据库记录时的日期/时间。
*   `onupdate`：当记录被存储或更新时，将其值设置为给定函数的返回值，例如，将`modified`设置为数据库记录更新时的当前日期/时间。
*   `nullable`：当`False`时，通过引发异常，不允许存储未为此属性设置值的记录。

URL`sqlite:///sched.db`告诉 SQLAlchemy 在当前工作目录中使用 SQLite 数据库。Python 附带了对 SQLite 的支持，SQLite 是一种嵌入式关系数据库管理系统，也可以在[SQLite.org](http://sqlite.org)上找到。

## 还有更多。。。

我们只对数据进行了建模，并告诉 Flask 如何连接到 SQLite 数据库。让我们尝试一些查询。

### 用 SQLAlchemy 进行查询

有了约会模型定义，我们可以从 Python 运行一些查询。在构建应用程序的视图函数之前，我们可以进行一些示例查询。将以下代码添加到`if __name__ == '__main__'`块内的`models.py`主脚本中。添加您想要的任何语句或`print`调用，以查看 SQLAlchemy 的工作原理并观察其运行情况：

```py
$ python models.py

```

### 提示

web 请求在哪里？本节在请求上下文之外直接使用 SQLAlchemy，以说明 SQLAlchemy 是如何工作的。这种自下而上的方法可以帮助您理解构建块。

我们从一个引擎开始，它连接到数据库并执行查询。如果您不想在磁盘上创建文件，可以使用内存中的临时数据库。`sqlite://`URL 告诉 SQLAlchemy 连接到 SQLite 数据库，由于省略了文件路径，它应该连接到内存中的临时数据库。也就是说，`sqlite://`URL 将提供一个只在 Python 进程执行期间存在的数据库，并且不会在对 Python 的调用中持久存在。

```py
from datetime import timedelta

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine('sqlite:///sched.db', echo=True)
```

接下来，我们创建一个会话并创建数据库表。当引擎连接到数据库并执行查询时，会话表示与数据库的持续对话，是应用程序在 SQLAlchemy 中使用关系数据库的主要入口点。

```py
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)
session = Session()
```

现在我们添加一些示例数据。我们使用当前时间`now`加上或减去一些`timedelta`（接受天数和秒数）为假预约生成时间。

```py
now = datetime.now()

session.add(Appointment(
  title='Important Meeting',
  start=now + timedelta(days=3),
  end=now + timedelta(days=3, seconds=3600),
  allday=False,
  location='The Office'))
session.commit()

session.add(Appointment(
  title='Past Meeting',
  start=now - timedelta(days=3),
  end=now - timedelta(days=3, seconds=3600),
  allday=False,
  location='The Office'))
session.commit()

session.add(Appointment(
  title='Follow Up',
  start=now + timedelta(days=4),
  end=now + timedelta(days=4, seconds=3600),
  allday=False,
  location='The Office'))
session.commit()

session.add(Appointment(
  title='Day Off',
  start=now + timedelta(days=5),
  end=now + timedelta(days=5),
  allday=True))
session.commit()
```

要创建、更新和删除约会记录，请执行以下操作：

```py
# Create. Add a new model instance to the session.
appt = Appointment(
  title='My Appointment',
  start=now,
  end=now + timedelta(seconds=1800),
  allday=False)

session.add(appt)
session.commit()

# Update. Update the object in place, then commit.
appt.title = 'Your Appointment'
session.commit()

# Delete. Tell the session to delete the object.
session.delete(appt)
session.commit()
```

下面是一些示例查询，您可以运行这些查询来了解 SQLAlchemy 是如何工作的。每个`appt`示例都是一个类型为`Appointment`的 Python 对象。每个`appts`示例都是`Appointment`对象的 Python 列表。

```py
# Get an appointment by ID.
appt = session.query(Appointment).get(1)

# Get all appointments.
appts = session.query(Appointment).all()

# Get all appointments before right now, after right now.
appts = session.query(Appointment).filter(Appointment.start < datetime.now()).all()
appts = session.query(Appointment).filter(Appointment.start >= datetime.now()).all()

# Get all appointments before a certain date.
appts = session.query(Appointment).filter(Appointment.start <= datetime(2013, 5, 1)).all()

# Get the first appointment matching the filter query.
appt = session.query(Appointment).filter(Appointment.start <= datetime(2013, 5, 1)).first()
```

SQLAlchemy 提供了完整的 SQL 功能。从 Python 代码生成 SQL 查询时，请务必参考 SQLAlchemy 文档。

### 提示

关于`session`对象：您将使用`db.session`（在本节中我们添加到`app.py`的`db`对象上），而不是直接使用会话。Flask SQLAlchemy 将确保`db.session`被正确实例化，并且在一个 web 请求中通过数据库`session`访问的数据不会干扰其他请求中的`session`。

### 生产数据库

SQLite 非常适合开发，可以在生产环境中工作，但是当您部署代码时，您可能希望使用 PostgreSQL 或 MySQL 作为数据库管理系统。通过指定不同的数据库 URL 并安装必要的包绑定到数据库，可以在保持模型不变的同时更改基础数据库。

对于 PostgreSQL：

*   URL 模式：`postgresql://user:pass@localhost:5432/database_name`
*   `pip install psycopg2`

对于 MySQL：

*   URL 模式：`mysql://user:pass@localhost:3306/database_name`
*   `pip install mysql-python`

记住在连接到干净的数据库时创建表。

SQLAlchemy 知道如何将数据定义转换到所有主要的关系数据库管理系统，当您需要使用特定的数据库功能时，它支持 SQL 方言，如[docs.SQLAlchemy.org/en/rel_0_8/dialogs/](http://docs.sqlalchemy.org/en/rel_0_8/dialects/)所述。

### 命名约定

我们的`Appointment`类使用一个名为`appointment`的底层表。我建议使用主键的单数表名，始终命名为`id`，但您可以自行决定如何命名表和列。

### 自定义 SQL

SQLAlchemy 的核心是一个 Python 工具包，用于构造参数化 SQL 表达式。在任何时候，如果您需要编写自定义查询，则无需通过传递字符串下拉到原始执行语句 SQLAlchemy 为您提供了工具。

参见[docs.sqlalchemy.org/en/rel_0_8/core/](http://docs.sqlalchemy.org/en/rel_0_8/core/)上的 SQL 表达式语言文档。

### 文档存储和非关系数据库

如果您更喜欢另一个数据库管理系统，可能是面向文档而不是关系型的，请使用可用于从 Python 连接到该数据库的工具。如您所见，我们将域模型声明隔离在一个文件中，并用几行代码将它们连接到 Flask 应用程序对象中。本书中的应用程序代码将使用 SQLAlchemy API 查询数据，但您可以将这些调用转换为您选择的数据库。

# 处理表格和文件上传（简单）

让我们从用户那里获取数据。在开始之前，请记住永远不要相信用户输入，因为迟早会有人（或某人的脚本）恶意破坏您的应用程序。

## 准备好了吗

我们正在从项目的`sched`目录中的`forms.py`文件开始工作。

## 怎么做。。。

1.  现在我们有了一个数据模型，我们需要向用户提供一个表单，以便填充数据库并验证用户输入，以确保它与我们的模式匹配。您可以使用任何喜欢的工具验证传入数据。我们将在调度程序中使用**WTForms**。
2.  更新`requirements.txt`：

    ```py
    Flask
    Flask-Script
    Flask-SQLAlchemy
    WTForms
    ```

3.  然后：

    ```py
    $ pip install -r requirements.txt

    ```

4.  WTForms 使用类似于 SQLAlchemy 用于数据库表建模的声明性扩展的样式的类对表单进行建模。它采用的理念是表单应与数据分开建模，这样表单和数据是分开的，并且用户表单（在 HTML 用户界面中）通常与域数据（在使用 SQLAlchemy 建模的数据库中）不完全一致。WTForms 提供 HTML 表单生成和表单数据验证。在 Flask 中，您将在`POST`和`PUT`请求的`request.form`中找到提交的表单数据。
5.  这是我们的预约表。每个属性都有一个标签和一组验证器。`Length(max=255)`验证程序确保输入最多 255 个字符，`required()`验证程序拒绝空输入。在`forms.py`：

    ```py
    from wtforms import Form, BooleanField, DateTimeField
    from wtforms import TextAreaField, TextField
    from wtforms.validators import Length, required

    class AppointmentForm(Form):
      title = TextField('Title', [Length(max=255)])
      start = DateTimeField('Start', [required()])
      end = DateTimeField('End')
      allday = BooleanField('All Day')
      location = TextField('Location', [Length(max=255)])
      description = TextAreaField('Description')
    ```

    中

## 它是如何工作的。。。

`AppointmentForm`类的目的有两个：用 HTML 呈现输入表单和验证提交的数据。这与基于 SQLAlchemy 的`Appointment`类非常匹配。当`Appointment`模型表示域及其持久性时，这个表单类表示如何以 HTML 显示表单并接受或拒绝结果。

### 提示

在将代码添加到 Flask 应用程序之前，我们可以通过自下而上的方法了解代码的功能。本节通过一些示例代码说明 WTForms 是如何工作的。您可以将此代码添加到`if name == '__main__'`块内`forms.py`的底部，并使用`python forms.py`观察其运行。

在我们将表单添加到后面的应用程序之前，让我们先看看表单本身的作用。我们将打印 WTForms 创建的值，以便了解它在做什么。如果您使用的是 Python 2，则需要在 Python 文件的顶部添加一行，以使打印表达式在 Python 2 和 Python 3 之间兼容：

```py
from __future__ import print_function
```

以下代码打印`title`字段的 HTML 表示：

```py
# Demonstration of a WTForms form by itself.
form = AppointmentForm()
print('Here is how a form field displays:')
print(form.title.label)
print(form.title)
```

输出：

```py
Here is how a form field displays:
<label for="title">Title</label>
<input id="title" name="title" type="text" value="">
```

当显示在浏览器中时，此表单字段呈现为非常简单的输入，如以下屏幕截图所示。我们将在后面的 HTML 模板部分中为表单设计样式。

![How it works...](images/9628OS_01_06.jpg)

下面的代码显示了如何直接与表单的验证交互。您可以使用表单数据字典实例化`AppointmentForm`。您可以将 Flask 的`request.form`对象赋予`AppointmentForm`，但在这里，我们将构建自己的字典，看看它是如何工作的。由于 HTML 表单支持单个参数的多个值，因此我们不能使用 Python 内置的`dict`。相反，我们使用 Werkzeug 的`ImmutableMultiDict`类型，为`title`字段生成虚拟数据，并省略所有其他字段。

```py
# Give it some data.
from werkzeug.datastructures import \
  ImmutableMultiDict as multidict

data = multidict([('title', 'Hello, form!')])
form = AppointmentForm(data)
print('Here is validation...')
print('Does it validate: {}'.format(form.validate()))
print('There is an error attached to the field...')
print('form.start.errors: {}'.format(form.start.errors))
```

输出：

```py
Here is validation...
Does it validate: False
There is an error attached to the field...
form.start.errors: [u'This field is required.']
```

请注意，当`AppointmentForm`被赋予字典表单数据时，`form.validate()`将对其进行处理并根据表单数据是否有效返回`True`或`False`（`True`表示有效）。来自验证器的错误被加载到`errors`列表中的每个字段中，以便您可以在上下文中显示错误，我们将在后面的部分中呈现模板时执行此操作。

## 还有更多。。。

我们处理文件上传的方式有点不同。

### 处理文件上传

如果您正在处理文件上载，则需要直接与 Flask 交互。这些片段将帮助您开始学习。首先，HTML 表单将包括以下基本元素：`form`元素上的`enctype=multipart/form-data`属性和`"<input type=file name=...>"`形式的文件输入。

```py
<form method=post enctype=multipart/form-data>
  <input type=file name=file>
  <input type=submit value=Attach>
</form>
```

接收端的代码应根据文件输入元素上给出的名称在`request.files`字典中查找 Werkzeug`FileStorage`对象，然后在将文件保存到磁盘之前清理文件名。请注意，如果您在响应中使用与文件扩展名匹配的内容类型返回该文件，则只应使用您信任的文件扩展名。否则，攻击者可能会使用您的文件上载功能在应用程序中嵌入 JavaScript，这将导致用户的浏览器信任其他人的代码。

```py
import os

from flask import request
from werkzeug import secure_filename

# '...' here and below need to be set according to your project.
# In your configuration, set a root folder for file uploads.
FILE_FOLDER = '...'

@app.route('...', methods=['POST'])
def file_attach():
  # Match name from <input type=file name=file>: 'file'.
  filestorage = request.files['file']
  # Do not allow '..' in the filename.
  filename = secure_filename(filestorage.filename)
  dest = os.path.join(FILE_FOLDER, filename)
  filestorage.save(dest)
  return 'Put your response here.'
```

# 使用 Jinja 进行模板制作–设置基础模板（简单）

Flask 附带了 Jinja 模板引擎，可以呈现所需的任何文本格式。我们的调度程序将用一点样式和一点 JavaScript 呈现 Jinja 呈现的 HTML5 页面。

## 准备好了吗

我们将使用 HTML、CSS 和 JavaScript 构建模板。您需要熟悉这些，才能理解我们在 Flask 中构建的响应。我们将使用 Twitter 的 Bootstrap（[getbootstrap.com/2.3.2/](http://getbootstrap.com/2.3.2/)框架进行 CSS，并使用 jQuery（[jQuery.com](http://jquery.com)库进行 JavaScript。两者都包括在线文档。引导还包括 Glyphicons（[Glyphicons.com](http://glyphicons.com)提供的图标，我们可以在应用程序中使用这些图标。我们将使用 Bootswatch（[Bootswatch.com](http://bootswatch.com)中的免费引导主题）。

我们在`sched`目录下的`templates`目录下的`base.html`工作。

### 提示

本文通过示例显示模板。在自下而上的方法中，在构建特定的应用程序页面之前，我们将从基本页面结构开始。Jinja 有关于其所有模板功能的文档。请务必参考[处的文件 http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/) 查看金贾提供的服务。

## 怎么做。。。

我们将使用公共**内容交付网络**（**CDN**）进行引导和 jQuery，这将加快我们项目的启动时间。NetDNA 为引导提供了一个公共 CDN。jQuery 项目通过 MediaTemple 提供 CDN。当您准备好或希望离开 CDN 时，只需下载所需的文件并将其与应用程序的静态文件一起提供，更新基本模板中的链接。CDN URL 为，用于基本模板（其中`... thing ...`标识符为）：

*   [http://netdna.bootstrapcdn.com/bootswatch/2.3.2/united/bootstrap.min.css](http://netdna.bootstrapcdn.com/bootswatch/2.3.2/united/bootstrap.min.css)
*   [http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-responsive.min.css](http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-responsive.min.css)
*   [http://code.jquery.com/jquery-1.9.1.min.js](http://code.jquery.com/jquery-1.9.1.min.js)
*   [http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js](http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js)

Jinja 支持模板继承，其中模板文件可以扩展现有模板。我们将使用这个特性来布局我们的基础结构，使用`block`模板标记来指示子模板将填充的部分。我们提供了一个块来设置页面标题，向页面标题添加任何附加内容（这对于附加样式和脚本非常有用），并填充页面的主要内容。Jinja 使用模板标记`{% ... %}`来表示 Jinja 特定的标记和指令。这是我们的基础模板，在`templates/base.html`中，在接下来的部分中有截图：

```py
<!DOCTYPE html>
<html lang="en">
<head>
  <title>{% block title %}{% endblock title %}</title>
  <link rel="shortcut icon" type="image/x-icon"
    href="{{ url_for('static', filename='img/favicon.ico') }}"/>
  <link href="... bootstrap css ..." rel="stylesheet">
  <link href="... responsive css ..." rel="stylesheet">
  <script src="... jQuery js ..."></script>
  <script src="... bootstrap js ..."></script>
  {# Link any other .css or .js found in app static folder. #}
  <style>
    {# Add simple CSS style tweaks here. #}
  </style>
  <script>
    $(function() {
      {# Add page-load JavaScript here. #}
    });
  </script>
  {% block extra_head %}{% endblock extra_head %}
</head>
<body>
  <div id="main">
    <div class="utility-nav navbar navbar-fixed-top">
    <div class="navbar-inner">
    <div class="container">
      {# Navbar goes here. #}
    </div>
   </div>
  </div>
  <div class="content container">
    {% block main %}{% endblock main %}
  </div>
  </div>
</body>
</html>
```

## 它是如何工作的。。。

这个基本模板允许我们编写具有共同结构和风格的重点页面。在 templates 目录中创建的任何模板都可以继承基本模板：

```py
{% extends 'base.html' %}
{% block title %}Page Title{% endblock title %}
{% block main %}
  <h2>This is a child template.</h2>
{% endblock main %}
```

使用`flask.render_template`函数进行渲染。如果文件在 templates 目录中命名为`index.html`，则可以使用以下命令将该模板呈现为字符串：

```py
from flask import render_template
#...
@app.route('/')
def index():
  return render_template('index.html')
```

## 还有更多。。。

使用 Jinja 模板还可以做很多事情

### 使用 Jinja 以外的模板引擎

您可以选择任何您喜欢的模板引擎。当您调用`render_template`时，您有一个 Python 字符串，Flask 将该字符串转换为`Response`对象。如果您喜欢使用不同的模板方法，请构建一个字符串并从视图函数返回它。Flask 捆绑 Jinja，为快速入门提供默认模板环境，并为社区构建 Flask 扩展提供公共环境保证。

### 使用 Bower 管理 web 包

您可以使用 Bower 来管理下载的静态文件，Bower 是 web 工具的包管理器，[Bower.io](http://bower.io)。使用 Bower，您可以使用`bower.json`文件列出依赖项，使用`bower install`加载这些文件，然后在应用程序的静态区域中提供这些文件。

# 创建新记录（中间）

在此，我们提供了一个 web 表单来创建新约会，如以下屏幕截图所示：

![Creating a new record (Intermediate)](images/9628OS_01_01.jpg)

## 准备好了吗

我们将从`sched`和`templates`目录中的`app.py`文件继续工作。

## 怎么做。。。

1.  我们提供了一个`view`函数来对表单进行 GET 和 POST 处理。在这里，我们将数据库部分的`db.session`和表单部分的`AppointmentForm`放在一起。在`app.py`：

    ```py
    from flask import abort, jsonify, redirect, render_template
    from flask import request, url_for
    from sched.forms import AppointmentForm
    from sched.models import Appointment

    # ... skipping ahead. Keep previous code from app.py here.

    @app.route('/appointments/create/', methods=['GET', 'POST'])
    def appointment_create():
      """Provide HTML form to create a new appointment."""
      form = AppointmentForm(request.form)
      if request.method == 'POST' and form.validate():
        appt = Appointment()
        form.populate_obj(appt)
        db.session.add(appt)
        db.session.commit()
        # Success. Send user back to full appointment list.
        return redirect(url_for('appointment_list'))
      # Either first load or validation error at this point.
      return render_template('appointment/edit.html', form=form)
    ```

    中
2.  在构建输入字段之前，我们可以为自己创建一个实用程序，它将显示给定字段的所有 WTForms 功能：标签、输入和错误。Jinja 有宏，类似于 Python 函数。我们将创建一个宏来呈现来自`AppointmentForm`的`edit`字段。
3.  For inputs, we can follow Bootstrap conventions with `control-group` and `controls` page elements, which will let us completely control the form flow from CSS. We want to start a new template with our macro, so that we can reuse it in other templates we create. In `templates/appointment/common.html`:

    ```py
    {% macro edit_field(field, catch_kwargs=true) %}
      <div class="control-group{% if field.errors %} error{% endif %}">
        {{ field.label(class="control-label") }}
      <div class="controls">
        {{ field(**kwargs) }}
        {% for error in field.errors %}
         <span class="help-inline">{{ error }}</span>
        {% endfor %}
      </div>
      </div>
    {% endmacro %}
    ```

    现在，我们可以使用新的宏构建表单。启动一个新模板，我们可以扩展基础并导入宏。扩展基时，我们使用与基模板相同的语法提供块 title 和 main。您可以使用`{% set ... %}`在模板内设置变量，以便在该模板内使用。

4.  在`templates/appointment/edit.html`：

    ```py
    {% extends 'base.html' %}

    {% from 'appointment/common.html' import edit_field %}

    {% set title = 'Add Appointment' %}

    {% block title %}{{ title }}{% endblock title %}

    {% block main %}
    <div class="row">
      <div class="appointment-edit well offset2 span8">
      <form method="post" class="form-horizontal">
        <legend>{{ title }}</legend>
        {{ edit_field(form.title, maxlength=255, class="span3",
          placeholder="Important Meeting") }}
        {{ edit_field(form.start, class="span3", type="datetime",
          placeholder="yyyy-mm-dd hh:mm:ss") }}
        {{ edit_field(form.end, class="span3", type="datetime",
          placeholder="yyyy-mm-dd hh:mm:ss") }}
        {{ edit_field(form.allday) }}
        {{ edit_field(form.location, maxlength=255, class="span3",
          placeholder="The Office") }}
        {{ edit_field(form.description, rows="5", class="span5",
          placeholder="Bring a sharpened #2 pencil.") }}
        <div class="form-actions">
        <button type="submit" class="btn">Save</button>
        or <a href="{{ url_for('appointment_list') }}">Cancel</a>
        </div>
      </form>
      </div>
    </div>
    {% endblock main %}
    ```

    中

## 它是如何工作的。。。

在 GET 上，呈现表单时会执行一个操作，将数据发布到同一 URL。在 POST 中，view 函数验证数据并将其添加到数据库中。如果验证失败，POST 将再次呈现模板，但这次表单对象有错误。

Jinja 使用模板语法`{{ ... }}`将上下文中的 Python 对象打印到模板的输出中。如果字段有错误，我们使用一个简单的`if`语句添加错误类，当存在错误时，它将突出显示输入（多亏了引导风格）。我们使用`for`循环为字段中的每个错误设置帮助范围。使用`**kwargs`将捕获宏调用签名之外给出的所有参数；这使我们可以通过宏传入所有 WTForm 字段选项。`kwargs`功能仅在`catch_kwargs=true`时在 Jinja 宏中有效。

CSS 类`form-horizontal`、`span3`和`span5`告诉 Bootstrap 如何在其网格系统上布局表单。`placeholder`属性是 HTML5 中的一个特性，当没有内容时，它会在输入中显示水印。

# 显示记录（中间）

随着内容进入数据库，让我们将其取出，如下图所示：

![Displaying a record (Intermediate)](images/9628OS_01_03.jpg)

## 准备好了吗

我们将从`sched`文件夹中的`app.py`文件和`templates`目录继续工作。

## 怎么做。。。

1.  我们在`app.py`：

    ```py
    # Note the import statements from the previous section.

    @app.route('/appointments/<int:appointment_id>/')
    def appointment_detail(appointment_id):
      """Provide HTML page with a given appointment."""
      # Query: get Appointment object by ID.
      appt = db.session.query(Appointment).get(appointment_id)
      if appt is None:
        # Abort with Not Found.
        abort(404)
      return render_template('appointment/detail.html',
        appt=appt)
    ```

    中提供了一个通过数据库 ID 获取约会的简单查询
2.  让我们采用相同的宏方法来显示约会。模板宏将为我们提供一个工具，在需要时随时显示约会。在`templates/appointment/common.html`：

    ```py
    {% macro detail(appt,
      link_title=false,
      show_edit=true,
      show_description=true) %}
    <div class="appointment-detail">
      {% if link_title %}
        <h3>
          <a href="{{ url_for('appointment_detail',
            appointment_id=appt.id) }}">
            {{ appt.title }}</a>
        </h3>
      {% else %}
        <h3>{{ appt.title }}</h3>
      {% endif %}
      {% if appt.location %}
        <p><i class="icon-home"></i> {{ appt.location }}</p>
      {% endif %}
      {% if appt.allday %}
        <p><i class="icon-calendar"></i> {{ appt.start | date }}</p>
      {% else %}
        <p><i class="icon-calendar"></i> {{ appt.start | datetime }}
          for {{ appt.duration | duration }}</p>
      {% endif %}
      {% if show_edit %}
      <div class="edit-controls">
        <i class="icon-pencil"></i>
        <a href="{{ url_for('appointment_edit',
          appointment_id=appt.id) }}">Edit</a>
        <span class="inline-pad"></span>
        <i class="icon-trash"></i>
        <a class="appointment-delete-link" href="#"
          data-delete-url="{{ url_for('appointment_delete',
          appointment_id=appt.id) }}">Delete</a>
      </div>
      {% endif %}
      {% if show_description and appt.description %}
      <div class="row">
        <p class="span5">{{ appt.description | nl2br }}</p>
      </div>
      {% endif %}
    </div>
    {% endmacro %}
    ```

    中
3.  然后我们可以使用`templates/appointment/detail.html`：

    ```py
    {% extends 'base.html' %}

    {% from 'appointment/common.html' import detail %}

    {% block title %}
      {{ appt.title }}
    {% endblock title %}

    {% block main %}
    <div class="row">
      <div class="span12">
        {{ detail(appt) }}
      </div>
    </div>
    {% endblock main %}
    ```

    中的宏

## 它是如何工作的。。。

如果请求的数据库 ID 不存在，我们会告诉 Flask 使用**404 not Found**响应中止。`flask.abort`函数是作为一个异常实现的，因此当调用`abort`时，Python 将在当前函数中停止执行。

我们还将为 Jinja 命名过滤器实现一些实用程序，这些实用程序在 Python 对象进入模板输出之前以`{{ foo | filter }}`的形式格式化 Python 对象的输出。我们将构建过滤器`date`、`datetime`、`duration`和`nl2br.`，在实现这些过滤器的第一次过程中，只需从模板中省略这些过滤器即可；使用`{{ appt.start }}`代替`{{ appt.start | date }}`。这将使您更清楚地了解我们为什么要构建过滤器。

对于可能不存在的单个字段，我们使用 Python 的`or`行为。当用于显示或赋值时，`or`表达式是“快捷方式”，直到命中一个真值，然后使用该值。这种方法允许我们以简单的方式提供默认显示值。

# 编辑记录（中级）

现在，我们为现有约会提供了一个编辑页面，如以下屏幕截图所示：

![Editing a record (Intermediate)](images/9628OS_01_02.jpg)

## 准备好了吗

我们将从`sched`目录和`templates`目录中的`app.py`文件继续工作。

## 怎么做。。。

1.  编辑工作流是添加视图和详图视图的混合。我们得到一个约会，如果它存在，我们会显示一个表单来编辑它。在`app.py`：

    ```py
    @app.route('/appointments/
      <int:appointment_id>/edit/,
      methods=['GET', 'POST'])

    def appointment_edit(appointment_id):
      """Provide HTML form to edit a given appointment."""
      appt = db.session.query(Appointment).get(appointment_id)
      if appt is None:
        abort(404)
      form = AppointmentForm(request.form, appt)
      if request.method == 'POST' and form.validate():
        form.populate_obj(appt)
        db.session.commit()
        # Success. Send the user back to the detail view.
        return redirect(url_for('appointment_detail',
          appointment_id=appt.id))
        return render_template('appointment/edit.html', form=form)
    ```

    中
2.  在`templates/appointment/edit.html`：

    ```py
    {% if request.endpoint.endswith('edit') %}
      {% set title = 'Edit Appointment' %}
    {% else %}
      {% set title = 'Add Appointment' %}
    {% endif %}
    ```

    中

## 它是如何工作的。。。

我们重复使用与创建表单相同的模板，但是我们说的是**编辑**，而不是**添加**。因为这是非常简单的逻辑，所以我们可以在模板中使用一个`if`语句。Flask 允许我们检查模板中的请求对象。如果你发现你的项目做了大量的请求检查，你应该考虑一个设计模式，把这个逻辑移回你的 Python 代码。

# 列出所有记录（简单）

我们不希望用户跟踪其约会的数据库 ID，因此我们提供了一个视图，该视图将列出他们的所有约会，如以下屏幕截图所示：

![Listing all records (Simple)](images/9628OS_01_04.jpg)

## 准备好了吗

我们将从`sched`目录和`templates`目录中的`app.py`文件继续工作。

## 怎么做。。。

1.  我们在`app.py`：

    ```py
    @app.route('/appointments/')
    def appointment_list():
      """Provide HTML listing of all appointments."""
      # Query: Get all Appointment objects, sorted by date.
      appts = (db.session.query(Appointment)
        .order_by(Appointment.start.asc()).all())
      return render_template('appointment/index.html',
        appts=appts)
    ```

    中查询所有预约
2.  在`templates/appointment/index.html`：

    ```py
    {% extends 'base.html' %}

    {% from 'appointment/common.html' import detail %}

    {% block title %}Appointments{% endblock title %}

    {% block main %}
    <div class="row">
      {% for appt in appts %}
        <div class="span12">
        {{ detail(appt,
          link_title=true,
          show_edit=false,
          show_description=false) }}
        </div>
      {% else %}
        <h3 class="span12">No appointments.</h3>
      {% endfor %}
    </div>
    {% endblock main %}
    ```

    中

## 它是如何工作的。。。

我们按照预约开始时间的升序查询所有预约。SQLAlchemy 声明性类包括列属性的帮助器，这些属性允许我们提供 SQL 子句，这里用`.asc()`表示`sort`字段。在约会列表模板中，我们迭代所有约会记录，重用显示宏，并使用我们创建的呼叫签名关闭仅适用于详细视图的功能。

## 还有更多。。。

我们保持约会清单的简单。如果您不熟悉数据库标识符，您可能想知道约会 URL 是如何生成的。

### 数据库标识符

关于这些数据库 ID 的注意事项：它们是由我们的数据库管理系统和 SQLAlchemy 生成的系统。也就是说，它们在我们的应用程序之外毫无意义。ID 有助于创建良好的 URL，但不利于人类记忆。在这个视图中，您可以创造性地使用日、周、月和年日历隐喻。您可以这样做，但这将主要存在于 HTML、CSS 和 JavaScript 中。对于简单的调度程序应用程序，我们只需在列表中列出约会。

# 删除记录（高级）

我们都准备好了约会互动。等待我们如何删除约会？

## 准备好了吗

我们将从`sched`的`app.py`文件和`templates`目录继续工作。

## 怎么做。。。

1.  我们在`app.py`：

    ```py
    @app.route('/appointments/
      <int:appointment_id>/delete/',
      methods=['DELETE'])

    def appointment_delete(appointment_id):
      """Delete record using HTTP DELETE, respond with JSON."""
      appt = db.session.query(Appointment).get(appointment_id)
      if appt is None:
        # Abort with Not Found, but with simple JSON response.
        response = jsonify({'status': 'Not Found'})
        response.status = 404
        return response
      db.session.delete(appt)
      db.session.commit()
      return jsonify({'status': 'OK'})
    ```

    中构建了一个 Ajax 处理程序
2.  在`templates/base.html`：

    ```py
    <script>
     $(function() {
      $(".appointment-delete-link").on("click", function() {
        var delete_url = $(this).attr('data-delete-url');
        $.ajax({
          url: delete_url,
          type: 'DELETE',
          success: function(response) {
            if (response.status == 'OK') {
              window.location = {{ url_for('appointment_list') }};
            } else {
            alert('Delete failed.')
          }
        }
        });
        return false;
      });
    });
    </script>
    ```

    中，一个小 jQuery 将连接所有删除链接以使用此处理程序

## 它是如何工作的。。。

我们提供了我们的第一个视图函数，它不呈现 HTML，但使用最小的 Ajax 与 JSON 交互。它接受 HTTP DELETE 请求并执行这项工作。我们不必通过 GET 请求公开删除功能，这会让用户通过浏览不小心删除数据库记录。当我们发布可以被搜索引擎和其他机器人点击的代码时，这一点尤为重要。抓取我们所有的网页将删除我们的整个数据库！Flask 提供了一个`jsonify`函数，将 Python 字典转换为 JSON 响应。

如何让浏览器发送删除请求？使用 JavaScript。jQuery 库使得 Ajax 调用比 JavaScript 本身简单得多。我们添加了一个 jqueryhook，它将获取所有的 delete 链接，并在单击链接时提交一个 ajax 调用。单击回调从删除链接获取删除 URL，并将其作为删除请求发送。成功后，它会将当前浏览器窗口重定向到约会列表。通过将此脚本放入基本模板，它将使约会列表和详细信息页面上的所有删除链接都起作用。

## 还有更多。。。

这里我们只简单介绍 Ajax；它值得一整本书。

### 阿贾克斯

Ajax 仅仅意味着我们呈现一个 web 页面，并让浏览器与我们的 web 服务进行通信，而不必重新加载页面。也就是说，渲染页面一次，并更新页面上显示的内容，而不刷新整个页面。这最初被称为 AJAX，表示“异步 JavaScript 和 XML”，但现在已经成为 web 开发人员的常用词，可以表示任何序列化格式，这里是 JSON 而不是 XML。

# 在 Jinja 中使用自定义模板过滤器（高级）

为了包装我们的模板，我们需要清理一些字段的显示。

## 准备好了吗

我们从`sched`目录移动到`filters.py`文件，并再次使用`app.py`。

## 怎么做。。。

1.  我们希望以干净的格式显示时间。在`filters.py`：

    ```py
    def do_datetime(dt, format=None):
      """Jinja template filter to format a datetime object."""
      if dt is None:
        # By default, render an empty string.
        return ''
      if format is None:
        # No format is given in the template call.
        # Use a default format.
        #
        # Format time in its own strftime call in order to:
        # 1\. Left-strip leading 0 in hour display.
        # 2\. Use 'am'/'pm' (lower case) instead of 'AM'/'PM'.
        formatted_date = dt.strftime('%Y-%m-%d - %A')
        formatted_time =\
          dt.strftime('%I:%M%p').lstrip('0').lower()
        formatted = '%s at %s' %\
          (formatted_date, formatted_time)
      else:
        formatted = dt.strftime(format)
      return formatted
    ```

    中
2.  在这里添加更多过滤器，并提供一个钩子来初始化 Flask 应用程序。

    ```py
    def init_app(app):
      """Initialize a Flask application with custom filters."""
      app.jinja_env.filters['datetime'] = do_datetime
    ```

3.  使用`app.py`：

    ```py
    from sched import filters
    filters.init_app(app)
    ```

    中的初始化钩子

## 它是如何工作的。。。

Jinja 支持一个环境，其中 Python 函数在模板中作为过滤器提供。我们的约会中有一个`datetime`字段，所以我们为它提供了一些格式。您可以直接在模板`{{ dt.strftime('%Y-%m-%d') }}`中调用属性和方法，但通过定义过滤器，我们可以指定如何在仍然公开参数的情况下集中设置所有日期的格式。您可以使用我们的 datetime 筛选器调用`{{ dt | datetime }}`以获取我们定义的默认功能，以及`{{ dt | datetime('%Y-%m-%d') }}`，其中模板调用中的参数在筛选值后作为参数传入。

## 还有更多。。。

您可以在 Packt 网站上下载的源代码文件中找到过滤器的完整代码。

### 附加过滤器

`sched`的完整源代码包括用于默认日期格式、约会记录的持续时间格式的过滤器，以及用于在约会描述字段中保留用户输入的换行符的`nl2br`过滤器（因为 HTML 规范化了空白）。

# 发送错误响应（简单）

在本节中，我们将向具有样式的用户发送一个错误页面。

## 准备好了吗

我们从项目的`sched`目录中的`app.py`文件开始工作，在`sched`目录中的`templates`目录中工作。在`templates`目录中创建一个名为`error`的目录。

## 怎么做。。。

1.  When the user hits a **Not Found** page, we want to display a page that will direct them back to the appointment list. You can tell Flask how to render responses for error cases, typically for HTTP error codes. We will provide a custom 404 Not Found page as shown in the following screenshot:

    ![How to do it...](images/9628OS_01_05.jpg)

2.  Flask 提供了`app.errorhandler`来告诉 Flask 如何处理某些类型的错误，可以使用`4xx`或`5xx`HTTP 状态代码或 Python 异常类。修饰一个接受`Exception`实例并返回响应的函数。通过在元组响应中提供带有呈现模板字符串的`404`，确保在 Flask 响应中包含 HTTP 状态代码。在下面的代码中，我们呈现一个未找到的模板，它提供了一个指向约会列表的链接。在`app.py`：

    ```py
    @app.errorhandler(404)
    def error_not_found(error):
      return render_template('error/not_found.html'), 404
    ```

    中
3.  在`templates/error/not_found.html`：

    ```py
    {% extends 'base.html' %}

    {% block title %}Not Found{% endblock title %}

    {% block main %}
    <h2>Not Found</h2>
    {% endblock main %}
    ```

    中

基本模板中的`navbar`元素将帮助用户导航回已知页面。

## 它是如何工作的。。。

`app.errorhandler`装饰器接受异常类或 HTTP 状态代码作为整数。下面是一些 HTTP 状态代码，让您开始使用。您可以将它们与视图中的`flask.abort(status_code)`函数一起使用，直接跳转到错误响应，并定义自定义`app.errorhandler`以提供样式化响应。

*   400 错误请求
*   401 未经授权
*   403 禁止
*   404 找不到
*   405 方法不允许（您可能忘记了路由中的方法）
*   410 走了（再也没有回来）
*   500 内部服务器错误

完整列表见[www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。

只要代码有未捕获的异常，`500`错误处理程序就会显示。

## 还有更多。。。

Flask 提供了一个非常有用的调试器来检查开发中的错误。

### 处理特定异常

您可以提供有关 Python 异常的自定义错误页：

```py
class SchedulingException(Exception):
  """Some application-specific error has occurred."""
  pass

@app.errorhandler(SchedulingException)
def scheduling_exception_handler(error):
  return 'Just a demo of app.errorhandler...', 500

@app.route('/test_error/')
def test_error():
  raise SchedulingException('Use my custom error handler.')
```

### 烧瓶调试器

这是讨论 Flask 调试器的好地方。当 Flask 应用程序将`app.config['DEBUG']`设置为`True`时，应用程序代码中任何未捕获的异常都将在浏览器中显示一个开发人员友好的调试器。此调试器使 Python 堆栈跟踪具有交互性，允许您在堆栈框架中的任意点运行代码，并在上下文中查看代码。

在`app.py`中：

```py
app = Flask(__name__)
app.config['DEBUG'] = True
```

您可以故意触发异常，以便快速查看堆栈。在 web 浏览器中写入异常并点击路由。我最喜欢的两个例外是：

```py
1/0 # Divide by zero to get an exception.
raise Exception("Don't Panic!")
```

仅在安全机器上的开发中使用此选项，因为交互式解释器允许从浏览器执行 Python 代码。如果交互式解释器在浏览器中没有响应，则表示开发服务器已关闭或已转到新请求，忘记了错误。

# 验证用户（高级）

到目前为止，我们假设任何能够访问`sched`应用程序的人都应该能够在数据库中创建、显示、编辑、列出和删除约会记录。我们的 Flask 应用程序需要对用户进行身份验证并保护我们的数据库。

## 准备好了吗

我们返回到我们项目的`sched`目录中的`models.py`文件。

## 怎么做。。。

1.  我们首先在`models.py`：

    ```py
    from datetime import datetime

    from sqlalchemy import Column
    from sqlalchemy import Boolean, DateTime, Integer, String
    from sqlalchemy.orm import synonym
    from sqlalchemy.ext.declarative import declarative_base
    from werkzeug import check_password_hash
    from werkzeug import generate_password_hash

    Base = declarative_base()

    class User(Base):
      """A user login, with credentials and authentication."""
      __tablename__ = 'user'

      id = Column(Integer, primary_key=True)
      created = Column(DateTime, default=datetime.now)
      modified = Column(DateTime, default=datetime.now,
        onupdate=datetime.now)

      name = Column('name', String(200))
      email = Column(String(100), unique=True, nullable=False)
      active = Column(Boolean, default=True)
    ```

    中为具有唯一电子邮件地址的用户创建一个数据库记录
2.  然后，我们添加了一种存储密码散列的方法（在用户定义中继续）：

    ```py
      _password = Column('password', String(100))

      def _get_password(self):
        return self._password

      def _set_password(self, password):
        if password:
          password = password.strip()
        self._password = generate_password_hash(password)

      password_descriptor = property(_get_password,
        _set_password)
      password = synonym('_password',
        descriptor=password_descriptor)
    ```

3.  最后，我们添加了验证密码的方法（在用户定义中继续）：

    ```py
      def check_password(self, password):
        if self.password is None:
          return False
        password = password.strip()
        if not password:
          return False
        return check_password_hash(self.password, password)

      @classmethod
      def authenticate(cls, query, email, password):
        email = email.strip().lower()
        user = query(cls).filter(cls.email==email).first()
        if user is None:
          return None, False
        if not user.active:
          return user, False
        return user, user.check_password(password)
    ```

## 它是如何工作的。。。

我们需要一个存储用户记录的地方，以便我们可以验证身份验证请求是否针对应用程序中的有效用户。但是，我们不希望以明文形式存储密码，这会让任何对数据库表具有读取权限的人知道如何作为应用程序中的有效用户登录。这在您第一次想到这个想法时似乎并不重要，但您不想承担存储每个人的密码的责任，特别是当用户在应用程序中重复使用密码时。（这应该是一个提示，说明为什么这是一个坏主意。）

Werkzeug 提供了散列密码的实用程序，并验证提供的密码是否与该散列匹配。我们存储的是散列，而不是明文密码。只要在`User`实例上设置了`user.password`，就会立即使用 Python 描述符和 SQLAlchemy 的同义词 hook 对密码进行哈希运算。同义词让我们让`user.password`的行为与其他所有 SQLAlchemy 对象属性一样，但当访问`user.password`时，获取值将调用`_get_password`，设置它将调用`_set_password`，它将存储散列值。

我们现在可以使用电子邮件、密码和带有`User.authenticate(query, email, password)`的 SQLAlchemy 查询对象进行身份验证，该对象返回一个`user, bool`对（元组），其中`user`是匹配的用户对象，布尔值指示身份验证是否有效。

## 还有更多。。。

我们需要将电子邮件/密码身份验证集成到应用程序中。

### 预约关系

我们可以在约会和用户之间建立关系，以便在加载时间表时只显示当前用户的约会。更新`models.py`中的`Appointment`类，使其包含与`User`的外键关系：

```py
class Appointment(Base):
  # ... existing code.
  user_id = Column(Integer,
    ForeignKey('user.id'), nullable=False)
  user = relationship(User, lazy='joined', join_depth=1)
  # ... existing code.
```

访问`Appointment`对象现在将为该约会的所有者提供`appointment.user`属性来访问`User`对象。因为我们使用了`ForeignKey`，SQLAlchemy 知道在访问`Appointment`对象时如何获取相关的`User`记录。

### 开课

HTTP 是无状态的，这意味着一个请求没有关于先前请求的信息。我们需要打开一个从一个请求到另一个请求保留的会话，这样我们就可以在一个请求中对用户进行身份验证，并在用户在给定会话中发出的以下每个请求中使用该身份验证。

在下一节中，我们将看到如何处理会话，在代码中添加一个`current_user`对象，它将表示与当前已验证用户匹配的`User`数据库对象。现在我们已经在`models.py`中添加了`User`和`Appointment`之间的关系，我们需要为创建或检索`Appointment`对象的每种情况更新`app.py`。将`Appointment`对象创建行更改为：

```py
appt = Appointment(user_id=current_user.id)
```

然后在检索记录时验证当前`Appointment`是否为当前用户：

```py
if appt.user_id != current_user.id:
  abort(403)
```

### 数据库迁移

更改`models.py`意味着我们需要更新我们在开发中使用的数据库的数据库结构，如果我们已经部署了`sched`应用程序，则需要更新生产数据库。如果我们所做的唯一更改是添加表，那么我们只需再次调用`Base.metadata.create_all(engine)`。

有时在开发中，这是最简单的方法：只需销毁开发数据库，再次运行`create_all`，然后再次开始添加数据。设置初始开发或测试数据可能很麻烦，因此您可能希望投资于**装置**，在运行应用程序开发服务器之前加载这些装置。Python 社区中有几个项目可以实现这一点，包括位于[pypi.Python.org/pypi/fixture](http://pypi.python.org/pypi/fixture)的`fixture`。

对于列更改，我们需要提供一种自动化来更改实时数据库，特别是对于人们正在使用的生产数据库。如果您熟悉 SQL，您可以编写自己的`ALTER TABLE`语句并提供自己的脚本。如果您想要一个工具包来管理这个问题，SQLAlchemy 的创建者 Mike Bayer 已经编写了 Alembic 作为在 SQLAlchemy 中执行迁移的工具，[Alembic.readthedocs.org](http://alembic.readthedocs.org)。

### 使用现有服务进行身份验证

新用户是如何开始的？在`sched`的用户身份验证就绪后，您需要提供一种向您的应用程序注册用户的方法。这可以像从 Python 交互式解释器创建`User`对象一样简单，也可以是应用程序中的用户注册表单。

或者，您可以将`User`实现简化为所需的核心应用程序数据，并使用现有服务对用户进行外部身份验证，在第一次此类身份验证时创建新的`User`对象。这将使用户不必记住另一个密码，并加快用户获取过程。

OpenID（[OpenID.net](http://openid.net)提供了一个开放标准来执行这种类型的身份验证。像谷歌这样的流行服务有自己的文档，用于使用现有用户帐户进行身份验证和授权，[developers.Google.com/accounts/](http://developers.google.com/accounts/)。

# 处理会话和用户（中级）

由于 HTTP 是无状态的，我们需要通过会话跨请求跟踪一些数据。

## 准备好了吗

我们将继续从`sched`目录中的`app.py`文件和`models.py`文件进行工作。

## 怎么做。。。

1.  Flask 提供了一个`session`对象，其行为类似于 Python 字典，并在请求之间自动保持。您可以，在您的烧瓶申请代码中：

    ```py
    from flask import session
    # ... in a request ...
    session['spam'] = 'eggs'
    # ... in another request ...
    spam = session.get('spam') # 'eggs'
    ```

2.  Flask 登录提供了在 Flask 会话中跟踪用户的简单方法。更新 requirements.txt:

    ```py
    Flask
    Flask-Login
    Flask-Script
    Flask-SQLAlchemy
    WTForms
    ```

3.  然后：

    ```py
    $ pip install -r requirements.txt

    ```

4.  然后，我们可以在`app.py`：

    ```py
    from flask.ext.login import LoginManager, current_user
    from flask.ext.login import login_user, logout_user
    from sched.models import User

    # Use Flask-Login to track current user in Flask's session.
    login_manager = LoginManager()
    login_manager.setup_app(app)
    login_manager.login_view = 'login'

    @login_manager.user_loader
    def load_user(user_id):
      """Flask-Login hook to load a User instance from ID."""
      return db.session.query(User).get(user_id)
    ```

    中将 Flask 登录加载到`sched`的请求处理中
5.  Flask-Login requires four methods on the `User` object, inside `class User` in `models.py`:

    ```py
      def get_id(self):
        return str(self.id)

      def is_active(self):
        return True

      def is_anonymous(self):
        return False

      def is_authenticated(self):
        return True
    ```

    ### 提示

    Flask 登录提供了一个**UserMixin**（`flask.ext.login.UserMixin`），如果您愿意使用它的默认实现。

6.  然后，我们提供用户在经过身份验证后登录和注销的路由。在`app.py`：

    ```py
    @app.route('/login/', methods=['GET', 'POST'])
    def login():
      if current_user.is_authenticated():
        return redirect(url_for('appointment_list'))
      form = LoginForm(request.form)
      error = None
      if request.method == 'POST' and form.validate():
        email = form.username.data.lower().strip()
        password = form.password.data.lower().strip()
        user, authenticated = \
          User.authenticate(db.session.query, email,
            password)
        if authenticated:
          login_user(user)
          return redirect(url_for('appointment_list'))
        else:
          error = 'Incorrect username or password.'
        return render_template('user/login.html',
          form=form, error=error)

    @app.route('/logout/')
    def logout():
      logout_user()
      return redirect(url_for('login'))
    ```

    中
7.  然后，我们在`app.py`：

    ```py
    from flask.ext.login import login_required
    @app.route('/appointments/')
    @login_required
    def appointment_list():
      # ...
    ```

    中装饰每个需要有效用户的视图函数

## 它是如何工作的。。。

在`login_user`上，Flask Login 从`User.get_id`获取用户对象的 ID，并将其存储在 Flask 的会话中。Flask Login 然后设置一个`before_request`处理程序，使用我们提供的`load_user`钩子将用户实例加载到`current_user`对象中。然后，`logout_user`功能从会话中删除相关位。

如果没有用户登录，`current_user`将提供一个匿名用户对象，导致`current_user.is_anonymous()`返回`True`和`current_user.is_authenticated()`返回`False`，允许应用程序和模板代码根据用户是否有效进行逻辑推理。（Flask Login 将`current_user`放入所有模板上下文中。）您可以使用`User.is_active`使用户帐户无效，而不实际删除它们，根据需要返回`False`。

如果当前用户未通过身份验证，则使用`login_required`修饰的视图函数将用户重定向到登录视图，而不调用修饰函数。

## 还有更多。。。

Flask 的会话支持显示消息和防止请求伪造。

### 闪烁信息

当您想要显示一条简单的消息以快速指示操作成功或失败时，可以使用 Flask 的 flash 消息，它将消息加载到会话中，直到检索到消息为止。在应用程序代码中，内部请求处理代码：

```py
from flask import flash
flash('Sucessfully did that thing.', 'success')

```

在模板代码中，可以使用 `'success'`类别进行条件显示：

```py
{% for cat, m in get_flashed_messages(with_categories=true) %}
 <div class="alert">{{ m }}</div>
{% endfor %}
```

### 跨站点请求伪造保护

恶意 web 代码将试图伪造对其他 web 服务的数据更改请求。为了防止伪造，您可以将随机令牌加载到会话和 HTML 表单中，并在两者不匹配时拒绝请求。这在 Flask SeaSurf 扩展名[pythonhosted.org/Flask-SeaSurf/](http://pythonhosted.org/Flask-SeaSurf/)或 Flask WTF 扩展名[pythonhosted.org/Flask-ETF/](http://pythonhosted.org/Flask-ETF/)中提供。

# 向世界部署（先进）

一旦您对应用程序感到满意，您就可以部署您的应用程序，该应用程序将向全世界提供。

## 准备好了吗

您需要一台目标用户可以在线访问的计算机。安装 Python 并将`requirements.txt`放在一个您可以使用命令行访问的文件夹中，就像我们对您的开发环境所做的那样（virtualenv 适合于生产环境），然后创建数据库表。您可以部署到任何操作系统：Windows 和任何类似 Unix 的系统（包括 Mac OS X）。

## 怎么做。。。

1.  从一个干净的 Ubuntu 12.04 服务器安装：

    ```py
    $ sudo apt-get update && sudo apt-get install nginx
    $ # Load config into /etc/nginx/sites-available/default
    $ sudo service nginx restart
    $ pip install gunicorn
    $ gunicorn --access-logfile - -b 127.0.0.1:5000 sched.app:app

    ```

2.  在 virtualenv 中使用`pip`和`gunicorn`程序。加载到 nginx 配置中，将 localhost 更改为您的域名（如果有）：

    ```py
    server {
      listen 80;
      server_name localhost;
      access_log  /var/log/nginx/access.log;
      error_log  /var/log/nginx/error.log;
      location / {
        proxy_pass http://127.0.0.1:5000/;
        proxy_redirect off;
        proxy_set_header Host            $host;
        proxy_set_header X-Real-IP       $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      }
    }
    ```

3.  然后将 gunicorn 进程添加到服务器的引导顺序中，而不是手动运行它。请参阅操作系统的文档。对于类 Unix 系统，supervisord 提供对长时间运行的应用程序的管理，[supervisord.org](http://supervisord.org)。

## 它是如何工作的。。。

只要 nginx 接收到匹配的请求，它就会向运行在端口`5000`上的 HTTP 服务器发送代理请求，该端口在我们的应用程序中是 gunicorn，并传递响应。请注意，gunicorn 不会在代码更新时自动重新加载应用程序。您可以按照[docs.gunicorn.org/en/latest/faq.html](http://docs.gunicorn.org/en/latest/faq.html)中的说明重新加载过程信号。

更多文档请参见[docs.gunicorn.org/en/latest/deploy.html](http://docs.gunicorn.org/en/latest/deploy.html)。

## 还有更多。。。

部署有很多选择；配置完全取决于您的项目。

### 使用 nginx 处理静态文件

为了方便起见，Flask 提供了一个静态文件处理程序。现在我们已经有了一个优化的 HTTP 服务器，我们可以让它直接为静态文件服务。下面的配置块显示了如何使用 nginx 提供静态文件，并将所有其他请求代理到 Flask。根据您的设置调整配置：

*   从项目布局中将`/var/www/myproject`更改为包含`sched`文件夹的文件路径。
*   更改`/static/`如果您更改了 Flask 中的默认静态路由。

更新的服务器配置，以处理静态文件：

```py
server {
  listen 80;
  server_name localhost;
  access_log  /var/log/nginx/access.log;
  error_log  /var/log/nginx/error.log;
  location  /static/ {
    # /static/ is appended to root path on the request.
    root /var/www/myproject/sched/;
  }
  location / {
    proxy_pass http://127.0.0.1:5000/;
    proxy_redirect off;
    proxy_set_header Host            $host;
    proxy_set_header X-Real-IP       $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
```

### 可通过 HTTP 代理部署在任何操作系统上

我更喜欢在生产环境中使用 HTTP 代理运行应用程序，应用程序代码由独立的操作系统进程提供服务。大多数工业级 HTTP 服务器都包括一种将请求代理到另一个 web 服务的方法，正如我们在 nginx 中演示的那样。gunicorn 仅在类 Unix 系统上运行，但 cherrypy（[cherrypy.org](http://cherrypy.org)提供了一个跨平台的 WSGI 服务器。您可以使用以下示例所示的脚本启动应用程序：

```py
from cherrypy.wsgiserver import CherryPyWSGIServer
from sched.app import app
server = CherryPyWSGIServer(('127.0.0.1', 5000), app)
server.start()
```

### Windows 服务器部署

要在 Windows Server IIS 中直接运行 Python 应用程序，请参阅位于[NWSGI.codeplex.com](http://nwsgi.codeplex.com)的 NWSGI 项目。

### 其他部署选项

参见[Flask.pocoo.org/docs/deploying/](http://flask.pocoo.org/docs/deploying/)上的烧瓶文档。