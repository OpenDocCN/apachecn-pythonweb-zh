# 第二章，这个代码有效吗？深度博士

在第一章中，我们学习了如何运行由`manage.py startapp`创建的样本测试。尽管我们使用了 Django 实用程序来运行测试，但对于 Django 来说，样本测试本身并没有什么特殊之处。在本章中，我们将开始详细介绍如何为 Django 应用程序编写测试。我们将：

*   通过开发项目将使用的一些基本模型，开始编写第一章中创建的市场研究项目
*   尝试向其中一个模型添加 doctest
*   开始学习有用的测试类型，以及只会给代码增加混乱的测试类型
*   发现博士的一些优点和缺点

虽然前一章提到了 doctest 和单元测试，但本章的重点将仅限于 doctest。为 Django 应用程序开发单元测试将是[第 3 章](03.html "Chapter 3. Testing 1, 2, 3: Basic Unit Testing")、*测试 1、2、3：基本单元测试*和[第 4 章](04.html "Chapter 4. Getting Fancier: Django Unit Test Extensions")、*越来越喜欢 Django 单元测试扩展*的重点。

# 调查应用模型

开始开发新的 Django 应用程序的一个常见地方是模型：由应用程序操作和存储的数据的基本构建块。我们的示例市场研究`survey`应用程序的基石模型将是`Survey`模型。

`Survey`将类似于 Django 教程`Poll`模型，除了：

*   如果教程`Poll`只包含一个问题，`Survey`将有多个问题。
*   `Survey`将有一个标题供参考。对于教程`Poll`，可以用一个问题来回答这个问题。
*   `Survey`只会在有限的时间内（和可变的时间，取决于`Survey`实例）对响应打开。虽然`Poll`模型有一个`pub_date`字段，但除了在索引页上订购`Polls`之外，它不用于任何其他用途。因此，`Survey`将需要两个日期字段，其中`Poll`只有一个，并且`Survey`日期字段的使用将多于`Poll pub_date`字段的使用。

考虑到`Survey`的这些简单需求，我们可以开始为其开发 Django 模型。具体地说，我们可以通过将以下内容添加到为我们的`survey`应用程序自动生成的`models.py`文件中，在代码中捕获这些需求：

```py
class Survey(models.Model): 
    title = models.CharField(max_length=60) 
    opens = models.DateField() 
    closes = models.DateField() 
```

请注意，由于`Survey`可能有几个问题，因此它没有问题字段。取而代之的是一个单独的模型`Question`，用于将问题与他们相关的调查实例一起保存：

```py
class Question(models.Model): 
    question = models.CharField(max_length=200) 
    survey = models.ForeignKey(Survey) 
```

我们需要的最后一个模型（至少从一开始）是保存每个问题的可能答案，并跟踪调查对象选择每个答案的次数。此模型`Answer`与教程`Choice`模型非常相似，只是它与`Question`相关，而不是与`Poll`相关：

```py
class Answer(models.Model): 
    answer = models.CharField(max_length=200) 
    question = models.ForeignKey(Question) 
    votes = models.IntegerField(default=0) 
```

# 测试调查模型

如果你和我一样，在这一点上，你可能想开始验证你到目前为止所得到的是正确的。诚然，目前还没有太多的代码，但特别是在刚开始一个项目时，我喜欢尽早并且经常地确保我到目前为止所得到的是有效的。那么，我们现在如何开始测试呢？首先，我们可以通过运行`manage.py syncdb`来验证我们没有语法错误，这也将让我们开始在 Python shell 中试验这些模型。让我们这样做吧。由于这是我们第一次为这个项目运行`syncdb`，我们将收到关于为`INSTALLED_APPS`中列出的其他应用程序创建表的消息，我们将被询问是否要创建超级用户，我们也可以继续这样做。

## 测试测量模型创建

现在，我们可以对这些模型做些什么来在 Python shell 中测试它们呢？实际上，除了创建每一个字段之外，可能还要验证如果不指定其中一个字段，是否会出现错误，或者是否分配了正确的默认值，以及验证是否可以遍历模型之间的关系。如果我们首先关注`Survey`模型，以及为了测试它的创建，我们可能会做些什么，那么针对该模型的 Python shell 会话可能如下所示：

```py
kmt@lbox:/dj_projects/marketr$ python manage.py shell 
Python 2.5.2 (r252:60911, Oct  5 2008, 19:24:49) 
[GCC 4.3.2] on linux2 
Type "help", "copyright", "credits" or "license" for more information. 
(InteractiveConsole) 
>>> from survey.models import Survey 
>>> import datetime 
>>> t = 'First!'
>>> d = datetime.date.today()
>>> s = Survey.objects.create(title=t, opens=d, closes=d) 
>>>

```

在这里，我们首先导入我们的`Survey`模型和 Python`datetime`模块，然后创建一个变量`t`来保存标题字符串和一个变量`d`来保存日期值，并使用这些值创建一个`Survey`实例。没有报告错误，因此看起来不错。

如果我们想要验证，如果我们试图创建一个没有结束日期的`Survey`，是否会出现错误，我们将继续：

```py
>>> s = Survey.objects.create(title=t, opens=d, closes=None) 
 File "<console>", line 1, in <module> 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 126, in create 
 return self.get_query_set().create(**kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 315, in create 
 obj.save(force_insert=True) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 410, in save 
 self.save_base(force_insert=force_insert, force_update=force_update) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 495, in save_base 
 result = manager._insert(values, return_id=update_pk) 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 177, in _insert 
 return insert_query(self.model, values, **kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 1087, in insert_query 
 return query.execute_sql(return_id) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/subqueries.py", line 320, in execute_sql 
 cursor = super(InsertQuery, self).execute_sql(None) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/query.py", line 2369, in execute_sql 
 cursor.execute(sql, params) 
 File "/usr/lib/python2.5/site-packages/django/db/backends/util.py", line 19, in execute 
 return self.cursor.execute(sql, params) 
 File "/usr/lib/python2.5/site-packages/django/db/backends/sqlite3/base.py", line 193, in execute 
 return Database.Cursor.execute(self, query, params) 
IntegrityError: survey_survey.closes may not be NULL 

```

在这里，我们对`Survey`实例创建尝试所做的不同之处在于为`closes`值指定`None`，而不是传入日期变量`d`。由于调查表的 closes 列不能为空，因此结果是一个错误，以报告`IntegrityError`的消息结尾。这证实了我们对应该发生的事情的预期，因此到目前为止一切都很好。然后，我们可以对其他字段执行类似的测试，并看到相同的回溯报告其他列的`IntegrityError`。

如果我们愿意，我们可以将这些测试从 shell 会话中直接剪切并粘贴到我们的`survey/models.py`文件中，从而使它们成为我们模型定义的永久部分，如下所示：

```py
import datetime
from django.db import models 

class Survey(models.Model): 
    """ 
    >>> t = 'First!' 
    >>> d = datetime.date.today() 
    >>> s = Survey.objects.create(title=t, opens=d, closes=d) 
    >>> s = Survey.objects.create(title=t, opens=d, closes=None) 
    Traceback (most recent call last): 
    ... 
    IntegrityError: survey_survey.closes may not be NULL 
    >>> s = Survey.objects.create(title=t, opens=None, closes=d) 
    Traceback (most recent call last): 
    ... 
    IntegrityError: survey_survey.opens may not be NULL 
    >>> s = Survey.objects.create(title=None, opens=d, closes=d) 
    Traceback (most recent call last): 
    ... 
    IntegrityError: survey_survey.title may not be NULL 
    """ 
    title = models.CharField(max_length=60) 
    opens = models.DateField() 
    closes = models.DateField()
```

您可能注意到，显示的结果并不是来自 shell 会话的直接剪切和粘贴。差异包括：

*   `import datetime`已从 doctest 中移出，并成为`models.py`文件中代码的一部分。严格来说，这并不是必需的—作为 doctest 的一部分，它可以正常工作，但如果导入在主代码中，则在 doctest 中不必这样做。由于`models.py`中的代码以后可能需要使用`datetime`函数，现在将导入放在主代码中可以减少以后主代码需要导入时的重复和混乱。
*   回溯的调用堆栈部分（即除第一行和最后一行之外的所有内容）被删除并替换为包含三个点的行。这也不是严格必要的，只是为了消除混乱并突出结果的重要部分。在决定测试成功或失败时，doctest 运行程序将忽略调用堆栈的内容（如果在预期输出中存在）。因此，您可以在测试中留下一个调用堆栈，如果它有一些解释性的值。然而，在大多数情况下，最好删除调用堆栈，因为它们会产生大量混乱，而不会提供太多有用的信息。

如果我们现在运行`manage.py test survey -v2`，输出的结尾将是：

```py
No fixtures found. 
test_basic_addition (survey.tests.SimpleTest) ... ok 
Doctest: survey.models.Survey ... ok 
Doctest: survey.tests.__test__.doctest ... ok 

---------------------------------------------------------------------- 
Ran 3 tests in 0.030s 

OK 
Destroying test database... 

```

我们仍然在`tests.py`中运行我们的示例测试，现在我们还可以看到我们的`survey.models.Survey`doctest 被列为正在运行并通过。

## 该测试有用吗？

但是等待；我们刚才添加的测试有用吗？它实际上在测试什么？除了验证基本 Django 函数是否如广告所示工作之外，实际上什么都没有。它测试是否可以创建已定义模型的实例，以及在模型定义中指定为必需的字段在关联的数据库表中实际上是必需的。这个测试似乎测试的是底层 Django 代码，而不是我们的应用程序。在我们的应用程序中，测试 Django 本身是不必要的：Django 有自己的测试套件，如果我们想测试它，我们可以运行它（尽管假设基本函数在任何 Django 发布版本中都能正常工作是非常安全的）。

可以说，该测试验证了已为模型中的每个字段指定了正确和预期的选项，因此它是对应用程序的测试，而不仅仅是对底层 Django 函数的测试。然而，通过检查（对任何有 Django 基本知识的人来说）可以明显看出的测试内容让我觉得有点过火。这不是一个测试，我通常会包括在我写的项目中。

这并不是说我不会在开发过程中在 pythonshell 中尝试这样的事情：我会，我会。但并非开发过程中在 shell 中进行的所有实验都需要成为应用程序中的永久测试。您希望在应用程序中包含的测试类型是那些执行应用程序特有行为的测试。因此，让我们开始开发一些调查应用程序代码，并在 pythonshell 中进行测试。当代码正常工作时，我们可以评估 shell 会话中哪些测试是有用的。

## 开发自定义测量保存方法

为了开始编写一些特定于应用程序的代码，考虑到对于调查模型，我们可能希望允许 Tyle T0.字段在 Outt1 之后，假设一个星期的默认值，如果在创建模型实例时没有指定 AUT2 T2。我们不能为此使用 Django 模型字段默认选项，因为我们要分配的值依赖于模型中的另一个字段。因此，我们通常会通过覆盖模型的 save 方法来实现这一点。实现这一点的第一次尝试可能是：

```py
import datetime
from django.db import models  

class Survey(models.Model): 
    title = models.CharField(max_length=60) 
    opens = models.DateField() 
    closes = models.DateField() 

    def save(self, **kwargs): 
        if not self.pk and not self.closes: 
            self.closes = self.opens + datetime.timedelta(7) 
        super(Survey, self).save(**kwargs) 
```

也就是说，如果调用了`save`并且模型实例还没有分配主键（因此这是第一次保存到数据库），并且还没有指定`closes`，那么我们在调用超类`save`方法之前为`closes`分配一个比`opens`晚一周的值。然后，我们可以通过在 Python shell 中进行实验来测试这是否正常工作：

```py
kmt@lbox:/dj_projects/marketr$ python manage.py shell 
Python 2.5.2 (r252:60911, Oct  5 2008, 19:24:49) 
[GCC 4.3.2] on linux2 
Type "help", "copyright", "credits" or "license" for more information. 
(InteractiveConsole) 
>>> from survey.models import Survey 
>>> import datetime 
>>> t = "New Year's Resolutions" 
>>> sd = datetime.date(2009, 12, 28) 
>>> s = Survey.objects.create(title=t, opens=sd) 
>>> s.closes 
datetime.date(2010, 1, 4) 
>>> 

```

这与我们之前的测试非常相似，只是我们选择了一个指定给`opens`的特定日期，而不是使用今天的日期，并且在创建`Survey`实例而没有指定`closes`的值之后，我们检查了分配给它的值。显示的值比`opens`晚一周，所以看起来不错。

请注意，选择一个`opens`日期，其中一周后的值将在下一个月和下一年是经过深思熟虑的。测试边界值始终是一个好主意，也是一个好习惯，即使我们正在编写的代码中没有任何东西能够正确回答边界情况。

接下来，我们可能需要确保，如果我们确实为`closes`指定了一个值，那么它将得到尊重，并且不会被一周后的默认日期覆盖：

```py
>>> s = Survey.objects.create(title=t, opens=sd, closes=sd)
>>> s.opens 
datetime.date(2009, 12, 28) 
>>> s.closes 
datetime.date(2009, 12, 28) 
>>> 

```

所有这些看起来都不错，`opens`和`closes`显示为具有相同的值，正如我们在`create`调用中指定的。我们还可以验证，如果我们在模型已经保存后将`closes`重置为`None`，然后再次尝试保存，我们将得到一个错误。在现有模型实例上将`closes`重置为`None`将是执行此操作的代码中的错误。因此，我们在这里测试的是，我们的`save`方法覆盖不会通过悄悄地将值重新分配给`closes`来隐藏错误。在我们的 shell 会话中，我们继续这样做，并看到：

```py
>>> s.closes = None 
>>> s.save() 
Traceback (most recent call last): 
 File "<console>", line 1, in <module> 
 File "/dj_projects/marketr/survey/models.py", line 12, in save 
 super(Survey, self).save(**kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 410, in save 
 self.save_base(force_insert=force_insert, force_update=force_update) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 474, in save_base 
 rows = manager.filter(pk=pk_val)._update(values) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 444, in _update 
 return query.execute_sql(None) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/subqueries.py", line 120, in execute_sql 
 cursor = super(UpdateQuery, self).execute_sql(result_type) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/query.py", line 2369, in execute_sql 
 cursor.execute(sql, params) 
 File "/usr/lib/python2.5/site-packages/django/db/backends/util.py", line 19, in execute 
 return self.cursor.execute(sql, params) 
 File "/usr/lib/python2.5/site-packages/django/db/backends/sqlite3/base.py", line 193, in execute 
 return Database.Cursor.execute(self, query, params) 
IntegrityError: survey_survey.closes may not be NULL 
>>> 

```

同样，这看起来很好，因为这是我们期望的结果。最后，由于我们已经在基本模型保存处理中插入了一些我们自己的代码，我们应该验证我们没有破坏其他预期故障情况下的任何内容，其中在`create`上没有指定`title`或`opens`字段。如果我们这样做，我们将看到没有指定`title`的情况正确工作（我们在数据库标题列中得到预期的`IntegrityError`，但是如果没有指定`opens`和`closes`，我们会得到一个意外错误：

```py
>>> s = Survey.objects.create(title=t) 
Traceback (most recent call last): 
 File "<console>", line 1, in <module> 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 126, in create 
 return self.get_query_set().create(**kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 315, in create 
 obj.save(force_insert=True) 
 File "/dj_projects/marketr/survey/models.py", line 11, in save 
 self.closes = self.opens + datetime.timedelta(7) 
TypeError: unsupported operand type(s) for +: 'NoneType' and 'datetime.timedelta' 
>>> 

```

在这里，我们交换了一条相当清晰的错误消息，该消息报告了一条更加模糊的消息，该消息抱怨不受支持的操作数类型不好，而未指定所需的值。问题是我们在尝试在`save`方法覆盖中使用`opens`之前没有检查它是否有值。为了得到这种情况下正确（更清晰）的错误，我们的`save`方法应该修改如下：

```py
    def save(self, **kwargs): 
        if not self.pk and self.opens and not self.closes: 
            self.closes = self.opens + datetime.timedelta(7) 
        super(Survey, self).save(**kwargs) 
```

也就是说，如果没有指定`opens`，我们不应该尝试设置`closes`。相反，在这种情况下，我们将`save`调用直接转发给超类，并让正常错误路径报告问题。然后，当我们尝试创建一个没有指定`opens`或`closes`值的`Survey`时，我们将看到：

```py
>>> s = Survey.objects.create(title=t) 
Traceback (most recent call last): 
 File "<console>", line 1, in <module> 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 126, in create 
 return self.get_query_set().create(**kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 315, in create 
 obj.save(force_insert=True) 
 File "/dj_projects/marketr/survey/models.py", line 12, in save 
 super(Survey, self).save(**kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 410, in save 
 self.save_base(force_insert=force_insert, force_update=force_update) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 495, in save_base 
 result = manager._insert(values, return_id=update_pk) 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 177, in _insert 
 return insert_query(self.model, values, **kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 1087, in insert_query 
 return query.execute_sql(return_id) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/subqueries.py", line 320, in execute_sql 
 cursor = super(InsertQuery, self).execute_sql(None) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/query.py", line 2369, in execute_sql 
 cursor.execute(sql, params) 
 File "/usr/lib/python2.5/site-packages/django/db/backends/util.py", line 19, in execute 
 return self.cursor.execute(sql, params) 
 File "/usr/lib/python2.5/site-packages/django/db/backends/sqlite3/base.py", line 193, in execute 
 return Database.Cursor.execute(self, query, params) 
IntegrityError: survey_survey.opens may not be NULL 
>>> 

```

这要好得多，因为报告的错误直接表明了问题所在。

## 决定测试什么

在这一点上，我们可以合理地确定我们的`save`覆盖正在按我们预期的方式工作。在我们为验证目的而在 pythonshell 中运行的所有测试中，哪些测试可以永久地包含在代码中？这个问题的答案涉及一个判断电话，理性的人可能会有不同的答案。就我个人而言，我倾向于包括：

*   涉及直接受代码影响的参数的所有测试
*   我在对代码进行初始测试时遇到的、在我编写的代码的原始版本中不起作用的任何测试

因此，我的`save`覆盖函数，包括带有注释的 doctest，可能看起来像这样：

```py
    def save(self, **kwargs): 
        """ 
        save override to allow for Survey instances to be created without explicitly specifying a closes date. If not specified, closes will be set to 7 days after opens. 
        >>> t = "New Year's Resolutions" 
        >>> sd = datetime.date(2009, 12, 28) 
        >>> s = Survey.objects.create(title=t, opens=sd) 
        >>> s.closes 
        datetime.date(2010, 1, 4) 

        If closes is specified, it will be honored and not auto-set. 

        >>> s = Survey.objects.create(title=t, opens=sd, closes=sd) 
        >>> s.closes 
        datetime.date(2009, 12, 28) 

        Any changes to closes after initial creation need to be explicit. Changing closes to None on an existing instance will not result in closes being reset to 7 days after opens. 

        >>> s.closes = None 
        >>> s.save() 
        Traceback (most recent call last): 
          ... 
        IntegrityError: survey_survey.closes may not be NULL 

        Making the mistake of specifying neither opens nor closes results in the expected IntegrityError for opens, not any exception in the code here. 

        >>> s = Survey.objects.create(title=t) 
        Traceback (most recent call last): 
          ... 
        IntegrityError: survey_survey.opens may not be NULL 
        """ 
        if not self.pk and self.opens and not self.closes: 
            self.closes = self.opens + datetime.timedelta(7) 
        super(Survey, self).save(**kwargs) 
```

## 到目前为止，博士的一些优点和缺点

即使有了我们所研究的这一示例方法的经验，我们也可以开始看到博士的一些优点和缺点。显然，为了永久性的测试目的，可以很容易地重用在 pythonshell 会话中完成的工作（可能已经作为编码的一部分完成的工作）。这使得更可能为代码编写测试，并且不需要调试测试本身。这是博士的两大优点。

第三，doctest 提供了代码预期行为的明确文档。散文描述可能是模糊的，而测试形式的代码示例不可能被误解。此外，由于测试是 docstring 的一部分，因此所有使用 docstring 自动生成帮助和文档的 Python 工具都可以访问这些测试。

在此处包含测试有助于完成此文档。例如，将`closes`重置为`None`后的行为是一种预期行为可能不明显的行为，同样有效的设计是，在这种情况下`closes`将重置为`save`期间一周后的日期。在编写文档时，这种细节很容易被忘记。因此，在 doctest 中详细说明预期的行为是有帮助的，因为它会自动记录下来。

然而，这个测试兼作文档功能也有一个缺点：您可能想要包含的一些测试可能并不适合作为文档，并且您可能会得到大量文档，用于编写相当简单的代码。考虑一下我们开发的 AutoT0.覆盖案例。它有四行代码和超过 30 行的 docstring。这个比率可能适用于一些具有许多参数的复杂函数，或者以不明显的方式交互的参数，但是对于这种简单的方法来说，文档的数量几乎是代码的十倍。

让我们考虑一下在 Type T0T 中的个别测试，重点是它们作为文档的有用性：

*   第一个测试显示创建带有`title`和`opens`但没有`closes`的`Survey`，并验证在创建后为`closes`分配了正确的值，这是`save`覆盖允许调用方执行的操作的一个示例。这是由添加的代码启用的特定调用模式，因此作为文档很有用，尽管它在很大程度上重复了散文描述。
*   第二个测试表明，如果指定，`closes`是值得遵守的，但作为文档并不特别有用。任何程序员都会期望，如果指定了`closes`，就应该尊重它。此行为可能适合测试，但无需记录。
*   第三个测试说明了在现有`Survey`实例上将`closes`重置为`None`后`save`的预期行为，出于上述原因，该测试可用作文档。
*   第四个也是最后一个测试说明，添加的代码不会导致在既没有指定`opens`也没有指定`closes`的错误情况下生成意外异常。这是另一个可以测试但不需要记录的例子，因为正确的行为是显而易见的。

将我们的文档字符串的一半归类为不适用于文档目的是不好的。当人们遇到明显的、多余的或无用的信息时，往往会停止阅读。通过将此类测试从 docstring 方法移动到我们的`tests.py`文件中，我们可以在不放弃 doctest 的一些优点的情况下解决这个问题。如果我们采用这种方法，我们可能会将`tests.py`中的`__test__`字典更改为如下所示：

```py
__test__ = {"survey_save": """ 

Tests for the Survey save override method. 

>>> import datetime 
>>> from survey.models import Survey 
>>> t = "New Year's Resolutions" 
>>> sd = datetime.date(2009, 12, 28) 

If closes is specified, it will be honored and not auto-set. 

>>> s = Survey.objects.create(title=t, opens=sd, closes=sd) 
>>> s.closes 
datetime.date(2009, 12, 28) 

Making the mistake of specifying neither opens nor closes results 
in the expected IntegrityError for opens, not any exception in the 
save override code itself. 

>>> s = Survey.objects.create(title=t) 
Traceback (most recent call last): 
  ... 
IntegrityError: survey_survey.opens may not be NULL 
"""} 
```

在这里，我们将测试的键从泛型`doctest`更改为`survey_save`，因此任何测试输出中报告的测试名称都将给出测试内容的提示。然后我们将“非文档化”测试（以及一些现在需要在两个位置上的变量设置代码）从`save`覆盖 docstring 移到这里的键值中，在顶部添加一条一般性注释，说明测试的目的。

对于`save`方法本身，文档字符串中剩下的是一些测试，它们确实具有文档价值：

```py
    def save(self, **kwargs): 
        """ 
        save override to allow for Survey instances to be created without explicitly specifying a closes date. If not specified, closes will be set to 7 days after opens. 
        >>> t = "New Year's Resolutions" 
        >>> sd = datetime.date(2009, 12, 28) 
        >>> s = Survey.objects.create(title=t, opens=sd) 
        >>> s.closes 
        datetime.date(2010, 1, 4) 

        Any changes to closes after initial creation need to be explicit. Changing closes to None on an existing instance will not result in closes being reset to 7 days after opens. 

        >>> s.closes = None 
        >>> s.save() 
        Traceback (most recent call last): 
          ... 
        IntegrityError: survey_survey.closes may not be NULL 

        """ 
        if not self.pk and self.opens and not self.closes: 
            self.closes = self.opens + datetime.timedelta(7) 
        super(Survey, self).save(**kwargs) 
```

对于函数来说，这无疑是一个更易于管理的 docstring，并且不再可能压倒在 pythonshell 中键入`help(Survey.save)`的人。

不过，这种方法也有其不利的一面。代码的测试不再集中在一个地方，因此很难知道或很容易确定代码测试的完整性。任何在`tests.py`中运行测试的人，如果不知道该方法的 docstring 中还有其他测试，可能会想知道为什么只测试了这两个边缘情况，为什么省略了对添加的基本函数的直接测试。

另外，在添加测试时，可能不清楚（特别是对于项目新手来说）新测试应该放在哪里。因此，即使一个项目从 docstring 测试中的“有助于良好文档的测试”和`tests.py`文件中的“必要但不是良好文档的测试”这两个清晰的分离开始，随着时间的推移，这种区别也很容易变得模糊。

因此，测试的选择和放置需要权衡。并非每个项目都有一个“正确”的答案。不过，采用一致的方法是最好的。在选择该方法时，每个项目团队应考虑以下问题的答案：

*   **What is the expected audience for auto-generated docstring-based documentation?**

    如果存在（或正在编写）预期将成为代码“使用者”的主要来源的其他文档，那么拥有不能很好地服务于文档功能的 doctest 可能不是问题。

*   **How many people will likely be working on the code?**

    如果这是一个相对较小且恒定的数字，那么让每个人都记住在两个地方进行的测试可能不是什么大问题。对于一个更大的项目，或者如果开发人员流动率很高，那么对开发人员进行这种拆分的教育可能会成为一个更大的问题，并且可能更难维护一致的代码。

# 额外的医生测试警告

医生还有一些我们还没有注意到的缺点。如果我们想确保我们的 doctest 能够在各种各样的环境中正常工作，并且随着围绕我们的代码的变化，其中一些正是我们需要注意的事情。还有一些更严重的问题，至少在受影响的测试中，通过切换到单元测试而不是 doctest 最容易解决。在本节中，我们将列出许多需要注意的额外 doctest 问题，并给出如何避免或克服这些问题的指导。

## 提防环境依赖

doctest 很容易无意中依赖于代码的实现细节，而不是实际正在测试的代码。我们在`save`覆盖测试中已经有了一些，尽管我们还没有被它绊倒。我们所拥有的依赖实际上是环境依赖数据库依赖的一种非常特殊的形式。由于数据库依赖性本身是一个相当大的问题，因此将在下一节中详细讨论。然而，我们将首先介绍一些我们可能容易遇到的其他次要环境依赖性，并了解如何避免在测试中包含它们。

一种极其常见的环境依赖形式潜入了博士测试，它依赖于物体的印刷表示。例如，a`__unicode__`方法是首先在模型类中实现的常用方法。在早期的`Survey`模型讨论中省略了它，因为当时没有必要，但实际上我们可能在`save`覆盖之前就已经实现了`__unicode__`。在`Survey`的`__unicode__`方法中，第一次通过可能看起来像这样：

```py
    def __unicode__(self): 
        return u'%s (Opens %s, closes %s)' % (self.title, self.opens, self.closes) 
```

在这里，我们已经决定，`Survey`实例的打印表示形式将包括标题值，后跟一个括号注释，说明此调查的开始和结束时间。根据该方法定义，当创建过程中未指定`closes`的正确设置时，我们用于测试其正确设置的 shell 会话可能如下所示：

```py
>>> from survey.models import Survey 
>>> import datetime 
>>> sd = datetime.date(2009, 12, 28) 
>>> t = "New Year's Resolutions" 
>>> s = Survey.objects.create(title=t, opens=sd) 
>>> s 
<Survey: New Year's Resolutions (Opens 2009-12-28, closes 2010-01-04)> 
>>> 

```

也就是说，我们可能只是显示所创建实例的打印表示，而不是专门检查分配给`closes`的值，因为它包括`closes`值。在 shell 会话中进行实验时，很自然地会以这种方式执行检查，而不是直接询问有问题的属性。首先，它比较短（`s`比`s.closes`更容易输入）。此外，它通常会显示比我们要测试的特定部件更多的信息，这在我们进行实验时非常有用。

但是，如果我们直接从 shell 会话剪切并粘贴到我们的`save`覆盖 doctest 中，我们将使该 doctest 依赖于`__unicode__`的实现细节。我们可能随后决定，我们不想将所有这些信息都包含在`Survey`的可打印表示中，甚至只是认为如果“Opens”中的“o”不大写会更好。因此，我们对`__unicode__`方法实现做了一个小改动，突然一个不相关方法的 doctest 开始失败：

```py
====================================================================== 
FAIL: Doctest: survey.models.Survey.save 
---------------------------------------------------------------------- 
Traceback (most recent call last): 
 File "/usr/lib/python2.5/site-packages/django/test/_doctest.py", line 2189, in runTest 
 raise self.failureException(self.format_failure(new.getvalue())) 
AssertionError: Failed doctest test for survey.models.Survey.save 
 File "/dj_projects/marketr/survey/models.py", line 9, in save 

---------------------------------------------------------------------- 
File "/dj_projects/marketr/survey/models.py", line 32, in survey.models.Survey.save 
Failed example: 
 s 
Expected: 
 <Survey: New Year's Resolutions (Opens 2009-12-28, closes 2010-01-04)> 
Got: 
 <Survey: New Year's Resolutions (opens 2009-12-28, closes 2010-01-04)> 

---------------------------------------------------------------------- 
Ran 3 tests in 0.076s 

FAILED (failures=1) 
Destroying test database... 

```

因此，在从 shell 会话创建 DOCTREST 时，仔细考虑会话是否依赖于特定代码之外的任何代码的实现细节，如果是这样，则进行调整以消除依赖性。在这种情况下，使用`s.closes`测试分配给`closes`的值消除了对`Survey`模型`__unicode__`方法实现方式的依赖。

在博士测试中可能会出现许多其他环境依赖的情况，包括：

*   任何依赖于文件路径打印表示的测试都可能与以下事实相冲突：在基于 Unix 的操作系统上，路径组件由正斜杠分隔，而 Windows 使用反斜杠。如果需要包含依赖文件路径值的 doctest，则可能需要使用实用程序函数跨不同操作系统规范化文件路径表示。
*   任何依赖于以特定顺序打印字典键的测试都可能与以下事实相冲突：对于不同的操作系统或 Python 实现，该顺序可能不同。因此，为了使这种测试在不同平台上具有健壮性，可能需要专门询问字典键值，而不是简单地打印整个字典内容，或者使用一个实用函数，将一致的顺序应用于打印表示的键。

对于这些经常出现在博士论文中的环境依赖问题，Django 并没有什么特别的地方。然而，Django 应用程序中特别可能出现一种环境依赖：数据库依赖。下面讨论这个问题。

## 小心数据库依赖性

Django**对象关系管理器**（**ORM**）在保护应用程序代码不受底层数据库差异影响方面遇到了相当大的麻烦。但是，Django 不可能在所有情况下使所有受支持的不同数据库看起来完全相同。因此，可以在应用程序级别观察特定于数据库的差异。这些差异可能很容易进入 doctest，使测试依赖于特定的数据库后端才能通过。

这种依赖性已经出现在本章前面开发的`save`覆盖测试中。因为 SQLite 是最容易使用的数据库（因为它不需要安装或配置），所以到目前为止，示例代码和测试是使用`settings.py`中的`DATABASE_ENGINE = 'sqlite3'`设置开发的。如果我们转而使用 MySQL（`DATABASE_ENGINE = 'mysql'`作为数据库，并尝试运行`survey`应用程序测试，我们将看到失败。有两个失败，但我们首先只关注测试输出中的最后一个：

```py
====================================================================== 
FAIL: Doctest: survey.tests.__test__.survey_save 
---------------------------------------------------------------------- 
Traceback (most recent call last): 
 File "/usr/lib/python2.5/site-packages/django/test/_doctest.py", line 2189, in runTest 
 raise self.failureException(self.format_failure(new.getvalue())) 
AssertionError: Failed doctest test for survey.tests.__test__.survey_save 
 File "/dj_projects/marketr/survey/tests.py", line unknown line number, in survey_save 

---------------------------------------------------------------------- 
File "/dj_projects/marketr/survey/tests.py", line ?, in survey.tests.__test__.survey_save 
Failed example: 
 s = Survey.objects.create(title=t) 
Expected: 
 Traceback (most recent call last): 
 ... 
 IntegrityError: survey_survey.opens may not be NULL 
Got: 
 Traceback (most recent call last): 
 File "/usr/lib/python2.5/site-packages/django/test/_doctest.py", line 1274, in __run 
 compileflags, 1) in test.globs 
 File "<doctest survey.tests.__test__.survey_save[6]>", line 1, in <module> 
 s = Survey.objects.create(title=t) 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 126, in create 
 return self.get_query_set().create(**kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 315, in create 
 obj.save(force_insert=True) 
 File "/dj_projects/marketr/survey/models.py", line 34, in save 
 super(Survey, self).save(**kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 410, in save 
 self.save_base(force_insert=force_insert, force_update=force_update) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 495, in save_base 
 result = manager._insert(values, return_id=update_pk) 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 177, in _insert 
 return insert_query(self.model, values, **kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 1087, in insert_query 
 return query.execute_sql(return_id) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/subqueries.py", line 320, in execute_sql 
 cursor = super(InsertQuery, self).execute_sql(None) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/query.py", line 2369, in execute_sql 
 cursor.execute(sql, params) 
 File "/usr/lib/python2.5/site-packages/django/db/backends/mysql/base.py", line 89, in execute 
 raise Database.IntegrityError(tuple(e)) 
 IntegrityError: (1048, "Column 'opens' cannot be null") 

---------------------------------------------------------------------- 
Ran 3 tests in 0.434s 

FAILED (failures=2) 
Destroying test database... 

```

这里有什么问题？对于`tests.py`中 doctest 中的`save`调用，如果没有指定`opens`的值，则应为`IntegrityError`，并生成`IntegrityError`，但`IntegrityError`消息的细节不同。SQLite 数据库返回：

```py
 IntegrityError: survey_survey.opens may not be NULL 

```

MySQL 的说法有些不同：

```py
 IntegrityError: (1048, "Column 'opens' cannot be null") 

```

有两种简单的方法可以解决这个问题。一种是对失败的测试使用 doctest 指令`IGNORE_EXCEPTION_DETAIL`。有了这个选项，当确定预期结果是否与实际结果相匹配时，DoTestStand 将只考虑异常类型（在这种情况下，ORT T1）。因此，不同数据库产生的异常消息的差异不会导致测试失败。

通过将 Doctest 指令作为注释放置在包含测试的行上，为单个测试指定了 Doctest 指令。注释以`doctest:`开头，后面是一个或多个指令名，前面是`+`打开选项或`–`关闭选项。因此，在本例中，我们将`tests.py`中的失败测试行更改为（注意，虽然这一行在本页上换行到第二行，但在测试中需要保留在一行）：

```py
>>> s = Survey.objects.create(title=t) # doctest: +IGNORE_EXCEPTION_DETAIL 
```

解决此问题的另一种方法是将测试中预期输出的详细消息部分替换为三个点，这是一个省略号标记。即，将测试更改为：

```py
>>> s = Survey.objects.create(title=t) 
Traceback (most recent call last): 
  ... 
IntegrityError: ... 
```

这是告诉 doctest 运行程序忽略异常消息细节的另一种方法。它依赖于为 doctest 运行启用 doctest 选项`ELLIPSIS`。虽然 Python 默认情况下未启用此选项，但 Django 使用的 doctest 运行程序启用了此选项，因此您无需在测试代码中执行任何操作即可在预期输出中启用省略号标记。还要注意的是，`ELLIPSIS`并不是特定于异常消息的详细信息；这是一种更通用的方法，可以让您指示 doctest 输出的各个部分，这些部分在不同的运行中可能会有所不同，而不会导致测试失败。

### 注

如果您阅读了`ELLIPSIS`的 Python 文档，您可能会注意到它是在 Python2.4 中引入的。因此，如果您运行的是 Python2.3（Django 1.1 仍然支持该版本），您可能会认为您将无法在 Django 应用程序的 doctest 中使用省略号标记技术。但是，Django 1.0 和 1.1 附带了一个定制的 doctest 运行程序，在运行应用程序的 doctest 时使用该运行程序。这个定制的运行程序基于 Python 2.4 附带的 doctest 模块。因此，即使您运行的是较早的 Python 版本，也可以使用 Python 2.4 中的 doctest 选项，例如`ELLIPSIS`。

不过，请注意，Django 使用其自己定制的 doctest 运行程序的另一面：如果您运行的是比 2.4 更新的 Python 版本，则不能在应用程序的 doctest 中使用 2.4 之后添加的 doctest 选项。例如，Python 在 Python2.5 中添加了`SKIP`选项。在 Django 更新其自定义 doctest 模块的版本之前，您将无法在 Django 应用程序 doctest 中使用此新选项。

回想一下，有两次测试失败，我们只查看了其中一次的输出（另一次很可能是滚动屏幕太快而无法读取）。但是，考虑到我们检查的一个失败，我们可能会认为另一个失败是相同的，因为我们在`models.py`的博士测试中有一个非常相似的`IntegrityError`测试：

```py
        >>> s.closes = None 
        >>> s.save() 
        Traceback (most recent call last): 
          ... 
        IntegrityError: survey_survey.closes may not be NULL 
```

这当然也需要修正，以忽略异常细节，因此我们不妨同时做这两件事，或许可以纠正两个测试失败。事实上，当我们在更改两个预期的`IntegrityErrors`以包含省略号标记而不是特定的错误消息后再次运行测试时，测试都通过了。

### 注

请注意，对于 MySQL 的某些配置，忽略异常详细信息不会纠正第二次测试失败。具体来说，如果 MySQL 服务器配置为在“非严格”模式下运行，则尝试更新一行以在声明为`NOT NULL`的列中包含`NULL`值不会引发错误。而是将该值设置为列类型的隐式默认值，并发出警告。

如果您使用的是 MySQL，您很可能希望将其配置为在“严格模式”下运行。但是，如果由于某种原因您不能，并且您需要在应用程序中进行类似的测试，并且您需要通过多个数据库的测试，那么您必须在测试中考虑数据库行为的差异。这是可以做到的，但在单元测试中要比在 doctest 中容易得多，因此我们将不讨论如何修复这种情况下的 doctest。

现在，我们已经在两个不同的数据库后端上通过了测试，我们可能认为我们已经设置好了，并且可能会在 Django 支持的所有数据库上得到一个干净的测试运行。当我们尝试使用 PostgreSQL 作为数据库运行这些相同的测试时，我们会发现我们错了。我们在 PostgreSQL 中遇到的数据库差异突出了编写 doctest 时要注意的下一项，下一节将介绍这一点。

## 小心测试的相互依赖性

如果我们现在尝试使用 PostgreSQL 作为数据库运行测试，我们会得到一个非常奇怪的结果（请在`settings.py`中指定`DATABASE_ENGINE = 'postgresql_psycopg2'`。从`manage.py test survey -v2`输出的尾端可以看到：

```py
No fixtures found. 
test_basic_addition (survey.tests.SimpleTest) ... ok 
Doctest: survey.models.Survey.save ... ok 
Doctest: survey.tests.__test__.survey_save ... FAIL 

```

我们在`tests.py`中的样本单元测试仍然运行并通过，然后`models.py`中的 doctest 也通过了，但是我们添加到`tests.py`中的 doctest 失败了。故障详情如下：

```py
====================================================================== 
FAIL: Doctest: survey.tests.__test__.survey_save 
---------------------------------------------------------------------- 
Traceback (most recent call last): 
 File "/usr/lib/python2.5/site-packages/django/test/_doctest.py", line 2189, in runTest 
 raise self.failureException(self.format_failure(new.getvalue())) 
AssertionError: Failed doctest test for survey.tests.__test__.survey_save 
 File "/dj_projects/marketr/survey/tests.py", line unknown line number, in survey_save 

---------------------------------------------------------------------- 
File "/dj_projects/marketr/survey/tests.py", line ?, in survey.tests.__test__.survey_save 
Failed example: 
 s = Survey.objects.create(title=t, opens=sd, closes=sd) 
Exception raised: 
 Traceback (most recent call last): 
 File "/usr/lib/python2.5/site-packages/django/test/_doctest.py", line 1274, in __run 
 compileflags, 1) in test.globs 
 File "<doctest survey.tests.__test__.survey_save[4]>", line 1, in <module> 
 s = Survey.objects.create(title=t, opens=sd, closes=sd) 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 126, in create 
 return self.get_query_set().create(**kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 315, in create 
 obj.save(force_insert=True) 
 File "/dj_projects/marketr/survey/models.py", line 34, in save 
 super(Survey, self).save(**kwargs)
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 410, in save 
 self.save_base(force_insert=force_insert, force_update=force_update) 
 File "/usr/lib/python2.5/site-packages/django/db/models/base.py", line 495, in save_base 
 result = manager._insert(values, return_id=update_pk) 
 File "/usr/lib/python2.5/site-packages/django/db/models/manager.py", line 177, in _insert 
 return insert_query(self.model, values, **kwargs) 
 File "/usr/lib/python2.5/site-packages/django/db/models/query.py", line 1087, in insert_query 
 return query.execute_sql(return_id) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/subqueries.py", line 320, in execute_sql 
 cursor = super(InsertQuery, self).execute_sql(None) 
 File "/usr/lib/python2.5/site-packages/django/db/models/sql/query.py", line 2369, in execute_sql 
 cursor.execute(sql, params) 
 InternalError: current transaction is aborted, commands ignored until end of transaction block 

---------------------------------------------------------------------- 
File "/dj_projects/marketr/survey/tests.py", line ?, in survey.tests.__test__.survey_save 
Failed example: 
 s.closes 
Exception raised: 
 Traceback (most recent call last): 
 File "/usr/lib/python2.5/site-packages/django/test/_doctest.py", line 1274, in __run 
 compileflags, 1) in test.globs 
 File "<doctest survey.tests.__test__.survey_save[5]>", line 1, in <module> 
 s.closes 
 NameError: name 's' is not defined 
 ****----------------------------------------------------------------------** 
**Ran 3 tests in 0.807s** 
 ****FAILED (failures=1)** 
**Destroying test database...****** 
```

 ****这一次，我们需要按顺序检查报告的错误，因为第二个错误是由第一个错误引起的。这种错误链接是常见的，因此最好记住，虽然从最后一次失败开始可能很诱人，因为这是在测试运行结束时最容易看到的失败，但这可能不是最有效的方法。如果不能立即确定上次故障的原因，通常最好从一开始就着手，找出第一次故障的原因。随后出现故障的原因可能变得显而易见。作为参考，失败测试的开始是：

```py
>>> import datetime 
>>> from survey.models import Survey 
>>> t = "New Year's Resolutions" 
>>> sd = datetime.date(2009, 12, 28) 

If closes is specified, it will be honored and not auto-set. 

>>> s = Survey.objects.create(title=t, opens=sd, closes=sd) 
>>> s.closes 
datetime.date(2009, 12, 28) 
```

因此，根据测试输出，第一次尝试访问数据库（即尝试在此测试中创建`Survey`实例）会导致错误：

```py
InternalError: current transaction is aborted, commands ignored until end of transaction block
```

然后，测试的下一行也会导致错误，因为它使用了前一行中应该分配的变量`s`。但是，该行没有完成执行，因此当测试尝试使用变量`s`时，没有定义该变量。所以第二个错误对于第一个错误来说是有意义的，但是为什么在这个测试中第一次访问数据库会导致错误呢？

为了理解这一点的解释，我们必须回顾一下在这之前运行的测试。我们可以从测试输出中看到，紧接着这个测试之前的测试是`models.py`中的 doctest。该测试的结束时间为：

```py
        >>> s.closes = None 
        >>> s.save() 
        Traceback (most recent call last): 
          ... 
        IntegrityError: ... 
        """ 
```

测试所做的最后一件事是预期会引发数据库错误的事情。这对 PostgreSQL 的一个副作用是，数据库连接进入一种状态，在这种状态下，它只允许结束事务块的命令。因此，此测试结束时，数据库连接处于断开状态，并且在下一个 doctest 开始运行时它仍然断开，导致下一个 doctest 在尝试任何数据库访问时立即失败。

这个问题说明 doctest 之间没有数据库隔离。一个 doctest 对数据库所做的操作可以被后续运行的 doctest 观察到。除了创建、更新或删除数据库表中的行之外，这还包括诸如此处所示的问题。此特定问题可以通过添加一个调用来解决，该调用按照故意导致数据库错误的代码回滚当前事务：

```py
        >>> s.closes = None 
        >>> s.save() 
        Traceback (most recent call last): 
          ... 
        IntegrityError: ... 
        >>> from django.db import transaction 
        >>> transaction.rollback() 
        """ 
```

这将允许测试通过 PostgreSQL，并且对其他数据库后端无害。因此，处理 doctest 中没有数据库隔离的一种方法是对它们进行编码，以便它们自己清理。对于像这样的问题，这可能是一种可接受的方法，但是如果测试在数据库中添加、修改或删除了对象，那么可能很难将所有内容恢复到最初的状态。

第二种方法是在进入每个 doctest 时将数据库重置为已知状态。Django 不会为您执行此操作，但您可以通过调用管理命令来手动执行此操作，以同步数据库。我一般不推荐这种方法，因为随着应用程序的增长，它会变得非常耗时。

第三种方法是使 doctest 对数据库状态具有合理的容忍度，以便它们能够正常运行，而不管之前是否运行过其他测试。此处使用的技术包括：

*   在测试本身中创建测试所需的所有对象。也就是说，不要依赖于任何以前运行的测试创建的对象的存在，因为该测试可能会更改或删除，或者测试运行的顺序可能会在某个时间更改。
*   创建对象时，应防止与其他测试可能创建的类似对象发生碰撞。例如，如果一个测试需要创建一个`User`实例，并将`is_superuser`字段设置为`True`，以便测试具有该属性的用户的某些行为，那么给`User`实例一个`username`的“超级用户”似乎很自然。但是，如果有两个 doctest 这样做，那么任何一个不幸运地运行第二个 doctest 都会遇到错误，因为`User`模型的`username`字段被声明为唯一的，因此第二次尝试使用该`username`创建`User`将失败。因此，最好使用共享模型中不太可能被其他测试使用的唯一字段的值。

所有这些方法和技术都有其缺点。对于这个特定的问题，单元测试是一个更好的解决方案，因为它们自动提供数据库隔离，而不会导致重置数据库的性能成本（只要您在支持事务的数据库上运行它们）。因此，如果您开始在 doctest 中遇到许多测试相互依赖性问题，我强烈建议您考虑将单元测试作为一种解决方案，而不是依赖此处列出的任何方法。

## 提防 Unicode

我们将在 doctest 警告中介绍的最后一个问题是 Unicode。如果您在 Django（甚至只是 Python）上做了大量工作，使用的是字符集比英语更宽的语言中的数据，那么您可能会遇到`UnicodeDecodeError`或`UnicodeEncodeError`一两次。因此，您可能已经养成了在测试中定期包含一些非 ASCII 字符的习惯，以确保所有语言都能正常工作，而不仅仅是英语。这是一个好习惯，但不幸的是，在 doctests 中使用 Unicode 值进行测试存在一些需要克服的意外故障。

前面提到的`Survey`的`__unicode__`方法可能是我们想要测试非 ASCII 字符的正确行为的地方。此测试的第一次通过可能是：

```py
    def __unicode__(self): 
        """ 
        >>> t = u'¿Como está usted?' 
        >>> sd = datetime.date(2009, 12, 28) 
        >>> s = Survey.objects.create(title=t, opens=sd) 
        >>> print s 
        ¿Como está usted? (opens 2009-12-28, closes 2010-01-04) 
        """ 
        return u'%s (opens %s, closes %s)' % (self.title, self.opens, self.closes) 
```

此测试类似于许多 save override 测试，因为它首先创建一个`Survey`实例。本例中的重要参数是标题，它被指定为 Unicode 文本字符串，并包含非 ASCII 字符。创建`Survey`实例后，会调用打印该实例，以验证该实例的打印表示中是否正确显示了非 ASCII 字符，并且没有引发 Unicode 异常。

这个测试的效果如何？不太好。添加该代码后尝试运行调查测试将导致错误：

```py
kmt@lbox:/dj_projects/marketr$ python manage.py test survey 
Traceback (most recent call last): 
 File "manage.py", line 11, in <module> 
 execute_manager(settings) 
 File "/usr/lib/python2.5/site-packages/django/core/management/__init__.py", line 362, in execute_manager 
 utility.execute() 
 File "/usr/lib/python2.5/site-packages/django/core/management/__init__.py", line 303, in execute 
 self.fetch_command(subcommand).run_from_argv(self.argv) 
 File "/usr/lib/python2.5/site-packages/django/core/management/base.py", line 195, in run_from_argv 
 self.execute(*args, **options.__dict__) 
 File "/usr/lib/python2.5/site-packages/django/core/management/base.py", line 222, in execute 
 output = self.handle(*args, **options) 
 File "/usr/lib/python2.5/site-packages/django/core/management/commands/test.py", line 23, in handle 
 failures = test_runner(test_labels, verbosity=verbosity, interactive=interactive) 
 File "/usr/lib/python2.5/site-packages/django/test/simple.py", line 178, in run_tests 
 app = get_app(label) 
 File "/usr/lib/python2.5/site-packages/django/db/models/loading.py", line 114, in get_app 
 self._populate() 
 File "/usr/lib/python2.5/site-packages/django/db/models/loading.py", line 58, in _populate 
 self.load_app(app_name, True) 
 File "/usr/lib/python2.5/site-packages/django/db/models/loading.py", line 74, in load_app 
 models = import_module('.models', app_name) 
 File "/usr/lib/python2.5/site-packages/django/utils/importlib.py", line 35, in import_module 
 __import__(name) 
 File "/dj_projects/marketr/survey/models.py", line 40 
SyntaxError: Non-ASCII character '\xc2' in file /dj_projects/marketr/survey/models.py on line 41, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 

```

这个容易修理；我们只是忘记了声明 Python 源文件的编码。为此，我们需要在文件顶部添加注释行，指定文件使用的编码。假设我们使用 UTF-8 编码，那么我们应该在`models.py`文件的第一行添加以下内容：

```py
# -*- encoding: utf-8 -*- 
```

现在，新的测试会起作用吗？还没有，我们还是失败了：

```py
====================================================================== 
FAIL: Doctest: survey.models.Survey.__unicode__ 
---------------------------------------------------------------------- 
Traceback (most recent call last): 
 File "/usr/lib/python2.5/site-packages/django/test/_doctest.py", line 2180, in runTest 
 raise self.failureException(self.format_failure(new.getvalue())) 
AssertionError: Failed doctest test for survey.models.Survey.__unicode__ 
 File "/dj_projects/marketr/survey/models.py", line 39, in __unicode__ 

---------------------------------------------------------------------- 
File "/dj_projects/marketr/survey/models.py", line 44, in survey.models.Survey.__unicode__ 
Failed example: 
 print s 
Expected: 
 ¿Como está usted? (opens 2009-12-28, closes 2010-01-04) 
Got: 
 Â¿Como estÃ¡ usted? (opens 2009-12-28, closes 2010-01-04) 

---------------------------------------------------------------------- 
Ran 4 tests in 0.084s 

FAILED (failures=1) 
Destroying test database... 

```

这个有点令人费解。虽然我们在测试中将标题指定为 Unicode 文本字符串`u'¿Como está usted?'`，但它显然返回为**Como estÃusted？**打印时。像这样的数据损坏是一个信号，表明在将 bytestring 转换为 Unicode 字符串时使用了错误的编码。事实上，此处损坏的具体性质是，原始字符串中的每个非 ASCII 字符已被损坏版本中的两个（或更多）字符替换，这是实际以 UTF-8 编码的字符串的特征，被解释为好像它是以 ISO-8859-1（也称为拉丁语-1）编码的。但是，当我们将 UTF-8 指定为 Python 文件编码声明时，这怎么可能发生呢？为什么要使用任何其他编码来解释此字符串？

此时，我们可能会仔细阅读第一条错误消息中引用的网页，并了解到我们添加的编码声明仅对 Python 解释器从源文件构造 Unicode 文本字符串的方式有影响。然后我们可能会注意到，尽管标题是 Unicode 文本字符串，但其中包含的 doctest 不是。所以这个奇怪的结果可能是因为我们忽略了将包含 doctest 的 docstring 设置为 Unicode 文本。那么，我们的下一个测试版本可能是将整个 docstring 指定为 Unicode 文本。

不幸的是，由于 Unicode 文本 docstring 的问题，这也将不成功。首先，doctest 运行程序无法将预期输出（现在是 Unicode，因为 docstring 本身是 Unicode 文本）与实际输出（包含非 ASCII 字符的 bytestring）进行正确比较。这样的 bytestring 必须转换为 Unicode 才能执行比较。Python 将在必要时自动执行此转换，但问题是它不知道正在转换的 ByTestString 的实际编码。因此，它采用 ASCII，如果 bytestring 包含任何非 ASCII 字符，则无法执行转换。

转换失败将导致涉及 bytestring 的比较假设失败，这反过来将导致测试报告为失败。即使预期输出和接收到的输出是相同的，如果 bytestring 只采用了正确的编码，也无法获得要使用的正确编码，因此测试将失败。对于`Survey`模型`__unicode__`doctest，当尝试将`print s`（将是由 TestRing 编码的 UTF-8）的实际输出与预期输出进行比较时，此问题将导致测试失败。

Unicode 文本 Docstring 的第二个问题涉及到包含非 ASCII 字符的输出报告，例如`Survey`模型`__unicode__`doctest 会出现这种故障。doctest 运行程序将尝试显示一条消息，显示预期和接收的输出。但是，当它试图将预期输出和接收到的输出合并到一条消息中显示时，它将遇到与比较过程中遇到的问题相同的问题。因此，doctest 运行程序本身不会生成一条消息，该消息至少会显示测试在何处遇到问题，而是生成一个`UnicodeDecodeError`。

Python 的 bug 跟踪器中有一个公开的 Python 问题报告了这些问题：[http://bugs.python.org/issue1293741](http://bugs.python.org/issue1293741) 。在修复之前，最好避免在 doctest 中使用 Unicode 文本 docstring。

那么，有没有办法在 doctest 中包含一些非 ASCII 数据的测试？是的，这是可能的。使此类测试正常工作的关键是避免在 docstring 中使用 Unicode 文本。相反，将字符串显式解码为 Unicode 对象。例如：

```py
    def __unicode__(self): 
        """ 
        >>> t = '¿Como está usted?'.decode('utf-8') 
        >>> sd = datetime.date(2009, 12, 28) 
        >>> s = Survey.objects.create(title=t, opens=sd) 
        >>> print s 
        ¿Como está usted? (opens 2009-12-28, closes 2010-01-04) 
        """ 
        return u'%s (opens %s, closes %s)' % (self.title, self.opens, self.closes) 
```

也就是说，将 Unicode 文本标题字符串替换为使用 UTF-8 显式解码以创建 Unicode 字符串的 bytestring。

这样行吗？现在运行`manage.py test survey -v2`时，我们可以在输出的末尾看到以下内容：

```py
No fixtures found. 
test_basic_addition (survey.tests.SimpleTest) ... ok 
Doctest: survey.models.Survey.__unicode__ ... ok 
Doctest: survey.models.Survey.save ... ok 
Doctest: survey.tests.__test__.survey_save ... ok 

---------------------------------------------------------------------- 
Ran 4 tests in 0.046s 

OK 
Destroying test database... 

```

成功因此，可以在 doctests 中使用非 ASCII 数据进行正确测试。必须注意避免遇到与使用 Unicode 文本 DocString 或在 doctest 中嵌入 Unicode 文本字符串相关的现有问题。

# 总结

我们对 Django 应用程序的 doctest 的探索现在已经完成。在本章中，我们：

*   开始为我们的 Django`survey`应用程序开发一些模型
*   尝试将 doctest 添加到其中一个模型`Survey`模型中
*   了解了哪些 doctest 是有用的，哪些 doctest 只会给代码增加混乱
*   体验了 doctest 的一些优点，即易于重用 pythonshell 会话工作和方便地将 doctest 用作文档
*   与博士的许多缺点发生冲突，并学会了如何避免或克服这些缺点

在下一章中，我们将开始探索单元测试。虽然单元测试可能无法提供 doctest 的一些易于重用的特性，但它们也没有 doctest 的许多缺点。此外，整体单元测试框架允许 Django 提供对 web 应用程序特别有用的方便支持，这将在[第 4 章](04.html "Chapter 4. Getting Fancier: Django Unit Test Extensions")中详细介绍。****