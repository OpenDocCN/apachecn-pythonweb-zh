# 附录

## 关于

本节旨在帮助学生完成书中的活动。它包括学生为实现活动目标而执行的详细步骤。

## 1：你的第一步

### 活动 1：使用邮递员向我们的 API 发送请求

**溶液**

1.  首先，我们将得到所有的食谱。在下拉列表中选择**获取**作为我们的**HTTP**方法。
2.  输入请求 URL**http://localhost:5000/recipes** 。
3.  Click the **Send** button. The result can be seen in the following screenshot:

    ![Figure 1.14: Getting all the recipes ](../images/00141.jpeg)

    ###### 图 1.14：获取所有配方

    在 HTTP 响应中，您将在响应面板的右上角看到 HTTP 状态**200 OK**。这意味着请求已成功。它旁边的时间显示为**7ms**，这是在请求上花费的时间。响应的大小，包括头部和主体，为**322**字节。食谱的详细信息（JSON 格式）显示在正文面板中。

4.  接下来，我们将使用 POST 方法创建一个菜谱。我们将向**发送 HTTP**POST**请求 http://localhost:5000/recipes** 。
5.  单击**+**按钮，在“获取请求”选项卡旁边创建一个新选项卡。选择**POST**作为 HTTP 方式。输入**http://localhost:5000/recipes** 作为请求 URL。
6.  选择 Body 选项卡。另外，选择**原始**单选按钮。
7.  Choose **JSON (application/json)** in the right drop-down menu. Type the following data in JSON format in the **Body** content area. Click the **Send** button:

    {

    “名称”：“奶酪比萨饼”，

    “描述”：“这是一个可爱的奶酪比萨饼”

    }

    结果可以在以下屏幕截图中看到：

    ![Figure 1.15: Creating a recipe ](../images/00142.jpeg)

    ###### 图 1.15：创建配方

    您应该在 Postman 界面的 HTTP 响应中看到以下信息，状态为**201**OK，这意味着创建已经成功，我们可以看到 JSON 格式的新配方。您还将注意到分配给配方的 ID 是**3**。

8.  Now, get all the recipes from the server application again. We want to see if we have three recipes there now. In the history panel, select our previous request that gets all recipes, clicks on it, and resends.

    作为回应，我们可以看到有三种食谱。它们显示在以下屏幕截图中：

    ![Figure 1.16: Getting all the recipes from the server application ](../images/00143.jpeg)

    ###### 图 1.16：从服务器应用程序获取所有配方

9.  然后，修改我们刚刚创建的配方。为此，单击**+**按钮，在**获取**请求选项卡旁边创建一个新选项卡。选择**PUT**作为 HTTP 方式。
10.  输入**http://localhost:5000/recipes/3** 作为请求 URL。
11.  选择**主体**选项卡，然后选择**原始**单选按钮。
12.  Choose **JSON (application/json)** in the right drop-down menu. Type the following data in JSON format in the **Body** content area. Click **Send**:

    {

    “名字”：“可爱的奶酪比萨饼”，

    “描述”：“这是一个可爱的奶酪比萨食谱。”

    }

    结果显示在以下屏幕截图中：

    ![Figure 1.17: Modifying the recipe ](../images/00144.jpeg)

    ###### 图 1.17：修改配方

    在 HTTP 响应中，您将看到**200 OK**HTTP 状态，表示更新已成功。您还可以看到在请求上花费的时间（以毫秒为单位）。您还应该看到响应的大小（标题和正文）。响应的内容是 JSON 格式的。我们可以在这里看到 JSON 格式的更新配方。

13.  接下来，我们将查看是否可以使用其 ID 查找配方。我们只希望在响应中看到 ID 为**3**的配方。为此，单击**+**按钮，在**获取请求**选项卡旁边创建一个新选项卡。
14.  选择**获取**作为 HTTP 方法。输入**http://localhost:5000/recipes/3** 作为请求 URL。
15.  Click **Send**. The result is shown in the following screenshot:

    ![Figure 1.18: Looking for the recipe with ID ](../images/00145.jpeg)

    ###### 图 1.18：查找 ID 为的配方

    我们可以在响应中看到，只返回 ID 为**3**的配方。它也有我们刚刚设置的修改细节。

16.  When we search for a recipe that doesn't exist, we will see the following response, with a message **recipe not found**. Search by using the **http://localhost:5000/recipes/101** endpoint. The result is shown in the following screenshot:

    ![Figure 1.19: Response showing "recipe not found" ](../images/00146.jpeg)

###### 图 1.19：显示“未找到配方”的响应

### 活动 2：实现并测试删除配方功能

**溶液**

1.  The **delete_recipe** function removes a recipe from the memory. Use **recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)** to get the recipe with the specific ID:

    @app.route（'/recipes/<recipe_id>，methods=['DELETE']）</recipe_id>

    def 删除配方（配方 id）：

    配方=下一步（（如果配方['id']==配方 id，则配方中配方的配方），无）

    如果不是配方：

    返回 jsonify（{'message'：'recipe not found'}），HTTPStatus.not_found

    配方。删除（配方）

    返回“”，HTTPStatus.NO\u 内容

2.  与前面显示的**更新配方**功能类似，如果找不到配方，则返回“**配方未找到**，并返回 HTTP 状态**未找到**。否则，我们将继续从我们的配方集合中删除具有给定 ID 的配方，其 HTTP 状态为**204 无内容**
3.  代码完成后，*右键点击**app.py**文件上的*并点击**run**启动应用程序。Flask 服务器将启动，我们的应用程序已准备好进行测试。
4.  Use httpie or curl to delete the recipe with **ID = 1**:

    http 删除本地主机：5000/recipes/1

    下面是该命令的**curl**版本，它执行相同的操作。

    curl-i-X 删除 localhost:5000/recipes/1

    **@app.route（'/recipes/<int:recipe\u id>，methods=['DELETE']）**路由将捕获客户端请求并调用**DELETE\u recipe（recipe\u id）**函数。该函数将查找具有**配方 id**id 的配方，如果找到，将删除该配方。作为回应，我们可以看到删除已经成功。我们看到 HTTP 状态为**204 无内容**：

    HTTP/1.0 204 无内容

    内容类型：text/html；字符集=utf-8

    日期：2019 年 9 月 6 日星期五 05:57:50 GMT

    服务器：Werkzeug/0.15.6 Python/3.7.0

5.  最后，使用 Postman 删除**ID=2**的配方。为此，单击**+**按钮，在**获取请求**选项卡旁边创建一个新选项卡。
6.  选择**删除**作为**HTTP**方式。输入**http://localhost:5000/recipes/2** 作为请求 URL。
7.  Click **Send**. The result is shown in the following screenshot:

    ![Figure 1.20: Deleting the recipe ](../images/00147.jpeg)

###### 图 1.20：删除配方

然后我们可以看到 HTTP 状态为**204 无内容**的响应。这意味着配方已成功删除。

## 2：开始建设我们的项目

### 活动 3：使用邮递员测试 API

**溶液**

1.  首先，构建一个请求新配方的客户机请求。然后，利用 Postman 中的 collection 函数来提高测试效率。
2.  点击**集合**选项卡，然后点击**+**创建新集合。
3.  输入**笑脸书**作为名称，点击**创建**。
4.  *在**上点击***右键。。。在**笑脸书**旁边，在**笑脸书**下新建一个文件夹，并在名称字段中键入**配方**。
5.  *右键点击**配方**上的*创建新请求。然后，将名称设置为**RecipeList**并保存在**配方**集合下。
6.  在下拉列表中选择**POST**作为 HTTP 方式，输入**http://localhost:5000/recipes** 在请求 URL 字段中。
7.  Now, go to the **Body** tab and select **raw**. Then, choose **JSON (application/json)** in the drop-down menu and type the following code into the **body** field:

    {

    “名称”：“奶酪比萨饼”，

    “描述”：“这是一个可爱的奶酪比萨饼”，

    “份数”：2，

    “烹饪时间”：30，

    “说明”：“这就是你的制作方法”

    }

8.  **Save** and send the recipe. The result is shown in the following screenshot:

    ![Figure 2.10: Creating our first recipe by sending the details in JSON format ](../images/00148.jpeg)

    ###### 图 2.10：通过以 JSON 格式发送详细信息来创建我们的第一个配方

    在 HTTP 响应中，您将看到 HTTP 状态**201 Created**，这意味着请求成功，在正文中，您应该看到我们刚才创建的相同配方。配方的 ID 应为 1。

9.  Create the second recipe by sending over a client request. Next, we will create our second recipe by sending the following details in JSON format:

    {

    “名称”：“番茄面食”，

    “描述”：“这是一个可爱的番茄面食食谱”，

    “份数”：3，

    “烹饪时间”：20，

    “说明”：“这就是你的制作方法”

    }

10.  Click **Send**. The result is shown in the following screenshot:

    ![Figure 2.11: Creating our second recipe by sending the details in JSON format ](../images/00149.jpeg)

    ###### 图 2.11：通过以 JSON 格式发送详细信息来创建第二个配方

    在 HTTP 响应中，您将看到 HTTP 状态**201 Created**，这意味着请求成功，在正文中，您应该看到我们刚才创建的相同配方。配方的 ID 应为 2。

    到目前为止，我们已经创造了两个食谱。让我们使用 Postman 检索这些配方，并确认这两个配方是否在应用程序内存中。

11.  在**配方**文件夹下创建一个新请求，将其命名为**RecipeList**，然后保存。
12.  选择我们刚刚创建的**RecipeList**（HTTP 方法设置为 GET 的那个）。
13.  Type **http://localhost:5000/recipes** in the request URL. Then, click **Save** and send the request. The result is shown in the following screenshot:

    ![Figure 2.12: Retrieving all the recipes using Postman and confirming whether they are in the application's memory ](../images/00150.jpeg)

    ###### 图2.12：使用 Postman 检索所有配方并确认它们是否在应用程序的内存中

    在 HTTP 响应中，您将看到 HTTP 状态**200 OK**，这意味着请求成功，在正文中，您应该看不到任何数据，因为我们创建的两个配方尚未设置为发布。现在，我们知道我们只能检索已发布的配方。让我们将**ID=1**的配方设置为已发布。

14.  在**配方**文件夹下创建一个 new 请求，命名为**RecipePublish**，然后保存。
15.  点击我们刚刚创建的the**RecipePublish**请求（HTTP 方法设置为 GET 的请求）。
16.  Select **PUT** as the HTTP method in the drop-down list and type **http://localhost:5000/recipes/1/publish** in the request URL. Then, click **Save** and send the request. The result is shown in the following screenshot:

    ![Figure 2.13: Retrieving the published recipe ](../images/00151.jpeg)

    ###### 图2.13：检索已发布的配方

    在 HTTP 响应中，您将看到 HTTP 状态**204 无内容**，表示请求已成功发布，响应体中未返回任何数据。

17.  Retrieve all the recipes using Postman again. Select **RecipeList** (**GET**) from the left-hand panel and send the request. The result is shown in the following screenshot:

    ![Figure 2.14: Retrieving all the recipes using Postman ](../images/00152.jpeg)

    ###### 图 2.14：使用邮递员检索所有食谱

    在 HTTP 响应中，您将看到 HTTP 状态**200 OK**，表示请求成功。正文应包含已发布的配方。它应该是我们之前发布的相同配方。

    我们将使用 PUT 方法修改 ID 为 1 的配方，将修改后的配方数据发送到 URL 路由，即**localhost:5000/recipes/1**。

18.  在**配方**文件夹下新建请求，将**请求名称**设置为**配方**，并保存。然后，将 HTTP 方法更改为**PUT**并键入**http://localhost:5000/recipes/1** 在请求 URL 中。
19.  Now, go to the **Body** tab and select raw, choose **JSON (application/json)** from the drop-down menu, and insert the following code into the body field. This is the modified recipe:

    {

    “名称：“可爱的奶酪比萨饼”，

    “描述”：“这是一个可爱的奶酪比萨食谱”，

    “份数”：3，

    “烹饪时间”：60，

    “说明”：“这就是你的制作方法”

    }

20.  **Save** and send it. The result is shown in the following screenshot:

    ![Figure 2.15: Modifying the recipe with ID 1 ](../images/00153.jpeg)

    ###### 图 2.15：修改 ID 为 1 的配方

    在 HTTP 响应中，您将看到 HTTP 状态**200 OK**，表示修改成功。正文应包含 JSON 格式的配方 1 的更新详细信息。我们将检索 ID 为 1 的配方。

21.  在**配方**文件夹下新建请求，将**请求名称**设置为**配方**，并保存。然后，将 HTTP 方法更改为**获取**并键入**http://localhost:5000/recipes/1** 在请求 URL 中。
22.  **Save** and send it. The result is shown in the following screenshot:

    ![Figure 2.16: Retrieving the recipe with ID 1 ](../images/00154.jpeg)

###### 图 2.16：检索 ID 为 1 的配方

在 HTTP 响应中，您将看到 HTTP 状态**200 OK**，表示请求成功。正文应包含 JSON 格式的**配方 1**的详细信息。

### 活动 4：实现删除配方功能

**溶液**

1.  Add the **delete** function to **RecipeResource**. Implement the **delete** method by following the sample code:

    def delete（自我，配方 id）：

    配方=下一步（如果 recipe.id==配方 id，则配方列表中配方的配方），无）

    如果配方为无：

    返回{'message'：'recipe not found'}，HTTPStatus.not_found

    配方列表。删除（配方）

    返回{}，HTTPStatus.NO_ 内容

    我们在这里构建的第三种方法已被删除。为此，我们使用相应的配方 ID 定位配方，然后将其从配方列表中删除。最后返回 HTTP 状态**204 无内容**。

2.  *在**app.py**文件上点击*右键，点击**运行**启动应用程序。Flask 服务器将启动，我们的应用程序将准备好进行测试。现在，使用 Postman 创建第一个食谱。我们将构建一个请求新配方的客户端请求。
3.  First, select the **RecipeList POST** request. Now, send the request by clicking the **Send** button, as shown in the following screenshot:

    ![Figure 2.17: Creating the first recipe using Postman ](../images/00155.jpeg)

    ###### 图 2.17：使用 Postman 创建第一个配方

4.  现在，我们将使用 Postman 删除一个配方。为此，请删除 ID 为 1 的配方。
5.  在**配方**文件夹下创建新请求。然后，将**请求名称**设置为**配方**并**保存**。
6.  Change the **HTTP** method to **DELETE** and type **http://localhost:5000/recipes/1** in the request URL. Then, save and send the request. The result is shown in the following screenshot:

    ![Figure 2.18: Deleting a recipe using Postman ](../images/00156.jpeg)

###### 图 2.18：使用邮递员删除配方

在 HTTP 响应中，您将看到 HTTP 状态**204 无内容**，表示删除成功，主体内容为空。下表显示了我们在此活动中为**ReciperSource**类构建的方法：

![Figure 2.19: The method that we built for the RecipeResource class ](../images/00157.jpeg)

###### 图 2.19：我们为 ReciperSource 类构建的方法

## 3：使用 SQLAlchemy 操作数据库

### 活动 5：创建用户和配方

**溶液**

1.  Open the Python console at the bottom of PyCharm and type in the following code to import the necessary modules and classes:

    从应用程序导入*

    从 models.user 导入用户

    从 models.recipe 导入配方

    app=create_app（）

2.  Create a **user** object and save that to the database by typing in the following code in the Python console:

    用户=用户（用户名='peter'，电子邮件='peter@gmail.com“，密码='WkQa'）

    db.session.add（用户）

    db.session.commit（）

3.  Next, we will create two recipes using the following code. One thing to note is the fact that the **user_id** attribute of the recipe is set to **user.id**. This is to indicate that the recipe was created by the user **Peter**:

    carbonara=Recipe（name='carbonara'，description='这是一个可爱的 carbonara 配方'，份数=4 份，烹调时间=50 次，说明='这是如何制作的'，user\u id=user.id）

    db.session.add（carbonara）

    db.session.commit（）

    意大利调味饭=食谱（名称 class='risotto'，描述 class='这是一个可爱的意大利调味饭食谱'，份数=5，烹调时间=40，说明 class='这是如何制作的'，用户 id=user.id）

    db.session.add（意大利调味饭）

    db.session.commit（）

4.  We can see a new record there in the **user** table:

    ![Figure 3.18: New record in the user table ](../images/00158.jpeg)

    ###### 图 3.18：用户表中的新记录

5.  We will then check whether the two recipes have been created in the database

    ![Figure 3.19: Checking whether the two recipes have been created ](../images/00159.jpeg)

    :

###### 图 3.19：检查两个配方是否已创建

### 活动 6：升级和降级数据库

**溶液**

1.  Add a new attribute to the **user** class:

    bio=db.Column（db.String（））

2.  Now, run the **flask db migrate** command to create the database and tables:

    烧瓶数据库迁移

    Flask Migrate 检测到新列，并为此创建了一个脚本：

    信息[alembic.runtime.migration]上下文 impl PostgresqlImpl。

    INFO[alembic.runtime.migration]将采用事务 DDL。

    INFO[alembic.ddl.postgresql]检测到名为“user_id_seq”的序列由整型列“user（id）”拥有，假设为串行并省略

    INFO[alembic.ddl.postgresql]检测到名为“recipe_id_seq”的序列属于整型列“recipe（id）”，假设为串行并省略

    信息[alembic.autogenerate.compare]检测到添加的列“user.bio”

    正在生成/PythonAPI 开发基础知识/smilebook/migrations/versions/6971bd62ec60_uuzy.py。。。完成

3.  Now, check **/migrations/versions/6971bd62ec60_.py** under the **versions** folder. This file is created by Flask-Migrate. Note that you may get a different revision ID here. Please review the file before you run the **flask db upgrade** command. That's because, sometimes, it may not detect every change you make to your models:

    “”“空消息

    修订编号：6971bd62ec60

    修订：1b69a78087e5

    创建日期：2019-10-08 12:11:47.3700082

    """

    从 alembic 导入 op

    将 sqlalchemy 作为 sa 导入

    #Alembic 使用的修订标识符。

    修订版='6971bd62ec60'

    向下修订='1b69a78087e5'

    分支标签=无

    依赖=无

    def 升级（）：

    #####命令由 Alembic 自动生成-请调整###

    op.add_ 列（'user'，sa.column（'bio'，sa.String（），nullable=True））

    #####结束 Alembic 命令###

    def 降级（）：

    #####命令由 Alembic 自动生成-请调整###

    op.drop_ 列（'user'，'bio'））

    #####结束 Alembic 命令###

    此自动生成的文件中有两个函数；一个是升级，这是将新配方和用户添加到表中，而另一个是降级，即返回到以前的版本。

4.  We will then execute the **flask db upgrade** command, which will upgrade our database to conform with the latest specification in our models:

    烧瓶数据库升级

    此命令将调用**upgrade（）**来升级数据库：

    信息[alembic.runtime.migration]上下文 impl PostgresqlImpl。

    INFO[alembic.runtime.migration]将采用事务 DDL。

    信息[alembic.runtime.migration]正在运行升级 a6d248ab7b23->6971bd62ec60，空消息

5.  Check whether the new field is created in the database. Go to **smilecook** >> **Schemas** >> **Tables** >> **user** >> **Properties to verify**:

    ![Figure 3.20: Checking whether the new field has been created in the database ](../images/00160.jpeg)

###### 图 3.20：检查是否已在数据库中创建新字段

运行**降级**命令删除新字段：

分贝降级

此命令将调用**降级（）**对数据库进行降级：

信息[alembic.runtime.migration]上下文 impl PostgresqlImpl。

INFO[alembic.runtime.migration]将采用事务 DDL。

运行降级 6971bd62ec60->a6d248ab7b23 的信息[alembic.runtime.migration]，空消息

检查该字段是否已被删除。转到**笑脸书**→ **模式**→ **表**→ **用户**→ **要验证的属性**：

![Figure 3.21: Checking whether the field has been removed from the database ](../images/00161.jpeg)

###### 图 3.21：检查字段是否已从数据库中删除

## 4：通过 JWTs 认证的服务和安全性

### 活动 7：对发布/取消发布配方功能进行访问控制

**溶液**

1.  Modify the **put** method in **RecipePublishResource** to restrict access to only authenticated users. In **resources/token.py**, add the **@jwt_required** decorator on top of the **RecipePublishResource.put** method. Use the **get_jwt_identity()** function to identify whether the authenticated user is the owner of the recipe:

    @jwt_ 必需

    def put（自身，配方 id）：

    配方=配方。通过配方 id 获取配方（配方 id=配方 id）

    如果配方为无：

    返回{'message'：'Recipe not found'}，HTTPStatus.not_found

    当前用户=获取 jwt 身份（）

    如果当前 _ 用户！=recipe.user\u id:

    返回{'message'：'Access is not allowed'}，HTTPStatus.probled

    recipe.is_publish=True

    recipe.save（）

    返回{}，HTTPStatus.NO_ 内容

    这是为了出版食谱。只有已登录的用户才能发布自己的食谱。该方法将执行各种检查，以确保用户具有发布权限。配方发布后返回**204 无内容**。

2.  Modify the **delete** method in **RecipePublishResource**. Only an authenticated user can unpublish the recipe:

    @需要 jwt_

    def delete（自我，配方 id）：

    配方=配方。通过配方 id 获取配方（配方 id=配方 id）

    如果配方为无：

    返回{'message'：'Recipe not found'}，HTTPStatus.not_found

    当前用户=获取 jwt 身份（）

    如果当前 _ 用户！=recipe.user\u id:

    返回{'message'：'Access is not allowed'}，HTTPStatus.probled

    recipe.is_publish=False

    recipe.save（）

    返回{}，HTTPStatus.NO_ 内容

    这将取消发布配方。与前面的代码类似，只有已登录的用户才能取消发布自己的配方。配方发布后返回**状态**代码**204 无内容**。

3.  登录到用户帐户并获取访问令牌。选择我们之前创建的**POST**令牌请求。
4.  Check the **raw** radio button and select **JSON (application/json)** from the drop-down menu. Type in the following JSON content in the **Body** field:

    {

    “电子邮件”：james@gmail.com",

    “密码”：“WkQad19”

    }

5.  Click **Send** to log in to the account. The result is shown in the following screenshot:

    ![Figure 4.20: Log in to the user account ](../images/00162.jpeg)

    ###### 图 4.20：登录到用户帐户

    您将看到 HTTP**状态**代码**200 OK**，表示登录成功。我们可以在响应体中看到**访问令牌**和**刷新令牌**。

6.  在用户登录状态下发布**id=3**的配方。选择**放置交互发布**。
7.  转到**头**选项卡，将**授权**放在密钥字段中，将**承载{token}**放在**值**字段中，其中 token 是我们在上一步中获得的 JWT 令牌。
8.  Click **Send** to publish the recipe. The result is shown in the following screenshot:

    ![Figure 4.21: Publishing the recipe ](../images/00163.jpeg)

    ###### 图 4.21：发布配方

    然后您将看到响应，HTTP**状态**代码**204**表示配方已成功发布。

    最后，尝试获取所有已发布的食谱。选择**获取 RecipeList**请求，然后点击**发送**获取所有发布的配方详情。结果显示在以下屏幕截图中：

    ![Figure 4.22: Retrieving all published recipes ](../images/00164.jpeg)

    ###### 图 4.22：检索所有已发布的配方

    然后您将看到响应，HTTP**状态**代码**200**表示请求成功，您可以看到返回了我们创建的一个已发布配方。

9.  在用户已登录状态下，取消发布**id=3**的配方。在**配方**文件夹下创建一个新请求，将其命名为**RecipePublish**，然后保存。
10.  点击我们刚刚创建的**RecipePublish**请求（HTTP 方法设置为**GET**的请求）。
11.  在下拉列表中选择**删除**作为 HTTP 方式，输入**http://localhost:5000/recipes/3/publish** 在请求 URL 中。
12.  进入**头**页签，将**授权**放在密钥字段，将**承载{token}**放在**值**字段，其中 token 是我们在*步骤 5*中得到的 JWT 令牌。
13.  **Save** and **Send** the request to unpublish. The result is shown in the following screenshot:

    ![Figure 4.23: Unpublishing the recipe ](../images/00165.jpeg)

###### 图 4.23：取消发布配方

## 5：使用棉花糖的 Validating API

### 活动 8：使用棉花糖序列化配方对象

**溶液**

1.  Modify the recipe schema to include all attributes except for **email**. In **schemas/recipe.py**, modify **only=['id', 'username'] to exclude=('email', )**. This way, we will be showing everything except for the user's email address. Besides, if we have a new attribute for the **recipe** object in the future (for example, a **user avatar** URL), we won't need to modify the schema again because it will show everything:

    author=fields.Nested（UserSchema，attribute='user'，dump_only=True，exclude=（'email'，））

2.  Modify the **get** method in **RecipeResource** to serialize the **recipe** object into JSON format using the recipe schema:

    返回 recipe_schema.dump（recipe）.data，HTTPStatus.OK

    这主要是修改代码，使用**配方\模式.dump（recipe）.data**使用配方模式返回配方详细信息。

3.  Right-click on it to run the application. Flask will then be started up and run on the localhost (**127.0.0.1**) at port **5000**:

    ![Figure 5.18: Run Flask on the localhost ](../images/00166.jpeg)

    ###### 图 5.18：在本地主机上运行 Flask

4.  Test the implementation by getting one specific published recipe in Postman. Select the **GET Recipe** request. Enter **http://localhost:5000/recipes/4** in **Enter request URL**. Click **Send** to get specific recipe details. The result is shown in the following screenshot:

    ![Figure 5.19: Select the GET Recipe request and send the request ](../images/00167.jpeg)

###### 图 5.19：选择 GET Recipe 请求并发送请求

然后您将看到返回响应。这里的 HTTP 状态码**200 OK**表示请求成功。在响应体中，我们可以获得 ID 为 4 的配方详细信息，如您所见，您还可以看到用户的注册时间，即在创建的**。**

## 6：电子邮件确认

### 活动 9：测试完整的用户注册和激活工作流

**溶液**

1.  我们将首先通过 Postman 注册一个新用户。点击**集合**页签，选择**POST UserList**请求。
2.  选择**主体**选项卡，然后选择**原始**单选按钮，从下拉列表中选择**JSON（应用程序/JSON）**。
3.  Put in the following user details (in JSON format) in the **Body** field. Change the username and password to the appropriate one:

    {

    “用户名”：“约翰”，

    “电子邮件”：“笑脸书”。api@gmail.com",

    “密码”：“Kwq2z5”

    }

4.  Send the request. You should see the following output:

    ![Figure 6.10: Registering a user through Postman ](../images/00168.jpeg)

    ###### 图 6.10：通过邮递员注册用户

    您应该在响应中看到新的用户详细信息（**ID=4**），其中**HTTP 状态为 201 OK**。这意味着新用户已在后端成功创建。

5.  通过 API 登录并单击**集合**选项卡。然后，选择我们之前创建的**POST Token**请求。
6.  现在，点击**主体**选项卡。选中**原始**单选按钮，从下拉菜单中选择**JSON（应用程序/JSON）**。
7.  Type in the following JSON content (email and password) in the **Body** field:

    {

    “电子邮件”：“笑脸书”。api@gmail.com",

    “密码”：“Kwq2z5”

    }

8.  Send the request. You should see the following output:

    ![Figure 6.11: Sending the request using JSON ](../images/00169.jpeg)

    ###### 图 6.11：使用 JSON 发送请求

    您应该会收到一条消息，说明用户帐户尚未激活，**HTTP 状态 403 禁止**。这是预期的行为，因为我们的应用程序将要求用户首先激活帐户。

9.  Please check your mailbox for the activation email. There should be a link there for you to activate the user's account. Click on that link to activate the account. It should look as follows:

    ![Figure 6.12: Activation mail ](../images/00170.jpeg)

    ###### 图 6.12：激活邮件

10.  激活帐户后再次登录。点击**集合**选项卡。
11.  Select the **POST Token** request that we created earlier and send the request. You'll see the following:

    ![Figure 6.13: After activating the account, select the POST Token request ](../images/00171.jpeg)

###### 图 6.13：激活帐户后，选择 POST 令牌请求

您应该在响应中看到访问令牌和刷新令牌，HTTP 状态为**200 OK**。这意味着登录成功。

### 活动 10：创建 HTML 格式的用户账户激活电子邮件

**溶液**

1.  Click **Sending** >> **Overview** on the **Mailgun** dashboard, then add the email of our new user to the authorized recipient list on the right. **Mailgun** will then send a confirmation email to that email address:

    ![Figure 6.14: Sending a confirmation email to our new user ](../images/00172.jpeg)

    ###### 图 6.14：向新用户发送确认电子邮件

    #### 笔记

    由于我们使用的是**Mailgun**的沙箱版本，因此对向外部电子邮件地址发送电子邮件有限制。必须首先将这些电子邮件添加到授权收件人列表中。

2.  Check the mailbox of the new user, and click **I Agree**. This will be as shown in the following screenshot:

    ![Figure 6.15: The mailbox of a new user with an email from Mailgun ](../images/00173.jpeg)

    ###### 图 6.15:一个新用户的邮箱中有一封来自 Mailgun 的电子邮件

3.  On the confirmation page, click **yes** to activate the account. The screen will appear as follows:

    ![Figure 6.16: Activation complete message ](../images/00174.jpeg)

    ###### 图 6.16：激活完成消息

4.  HTML template code is provided by **Mailgun** out of the box. We can find it under **Sending > Templates**. There, click **Create Message Template** and select **Action template**. We will find a template for a confirmation email and preview it:

    ![Figure 6.17: Previewing the confirm email address template ](../images/00175.jpeg)

    ###### 图 6.17：预览确认电子邮件地址模板

5.  然后，在我们的项目下创建一个**templates**文件夹。我们将把所有的 HTML 模板放在这个文件夹中。在**模板**文件夹中，创建一个子文件夹**电子邮件**，用于与电子邮件相关的 HTML 模板。
6.  Now, create a template file, **confirmation.html**, and paste the sample HTML code from **Mailgun** in *step 4*. Take a look at the sample HTML code from **Mailgun** that follows:

    ![Figure 6.18: Sample HTML code from Mailgun ](../images/00176.jpeg)

    ###### 图 6.18：来自 Mailgun 的示例 HTML 代码

    #### 笔记

    请注意，我们需要更改[http://www.mailgun.com](http://www.mailgun.com) 链接到**{{link}}**。此占位符将以编程方式替换为帐户激活链接。

7.  Import the **render_template** function from Flask by entering the following line of code in **resources/user.py**:

    来自 flask 导入请求、url\u for、render\u 模板

8.  In the **POST** method under **UserListResource**, we will pass in the HTML code as a parameter to the **send_mail** method. The HTML code can be rendered using the **render_template** function. You can see that the **link = link** parameter here is to replace the **{{link}}** placeholder in the HTML template with the actual account validation link:

    mailgun.send_email（to=user.email，

    主语，

    text=text，

    html=render_ 模板（'email/confirmation.html'，link=link））

9.  Register a new account using Postman:

    {

    “用户名”：“emily”，

    “电子邮件”：“笑脸书”。user@gmail.com",

    “密码”：“Wqb6g2”

    }

    #### 笔记

    请注意，电子邮件地址已事先在**邮枪**中验证。

    输出结果如下：

    ![Figure 6.19: Registering a new account using Postman ](../images/00177.jpeg)

    ###### 图 6.19：使用邮递员注册新账户

10.  The account activation email will then be received in HTML format. The output is shown in the following screenshot:

    ![Figure 6.20: Account confirmation email ](../images/00178.jpeg)

###### 图 6.20：账户确认电子邮件

## 7：使用图像

### 活动 11：实现配方封面图片上传功能

**溶液**

1.  Add the **cover_image** attribute to the User model in **models/recipe.py**:

    cover\u image=db.Column（db.String（100），默认值=None）

    **cover_image**属性将图像文件名作为字符串包含，最大长度为 100 个字符。

2.  Use the flask db migrate command to generate a database table update script:

    烧瓶数据库迁移

    您将看到已检测到一个新列，**‘recipe.cover_image’**：

    信息[alembic.runtime.migration]上下文 impl PostgresqlImpl。

    INFO[alembic.runtime.migration]将采用事务 DDL。

    信息[alembic.autogenerate.compare]检测到添加了列“recipe.cover\u image”

    生成/培训 ByPackt/PythonAPI 开发基础知识/Lesson07/SmileBook/migrations/versions/91c7dc71b826_u826.py。。。完成

3.  Check the script at **/migrations/versions/xxxxxxxxxx_.py**:

    “”“空消息

    修订 ID:91c7dc71b826

    修订：7aafe51af016

    创建日期：2019-09-22 12:06:36.061632

    """

    从 alembic 导入 op

    将 sqlalchemy 作为 sa 导入

    #Alembic 使用的修订标识符。

    修订版='91c7dc71b826'

    向下修订='7aafe51af016'

    分支标签=无

    依赖=无

    def 升级（）：

    #####命令由 Alembic 自动生成-请调整###

    op.add_ 列（'recipe'，sa.column（'cover_image'，sa.String（长度=100），nullable=True））

    #####结束 Alembic 命令###

    def 降级（）：

    #####命令由 Alembic 自动生成-请调整###

    op.drop_ 栏（“配方”、“封面图片”）

    #####结束 Alembic 命令###

    从它的内容中，我们可以看到脚本中生成了两个函数。**升级**功能用于将新的**封面**列添加到数据库表中，而**降级**功能用于删除**封面**列，使其恢复到原始状态。

4.  Run the **flask db upgrade** command to update the database and reflect the change in the **User** model:

    烧瓶数据库升级

    运行上述命令后，我们应该看到以下输出：

    信息[alembic.runtime.migration]上下文 impl PostgresqlImpl。

    INFO[alembic.runtime.migration]将采用事务 DDL。

    信息[alembic.runtime.migration]正在运行升级 7aafe51af016->91c7dc71b826，空消息

5.  Check the new **cover_image** column in pgAdmin:

    ![Figure 7.10: The cover_image column in pgAdmin ](../images/00179.jpeg)

    ###### 图 7.10:pgAdmin 中的封面图像列

    这确认新的**封面图片**列已添加到配方表中。

6.  In **schemas/recipe.py**, import the **url_for** package and add the **cover_url** attribute and the **dump_cover_url** method:

    从的 flask 导入 url_

    cover\u url=fields.Method（serialize='dump\u cover\u url'）

    def 转储 _ 封面 _url（自身、配方）：

    如果 recipe.cover_ 图像：

    返回（'static'，filename='images/recipes/{}'。格式（recipe.cover\u image），\u external=True）

    其他：

    返回 url_for（'static'，filename='images/assets/default recipe cover.jpg'，_external=True）

    将**default-recipe-cover.jpg**图像添加到**静态/图像**中：

    ![Figure 7.11: Folder structure after adding default-recipe-cover.jpg ](../images/00180.jpeg)

    ###### 图 7.11：添加 default-recipe-cover.jpg 后的文件夹结构

7.  In **resources/recipe.py**, add the import **os**, **image_set**, and **save_image** functions:

    导入操作系统

    从扩展导入图像集

    从 utils 导入保存图像

    在 resources/recipe.py 中，添加 recipe\u cover\u schema，只显示 cover\u url 列：

    recipe\u cover\u schema=RecipeSchema（仅=（'cover\u url'，））

8.  In **resources/recipe.py**, add the **RecipeCoverUpload** resource to upload the recipe cover to the recipes folder:

    类 RecipeCoverUploadResource（资源）：

    @jwt_ 必需

    def put（自身，配方 id）：

    file=request.files.get（'cover'）

    如果不是文件：

    返回{'message'：'不是有效图像'}，HTTPStatus.BAD_ 请求

    如果不允许使用 image\u set.file（文件，file.filename）：

    返回{'message'：'File type not allowed'}，HTTPStatus.BAD_ 请求

    **PUT**方法之前的**@jwt_required**修饰符表示只有用户登录后才能调用该方法。在**PUT**方法中，我们尝试在**request.files**中获取封面图像文件。然后，我们尝试验证它是否存在以及是否允许文件扩展名。

9.  After that, we retrieved the recipe object using **recipe_id**. First, we check whether a user has the right to modify the recipe. If the user has the right to, we will go ahead and modify the cover image of the recipe:

    配方=配方。通过配方 id 获取配方（配方 id=配方 id）

    如果配方为无：

    返回{'message'：'Recipe not found'}，HTTPStatus.not_found

    当前用户=获取 jwt 身份（）

    如果当前 _ 用户！=recipe.user\u id:

    返回{'message'：'Access is not allowed'}，HTTPStatus.probled

    如果 recipe.cover_ 图像：

    cover\u path=image\u set.path（folder='recipes'，filename=recipe.cover\u image）

    如果 os.path.存在（覆盖路径）：

    移除操作系统（覆盖路径）

10.  Then, we use the **save_image** function to save the uploaded image and set the **recipe.cover_image = filename**. Finally, we save the recipe using **recipe.save()** and return the image URL with an HTTP status code of **200**:

    filename=save_image（image=file，folder='recipes'）

    recipe.cover\u image=文件名

    recipe.save（）

    返回 recipe\u cover\u schema.dump（recipe）.data，HTTPStatus.OK

11.  In **app.py**, import RecipeCoverUploadResource:

    从 resources.recipe 导入 RecipeListResource、RecipeResource、RecipePublishResource、RecipeOveruploadResource

12.  In **app.py**, link **RecipeCoverUploadResource** to the route, that is, **/recipes/<int:recipe_id>/cover**:

    api.添加资源（RecipeCoverUploadResource，'/recipes/<recipe_id>/cover'）</recipe_id>

现在，我们已经创建了用于上传配方封面图像的函数。让我们继续测试它。

### 活动 12：图像上传功能测试

**溶液**

1.  Log in to the user account using Postman. Click on the **Collections** tab and select the **POST Token** request. Then, click the **Send** button. The result can be seen in the following screenshot:

    ![Figure 7.12: Sending a POST Token request ](../images/00181.jpeg)

    ###### 图 7.12：发送 POST 令牌请求

2.  向我们的 API 发送客户端请求，以创建配方，然后单击**集合**选项卡。
3.  Select the **POST RecipeList** request and put **Authorization** in the **KEY** field and **Bearer {token}** in the **VALUE** field, where the token is the access token we retrieved in the previous step. Then, click the **Send** button. The result can be seen in the following screenshot:

    ![Figure 7.13: Sending a client request to our API to create a recipe ](../images/00182.jpeg)

    ###### 图 7.13：向 API 发送客户端请求以创建配方

4.  上传食谱图片。点击**集合**选项卡，右键点击**。。。**在**配方**文件夹旁边创建新请求。
5.  将**请求名称**设置为**RecipeCoverUpload**并保存在**配方**文件夹中。
6.  选择**放置**作为 HTTP 方式，并输入**http://localhost:5000/recipes/ <配方 id>/封面**作为请求 URL（将**<配方 id>**替换为我们从上一步获得的配方 id）。
7.  选择**头**选项卡，在**键**字段中放入**授权**，在**值**字段中放入**承载{token}**，其中 token 是我们在上一步中检索到的访问令牌。
8.  选择**主体**选项卡。然后，选择表单数据单选按钮并在**键**中键入封面。
9.  在**键**旁的下拉菜单中选择**文件**，选择要上传的图像文件。
10.  Click the **Save** button and then the **Send** button. The result can be seen in the following screenshot:

    ![Figure 7.14: Uploading a recipe image ](../images/00183.jpeg)

    ###### 图 7.14：上传配方图像

11.  Check whether the image has been compressed in PyCharm. We can see from the application log in PyCharm that the file size has been reduced by **97%**:

    ![Figure 7.15: Checking whether the images are compressed in PyCharm ](../images/00184.jpeg)

    ###### 图 7.15：检查图像是否在 PyCharm 中压缩

12.  Check the uploaded image in **static/images/recipes**:

    ![Figure 7.16: Checking the uploaded image in the path ](../images/00185.jpeg)

    ###### 图 7.16：检查路径中上传的图像

13.  Get the recipe back and confirm that the **cover_url** attribute is populated. Now, click on the **Collections** tab and select the **GET Recipe** request. Then, type **http://localhost:5000/recipes/5** into the **URL** field. You may replace the recipe ID, that is, 5, with any ID that is appropriate. Then, click the **Send** button. The result can be seen in the following screenshot:

    ![Figure 7.17: Getting the recipe back and confirming that the cover_url attribute is populated ](../images/00186.jpeg)

###### 图 7.17：获取配方并确认 cover_url 属性已填充

祝贺我们已经测试了配方封面图像上传功能。它工作得很好！

## 8：分页、搜索和排序

### 活动 13：在特定于用户的配方检索 API 上实现分页

**溶液**

1.  Modify the code in the **get_all_by_user** method under **models/recipe.py**, as follows:

    @classmethod

    def 按用户获取所有内容（cls、用户 id、页面、每页、可见性='public'）：

    query=cls.query.filter\u by（user\u id=user\u id）

    如果可见性==“公共”：

    query=cls.query.filter\u by（user\u id=user\u id，is\u publish=True）

    elif 可见性==“专用”：

    query=cls.query.filter\u by（user\u id=user\u id，is\u publish=False）

    返回 query.order_by（desc（cls.created_at））.paginate（page=page，per_page=per_page）

2.  Import **RecipePaginationSchema** into **resources/user.py**:

    从 schemas.recipe 导入 RecipeSchema，RecipePaginationSchema

3.  Declare the **recipe_pagination_schema** attribute in **resources/user.py**:

    配方分页模式=RecipePaginationSchema（）

4.  Here, we've added the **@user_kwargs** decorator to **UserRecipeListResource.get**. It takes a few parameters, including **page**, **per_page**, and **visibility**:

    类 UserRecipeListResource（资源）：

    @jwt_ 可选

    @use_kwargs（{'page'：fields.Int（缺少=1），

    “每页”：fields.Int（缺少=10），

    “可见性”：fields.Str（缺少 class='public'）}

5.  Modify the **UserRecipeListResource.get** method in **resources/user.py**:

    def get（自我、用户名、页面、每页、可见性）：

    user=user.get\u by\u 用户名（username=username）

    如果用户为无：

    返回{'message'：'User not found'}，HTTPStatus.not_found

    当前用户=获取 jwt 身份（）

    如果当前 _user==user.id 且在['all'，'private']中可见：

    通过

    其他：

    可见性=‘公共’

    分页的配方=配方。按用户获取所有配方（用户 id=用户 id，页面=页面，每页=每页，可见性=可见性）

    返回 recipe_pagination_schema.dump（分页的 _recipes）.data，HTTPStatus.OK

    **Recipe.get_all_by_user**方法获取特定作者的分页食谱，然后让**Recipe_pagination_schema**序列化分页对象并返回。

### 活动 14：在用户特定配方检索 API 上测试分页

**溶液**

1.  使用邮递员获取约翰手下的所有食谱，一页一页，页面大小为 2。首先，点击**UserRecipeList**请求。
2.  类型**http://localhost:5000/{username}/recipes**进入**请求**URL。这里的**{username}**应该与我们在上一个练习中插入的相同。在我们的例子中，它将是**约翰**。
3.  选择**参数**选项卡并放入键值对中（**每**页、**2**。
4.  Send the request. The result is shown in the following screenshot:

    ![Figure 8.9: Getting all the recipes under John using Postman ](../images/00187.jpeg)

    ###### 图 8.9：使用邮递员获取约翰手下的所有食谱

    在配方的详细信息中，我们可以看到有与**第一个**、**最后一个**和**下一个**页面的 URL 链接。我们在这里看不到**上一页**，因为我们在第一页。总共有四页，我们每页有两条记录。我们还可以在 HTTP 响应中看到排序后的配方详细信息。

5.  Click the next URL in links to query for the next two records in Postman with the request URL populated (**http://localhost:5000/users/john/recipes?per_page=2&page=2**). Then, we just need to click on **Send** to send the request. The result is shown in the following screenshot:

    ![Figure 8.10: Querying for the next two records in Postman with the request URL populated ](../images/00188.jpeg)

###### 图 8.10：在填充请求 URL 的 Postman 中查询接下来的两条记录

从结果中，我们可以看到有指向**第一个**、**最后一个**、**下一个**和**上一个**页面的链接。我们还可以看到，我们目前在第二页。所有配方数据也都在那里。

### 活动 15：搜索含有特定成分的食谱

**溶液**

1.  First, in **models/recipe.py**, add the **ingredients** attribute to the **Recipe** model:

    成分=分贝列（分贝字符串（1000））

2.  Run the following command to generate a database migration script:

    烧瓶数据库迁移

    您将看到，检测到一个名为**recipe.components**的新列：

    信息[alembic.autogenerate.compare]检测到添加了列“recipe.Components”

    正在生成/通过 Packt/PythonAPI 开发基础知识/SmileBook/migrations/versions/0876058ed87e_uuzy.py 进行培训。。。完成

3.  Check the content in **/migrations/versions/0876058ed87e_.py**, which is the database migration script that was generated in the previous step:

    “”“空消息

    修订 ID:0876058ed87e

    修订：91c7dc71b826

    创建日期：2019-10-24 15:05:10.936752

    """

    从 alembic 导入 op

    将 sqlalchemy 作为 sa 导入

    #Alembic 使用的修订标识符。

    修订版='0876058ed87e'

    向下\'91c7dc71b826'

    分支标签=无

    依赖=无

    def 升级（）：

    #####命令由 Alembic 自动生成-请调整###

    op.add_ 列（'recipe'，sa.column（'components'，sa.String（长度=1000），nullable=True））

    #####结束 Alembic 命令###

    def 降级（）：

    #####命令由 Alembic 自动生成-请调整###

    op.drop_ 栏（“配方”、“成分”）

    #####结束 Alembic 命令###

    在这里，我们可以看到脚本中生成了两个函数。**升级**功能用于将新列**配料**添加到配方表中，而**降级**功能用于删除**配料**列，使其恢复到原始状态。

4.  Run the following **flask db upgrade** command to update the database schema:

    烧瓶数据库升级

    您将看到以下输出：

    信息[alembic.runtime.migration]上下文 impl PostgresqlImpl。

    INFO[alembic.runtime.migration]将采用事务 DDL。

    信息[alembic.runtime.migration]正在运行升级 91c7dc71b826->0876058ed87e，空消息

5.  In **schemas/recipe.py**, add the **ingredients** attribute to **RecipeSchema**:

    成分=字段.String（validate=[validate.Length（max=1000）]）

6.  Modify the **RecipeResource.patch** method in **resources/recipe.py** to be able to update **ingredients**:

    recipe.components=data.get（'components'）或 recipe.components

7.  Modify the **Recipe.get_all_published** method in **models/recipe.py** so that it gets all the published recipes that it can through the ingredients:

    返回 cls.query.filter（或（cls.name.ilike（关键字）），

    cls.description.ilike（关键字），

    cls.components.ilike（关键字）），

    cls.is_publish.is_（True））\

    排序依据（排序逻辑）。分页（页=页，每页=每页）

8.  **Right-click** on it to run the application. Flask will then start up and run on **localhost** (**127.0.0.1**) at port **5000**:

    ![Figure 8.11: Running Flask on the localhost ](../images/00029.jpeg)

    ###### 图 8.11：本地主机上的运行烧瓶

9.  Log in to a user account and create two recipes by running the following **httpie** command in the PyCharm console. The **{token}** placeholder should be replaced with the access token:

    http POST localhost:5000/recipes“Authorization:bearier**{token}**”name=“红薯砂锅”description=“这是一个可爱的红薯砂锅”份数=12 烹调时间=60 配料=“4 杯红薯、1/2 杯白糖、2 个鸡蛋、1/2 杯牛奶”说明=“这就是你的制作方法”

    http POST localhost:5000/recipes“Authorization:bearier**{token}**”name=“Pesto Pizza”description=“这是一个可爱的 Pesto Pizza”份数=6 烹饪时间=20 种配料=“1 个预焙比萨饼皮，1/2 杯香蒜酱，1 个成熟番茄”说明=“这就是你做的方法”

10.  Publish these two recipes by using the following **httpie** command:

    http PUT localhost:5000/recipes/14/publish“授权：承载人**{token}**”

    http PUT localhost:5000/recipes/15/publish“授权：承载者**{token}**”

11.  Search for recipes that contain the **eggs** string in the name, description, or ingredients. Click on the **RecipeList** request and select the **Params** tab. Then, insert the first key-value pair (**q**, **eggs**) and send the request. The result is shown in the following screenshot:

    ![Figure 8.12: Searching for the eggs ingredient by sending a request ](../images/00189.jpeg)

###### 图 8.12：通过发送请求搜索鸡蛋成分

从前面的搜索结果中，我们可以看到有一个配方的配料中含有鸡蛋。

## 9：构建更多功能

### 活动16：更新配方详细信息后获取缓存数据

**溶液**

1.  Get all the recipe data back, click on **RecipeList** and send the request. The result is shown in the following screenshot:

    ![Figure 9.15: Get the recipe data back and send the request ](../images/00190.jpeg)

    ###### 图 9.15：获取配方数据并发送请求

2.  Log in to your account, click on the **Collections** tab and select the **POST** **Token** request. Then, send the request. The result is shown in the following screenshot:

    ![Figure 9.16: Select the POST Token request and send it ](../images/00191.jpeg)

    ###### 图 9.16：选择 POST 令牌请求并发送它

3.  使用**补丁**方法修改配方记录。首先，选择**补丁配方**请求。
4.  现在选择**头**页签，修改**承载{令牌}**；令牌应该是访问令牌。
5.  Select the **Body** tab and modify **num_of_servings** to **5**, and **cook_time** to **50**:

    {

    “份数”：5 份，

    “烹饪时间”：50

    }

6.  Send the request. The result is shown in the following screenshot:

    ![Figure 9.17: Modifying a recipe record using the PATCH method ](../images/00192.jpeg)

    ###### 图 9.17：使用补丁方法修改配方记录

7.  再次获取所有配方数据，点击**RecipeList**。
8.  Send the request. The result is shown in the following screenshot:

    ![Figure 9.18: Get all the recipe data back again ](../images/00193.jpeg)

###### 图 9.18：再次获取所有配方数据

我们可以看到，当我们再次获取所有配方详细信息时，这些详细信息没有更新，这将导致用户看到错误的信息。

### 活动 17：增加多个费率限制

**溶液**

1.  In **resources/user.py**, import **limiter** from **extensions**:

    从扩展导入图像集，限制器

2.  In **UserRecipeListResource**, put the **limiter.limit** function in the **decorators** attribute:

    类 UserRecipeListResource（资源）：

    decorators=[limiter.limit（'3/分钟；30/小时；300/天'，methods=['GET']，error\u message='Too Many Requests'）]

3.  Comment out the whitelist in **app.py**:

    #@limiter.request\u 过滤器

    #def ip_ 白名单（）：

    #return request.remote_addr==“127.0.0.1”

    在 PyCharm 中，要注释掉一行代码，如果您使用 Mac，可以使用*命令+/*，如果您使用 Windows，可以使用*Ctrl+/*。

4.  When we are done, click **Run** to start the Flask application; then, we are ready to test it:

    ![Figure 9.19: Starting the Flask application ](../images/00194.jpeg)

    ###### 图 9.19：开始烧瓶应用

5.  获取用户的所有配方，并检查响应标题中的速率限制信息。首先，点击**UserRecipeList**并发送请求。
6.  然后，在**响应**中选择**表头**页签。结果显示在以下屏幕截图中：

![Figure 9.20: Checking the rate limit information in the response header ](../images/00195.jpeg)

###### 图 9.20：检查响应标头中的速率限制信息

在 HTTP 响应中，我们可以看到该端点的速率限制为 3，而我们只有两个剩余的请求配额。该限制将在 60 秒内重置。

## 10：部署

### 活动 18：在 Postman 中将访问令牌更改为变量

**溶液**

1.  Perform user login and get the access token. Use the **POST Token** request to get the access token. You should see the following output:

    ![Figure 10.26: Performing user login to get an access token ](../images/00196.jpeg)

    ###### 图 10.29：执行用户登录以获取访问令牌

2.  Click **Manage environments** in the top right-hand corner in Postman. Create the **access_token** variable. The value is the access token we obtained in the previous step. Then, click **Update**:

    ![Figure 10.27: Adding more environment variables in Postman ](../images/00197.jpeg)

    ###### 图 10.30：在 Postman 中添加更多环境 v变量

3.  Select the **GET** **User** request. In the **Headers** tab, change the **Authorization** value to **Bearer {{access_token}}**, which is the environment variable we added in the previous step, and then send the request. You should see the following output:

    ![Figure 10.28: Using more environment variables in Postman](../images/00198.jpeg)

###### 图 10.31：在 Postman 中使用更多环境变量