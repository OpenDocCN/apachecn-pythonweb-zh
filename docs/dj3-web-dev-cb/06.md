# 六、模型管理

在本章中，我们将介绍以下主题：

*   自定义“更改列表”页面上的列
*   创建可排序的内联线
*   创建管理操作
*   开发变更列表过滤器
*   更改第三方应用的应用标签
*   创建自定义帐户应用程序
*   获取用户 Gravatar
*   将地图插入到变更表单中

# 介绍

Django 框架为您的数据模型提供了一个内置的管理系统。只需很少的努力，您就可以设置可过滤、可搜索和可排序的列表以浏览模型，并且可以配置表单以添加和管理数据。在本章中，我们将通过开发一些实际案例，介绍可用于定制管理的高级技术。

# 技术要求

要使用本章中的代码，您将需要最新稳定版本的 Python、MySQL 或 PostgreSQL 数据库以及带有虚拟环境的 Django 项目。

您可以在本书 GitHub 存储库的`chapter 06`目录中找到本章的所有代码：[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition)

# 自定义“更改列表”页面上的列

默认 Django 管理系统中的变更列表视图提供了特定模型的所有实例的概览。默认情况下，`list_display`model admin 属性控制显示在不同列中的字段。此外，您可以实现自定义管理方法，这些方法将从关系返回数据或显示自定义 HTML。在这个配方中，我们将创建一个特殊函数，与`list_display`属性一起使用，它在列表视图的一列中显示一个图像。作为奖励，我们将通过添加`list_editable`设置，使列表视图中的一个字段直接可编辑。

# 准备

对于这个配方，我们需要`Pillow`和`django-imagekit`库。让我们使用以下命令在虚拟环境中安装它们：

```py
(env)$ pip install Pillow
(env)$ pip install django-imagekit
```

确保设置中的`django.contrib.admin`和`imagekit`处于`INSTALLED_APPS`位置：

```py
# myproject/settings/_base.py
INSTALLED_APPS = [
   # …
   "django.contrib.admin",
   "imagekit",
]
```

然后，在 URL 配置中连接管理站点，如下所示：

```py
# myproject/urls.py
from django.contrib import admin
from django.conf.urls.i18n import i18n_patterns
from django.urls import include, path

urlpatterns = i18n_patterns(
    # …
    path("admin/", admin.site.urls),
)
```

接下来，创建一个新的`products`应用程序并将其置于`INSTALLED_APPS`下。此应用程序将包含`Product`和`ProductPhoto`型号。在这里，一个产品可能有多张照片。在本例中，我们还将使用`UrlMixin`，这是在[第 2 章](02.html)*模型和数据库结构*中*使用 URL 相关方法*创建模型混合中定义的。

让我们在`models.py`文件中创建`Product`和`ProductPhoto`模型，如下所示：

```py
# myproject/apps/products/models.py import os

from django.urls import reverse, NoReverseMatch
from django.db import models
from django.utils.timezone import now as timezone_now
from django.utils.translation import ugettext_lazy as _

from ordered_model.models import OrderedModel

from myproject.apps.core.models import UrlBase

def product_photo_upload_to(instance, filename):
    now = timezone_now()
    slug = instance.product.slug
    base, ext = os.path.splitext(filename)
    return f"products/{slug}/{now:%Y%m%d%H%M%S}{ext.lower()}"

class Product(UrlBase):
    title = models.CharField(_("title"), max_length=200)
    slug = models.SlugField(_("slug"), max_length=200)
    description = models.TextField(_("description"), blank=True)
    price = models.DecimalField(
        _("price (EUR)"), max_digits=8, decimal_places=2, 
         blank=True, null=True
    )

    class Meta:
        verbose_name = _("Product")
        verbose_name_plural = _("Products")

    def get_url_path(self):
        try:
            return reverse("product_detail", kwargs={"slug": self.slug})
        except NoReverseMatch:
            return ""

    def __str__(self):
        return self.title

class ProductPhoto(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    photo = models.ImageField(_("photo"), 
     upload_to=product_photo_upload_to)

    class Meta:
        verbose_name = _("Photo")
        verbose_name_plural = _("Photos")

    def __str__(self):
        return self.photo.name
```

# 怎么做。。。

在此配方中，我们将为`Product`模型创建一个简单的管理，将`ProductPhoto`模型的实例作为内联线连接到产品。

在`list_display`属性中，我们将包括模型 admin 的`first_photo()`方法，该方法将用于显示多对一关系中的第一张照片。那么，让我们开始：

1.  让我们创建一个包含以下内容的`admin.py`文件：

```py
# myproject/apps/products/admin.py from django.contrib import admin
from django.template.loader import render_to_string
from django.utils.html import mark_safe
from django.utils.translation import ugettext_lazy as _

from .models import Product, ProductPhoto

class ProductPhotoInline(admin.StackedInline):
    model = ProductPhoto
    extra = 0
    fields = ["photo"]
```

2.  然后，在同一个文件中，让我们添加产品的管理：

```py
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ["first_photo", "title", "has_description", 
     "price"]
    list_display_links = ["first_photo", "title"]
    list_editable = ["price"]

    fieldsets = ((_("Product"), {"fields": ("title", "slug", 
     "description", "price")}),)
    prepopulated_fields = {"slug": ("title",)}
    inlines = [ProductPhotoInline]

def first_photo(self, obj):
        project_photos = obj.productphoto_set.all()[:1]
         if project_photos.count() > 0:
 photo_preview = render_to_string(
           "admin/products/includes/photo-preview.html",
             {"photo": project_photos[0], "product": obj},
            )
           return mark_safe(photo_preview)
         return ""

    first_photo.short_description = _("Preview")

def has_description(self, obj):
return bool(obj.description)

    has_description.short_description = _("Has description?")
    has_description.admin_order_field = "description"
    has_description.boolean = True
```

3.  现在，让我们创建用于生成`photo-preview`的模板，如下所示：

```py
{# admin/products/includes/photo-preview.html #} {% load imagekit %}
{% thumbnail "120x120" photo.photo -- alt=
 "{{ product.title }} preview" %}
```

# 它是如何工作的。。。

如果添加一些带有照片的产品，然后在浏览器中查看产品管理列表，它将类似于以下屏幕截图：

![](img/d14311ca-f563-4422-bb00-8eb990292a4f.png)

`list_display`属性通常用于定义字段，以便在管理列表视图中显示这些字段；例如，标题和价格是`Product`模型的字段。但是，除了正常的字段名，`list_display`属性还接受以下内容：

*   一个函数或另一个可调用函数
*   模型管理类的属性的名称
*   模型属性的名称

在`list_display`中使用 callables 时，每个 callables 将获得作为第一个参数传递的模型实例。因此，在我们的示例中，我们在模型管理类中定义了`get_photo()`方法，该方法将`Product`实例接收为`obj`。该方法尝试从多对一关系中获取第一个`ProductPhoto`对象，如果它存在，则返回从包含模板生成的带有`<img>`标记的 HTML。通过设置`list_display_links`，我们将照片和标题链接到`Product`模型的管理员变更表。

您可以为`list_display`中使用的可调用项设置多个属性：

*   callable 的`short_description`属性定义列顶部显示的标题。
*   默认情况下，callables 返回的值在管理中不可排序，但是可以设置`admin_order_field`属性来定义我们应该根据哪个数据库字段对生成的列进行排序。（可选）可以在字段前面加连字符，以指示反向排序顺序。
*   通过设置`boolean = True`，可以显示`True`或`False`值的图标。

最后，如果我们将价格字段包含在`list_editable`设置中，则可以对其进行编辑。因为现在有可编辑的字段，所以底部会出现一个保存按钮，这样我们就可以保存整个产品列表。

# 另见

*   在[第 2 章](02.html)*中*使用 URL 相关方法*创建模型 mixin，模型和数据库结构*
*   *创建管理操作*配方
*   *开发变更列表过滤器*配方

# 创建可排序的内联线

您需要按创建日期、发生日期或字母顺序对数据库中的大多数模型进行排序。但有时，用户必须能够以自定义排序顺序显示项目。这适用于类别、图像库、策划列表和类似案例。在此配方中，我们将向您展示如何使用`django-ordered-model`在管理中允许自定义排序。

# 准备

在这个配方中，我们将以我们在上一个配方中定义的`products`应用程序为基础。请按照以下步骤开始：

1.  让我们在虚拟环境中安装`django-ordered-model`：

```py
(env)$ pip install django-ordered-model 
```

2.  在设置中将`ordered_model`添加到`INSTALLED_APPS`。
3.  然后，从前面定义的`products`app 中修改`ProductPhoto`模型，如下所示：

```py
# myproject/apps/products/models.py from django.db import models
from django.utils.translation import ugettext_lazy as _

from ordered_model.models import OrderedModel

# …

class ProductPhoto(OrderedModel):
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    photo = models.ImageField(_("photo"), 
     upload_to=product_photo_upload_to)

order_with_respect_to = "product" 
    class Meta(OrderedModel.Meta):
        verbose_name = _("Photo")
        verbose_name_plural = _("Photos")

def __str__(self):
return self.photo.name
```

`OrderedModel`类引入了一个`order`字段。进行并运行迁移，将`ProductPhoto`的新`order`字段添加到数据库中。

# 怎么做。。。

要设置可排序的产品照片，我们需要修改`products`应用程序的模型管理。让我们开始：

1.  在管理文件中修改`ProductPhotoInline`，如下所示：

```py
# myproject/apps/products/admin.py from django.contrib import admin
from django.template.loader import render_to_string
from django.utils.html import mark_safe
from django.utils.translation import ugettext_lazy as _
from ordered_model.admin import OrderedTabularInline, OrderedInlineModelAdminMixin

from .models import Product, ProductPhoto

class ProductPhotoInline(OrderedTabularInline):
    model = ProductPhoto
    extra = 0
    fields = ("photo_preview", "photo", "order", 
    "move_up_down_links")
    readonly_fields = ("photo_preview", "order", 
    "move_up_down_links")
    ordering = ("order",)

    def get_photo_preview(self, obj):
 photo_preview = render_to_string(
 "admin/products/includes/photo-preview.html",
 {"photo": obj, "product": obj.product},
 )
 return mark_safe(photo_preview)

 get_photo_preview.short_description = _("Preview")
```

2.  然后，修改`ProductAdmin`如下：

```py
@admin.register(Product)
class ProductAdmin(OrderedInlineModelAdminMixin, admin.ModelAdmin):
    # …
```

# 它是如何工作的。。。

如果打开更改产品表单，您将看到如下内容：

![](img/11c19c3c-8124-4f8d-b852-5c08271d85fa.png)

在模型中，我们设置了`order_with_respect_to`属性，以确保每个产品的订购都是独立的，而不是通常只订购整个产品照片列表。

在 Django administration 中，产品照片可以按照产品详细信息本身作为表格内联进行编辑。在第一列中，我们有一个照片预览。我们使用之前配方中使用的相同`photo-preview.html`模板生成它。在第二列中，有一个用于更改照片的字段。然后，ORDER 字段有一个列，后面是一个带有箭头按钮的列，这样我们就可以在旁边手动重新排序照片。箭头按钮来自`move_up_down_links`方法。最后，有一个带有复选框的列，这样我们就可以删除内联。

`readonly_fields`属性告诉 Django 某些字段或方法将仅用于读取。如果您想使用另一种方法在变更表单中显示某些内容，则必须将这些方法放入`readonly_fields`列表中。在我们的例子中，`get_photo_preview`和`move_up_down_links`就是这样的方法。

`move_up_down_links`是在`OrderedTabularInline`中定义的，我们正在扩展它，而不是`admin.StackedInline`或`admin.TabularInline`。这将渲染箭头按钮，以便它们在产品照片中切换位置。

# 另见

*   变更列表页面配方上的*定制栏*
*   *创建管理操作*配方
*   *开发变更列表过滤器*配方

# 创建管理操作

Django 管理系统提供了我们可以为列表中的选定项执行的操作。默认情况下，提供一个操作，用于删除选定实例。在此配方中，我们将为`Product`模型的列表创建一个附加操作，这将允许管理员将所选产品导出到 Excel 电子表格。

# 准备

我们将从前面的食谱中创建的`products`应用程序开始。确保在虚拟环境中安装了`openpyxl`模块，以便创建 Excel 电子表格，如下所示：

```py
(env)$ pip install openpyxl
```

# 怎么做。。。

管理操作是具有三个参数的函数，如下所示：

*   当前`ModelAdmin`值
*   当前`HttpRequest`值
*   `QuerySet`值，包含所选项目

执行以下步骤以创建自定义管理操作以导出电子表格：

1.  在`products`app 的`admin.py`文件中为电子表格列配置创建`ColumnConfig`类，如下所示：

```py
# myproject/apps/products/admin.py from openpyxl import Workbook
from openpyxl.styles import Alignment, NamedStyle, builtins
from openpyxl.styles.numbers import FORMAT_NUMBER
from openpyxl.writer.excel import save_virtual_workbook

from django.http.response import HttpResponse
from django.utils.translation import ugettext_lazy as _
from ordered_model.admin import OrderedTabularInline, OrderedInlineModelAdminMixin

# other imports…

class ColumnConfig:
    def __init__(
            self,
            heading,
            width=None,
            heading_style="Headline 1",
            style="Normal Wrapped",
            number_format=None,
         ):
        self.heading = heading
        self.width = width
        self.heading_style = heading_style
        self.style = style
        self.number_format = number_format
```

2.  然后，在同一文件中创建`export_xlsx()`函数：

```py
def export_xlsx(modeladmin, request, queryset):
    wb = Workbook()
    ws = wb.active
    ws.title = "Products"

    number_alignment = Alignment(horizontal="right")
    wb.add_named_style(
        NamedStyle(
            "Identifier", alignment=number_alignment, 
             number_format=FORMAT_NUMBER
        )
    )
    wb.add_named_style(
        NamedStyle("Normal Wrapped", 
         alignment=Alignment(wrap_text=True))
    )

    column_config = {
        "A": ColumnConfig("ID", width=10, style="Identifier"),
        "B": ColumnConfig("Title", width=30),
        "C": ColumnConfig("Description", width=60),
        "D": ColumnConfig("Price", width=15, style="Currency", 
             number_format="#,##0.00 €"),
        "E": ColumnConfig("Preview", width=100, style="Hyperlink"),
    }

    # Set up column widths, header values and styles
    for col, conf in column_config.items():
        ws.column_dimensions[col].width = conf.width

        column = ws[f"{col}1"]
        column.value = conf.heading
        column.style = conf.heading_style

    # Add products
    for obj in queryset.order_by("pk"):
        project_photos = obj.productphoto_set.all()[:1]
        url = ""
        if project_photos:
            url = project_photos[0].photo.url

        data = [obj.pk, obj.title, obj.description, obj.price, url]
        ws.append(data)

        row = ws.max_row
        for row_cells in ws.iter_cols(min_row=row, max_row=row):
            for cell in row_cells:
                conf = column_config[cell.column_letter]
                cell.style = conf.style
                if conf.number_format:
                    cell.number_format = conf.number_format

    mimetype = "application/vnd.openxmlformats-
     officedocument.spreadsheetml.sheet"
    charset = "utf-8"
    response = HttpResponse(
        content=save_virtual_workbook(wb),
        content_type=f"{mimetype}; charset={charset}",
        charset=charset,
    )
    response["Content-Disposition"] = "attachment; 
     filename=products.xlsx"
    return response

export_xlsx.short_description = _("Export XLSX")
```

3.  然后，将`actions`设置添加到`ProductAdmin`，如下所示：

```py
@admin.register(Product)
class ProductAdmin(OrderedInlineModelAdminMixin, admin.ModelAdmin):
    # …
 actions = [export_xlsx]
    # …
```

# 它是如何工作的。。。

如果查看浏览器中的“产品管理列表”页面，您将看到一个名为 Export XLSX 的新操作，以及默认的“删除选定产品”操作，如以下屏幕截图所示：

![](img/ae598c42-d15a-4aef-a26d-1c24e63d4537.png)

我们使用`openpyxl`Python 模块创建与 Excel 和其他电子表格软件兼容的 OpenOffice XML 文件。

首先，创建工作簿并选择活动工作表，我们将其标题设置为`Products`。由于我们希望在整个工作表中使用通用样式，因此将这些样式设置为命名样式，以便根据需要按名称应用于每个单元格。这些样式、列标题和列宽存储为`Config`对象，并且`column_config`字典将列字母键映射到对象。然后对其进行迭代以设置标题和列宽。

我们使用表单的`append()`方法添加`QuerySet`中每个选定产品的内容，按 ID 排序，包括产品的第一张照片的 URL，以便在有照片时使用。然后，通过迭代刚刚添加的行中的每个单元格，再次引用`column_config`以一致地应用样式，对产品数据进行单独样式设置。

默认情况下，管理员操作对`QuerySet`执行一些操作，并将管理员重定向回更改列表页面。但是，对于更复杂的操作，`HttpResponse`可以返回。`export_xlsx()`功能将工作簿的虚拟副本保存到`HttpResponse`，内容类型和字符集与**Office Open XML**（**OOXML**电子表格相适应。使用`Content-Disposition`头，我们设置响应，以便将其作为`products.xlsx`文件下载。生成的工作表可以在 Open Office 中打开，其外观类似于以下内容：

![](img/85faa318-6a66-4cc2-9cb2-14950f5e4f76.png)

# 另见

*   变更列表页面配方上的*定制栏*
*   *开发变更列表过滤器*配方

*   [第 9 章](09.html)*数据导入导出*

# 开发变更列表过滤器

如果希望管理员能够按日期、关系或字段选择筛选更改列表，则必须使用管理员模型的`list_filter`属性。此外，还可以定制过滤器。在这个配方中，我们将添加一个过滤器，允许我们根据附在产品上的照片数量来选择产品。

# 准备

让我们从我们在前面的食谱中创建的`products`应用程序开始。

# 怎么做。。。

执行以下步骤：

1.  在`admin.py`文件中，创建一个扩展自`SimpleListFilter`的`PhotoFilter`类，如下所示：

```py
# myproject/apps/products/admin.py
from django.contrib import admin
from django.db import models
from django.utils.translation import ugettext_lazy as _

# other imports…

ZERO = "zero"
ONE = "one"
MANY = "many"

class PhotoFilter(admin.SimpleListFilter):
    # Human-readable title which will be displayed in the
    # right admin sidebar just above the filter options.
    title = _("photos")

    # Parameter for the filter that will be used in the
    # URL query.
    parameter_name = "photos"

    def lookups(self, request, model_admin):
        """
        Returns a list of tuples, akin to the values given for
        model field choices. The first element in each tuple is the
        coded value for the option that will appear in the URL
        query. The second element is the human-readable name for
        the option that will appear in the right sidebar.
        """
        return (
            (ZERO, _("Has no photos")),
            (ONE, _("Has one photo")),
            (MANY, _("Has more than one photo")),
        )

    def queryset(self, request, queryset):
        """
        Returns the filtered queryset based on the value
        provided in the query string and retrievable via
        `self.value()`.
        """
        qs = queryset.annotate(num_photos=
         models.Count("productphoto"))

        if self.value() == ZERO:
            qs = qs.filter(num_photos=0)
        elif self.value() == ONE:
            qs = qs.filter(num_photos=1)
        elif self.value() == MANY:
            qs = qs.filter(num_photos__gte=2)
        return qs
```

2.  然后，在`ProductAdmin`中添加一个列表过滤器，如下代码所示：

```py
@admin.register(Product)
class ProductAdmin(OrderedInlineModelAdminMixin, admin.ModelAdmin):
    # …
    list_filter = [PhotoFilter]
    # …
```

# 它是如何工作的。。。

基于我们刚刚创建的自定义字段的列表过滤器将显示在产品列表的侧栏中，如下所示：

![](img/ca4b4b04-eecf-40ee-b6c2-b4f3f61129ec.png)

`PhotoFilter`类具有可翻译的标题和查询参数名称作为属性。它还有两种方法，如下所示：

*   `lookups()`方法，定义过滤器的选择
*   `queryset()`方法，定义选择特定值时如何过滤`QuerySet`对象

在`lookups()`方法中，我们定义了三种选择，如下所示：

*   没有照片
*   有一张照片
*   附件中有多张照片

在`queryset()`方法中，我们使用`QuerySet`的`annotate()`方法来选择每个产品的照片数量。然后根据所选选项过滤此计数。

要了解更多关于聚合函数的信息，如`annotate()`，请参阅[上的 Django 官方文档 https://docs.djangoproject.com/en/3.0/topics/db/aggregation/](https://docs.djangoproject.com/en/3.0/topics/db/aggregation/) 。

# 另见

*   变更列表页面配方上的*定制栏*
*   *创建管理操作*配方
*   *创建自定义账户应用*配方

# 更改第三方应用的应用标签

Django 框架有很多第三方应用程序，可以在项目中使用。您可以在[浏览和比较其中的大部分内容 https://djangopackages.org/](https://djangopackages.org/) 。在本食谱中，我们将向您展示如何在管理中重命名`python-social-auth`应用程序的标签。类似地，您可以更改任何 Django 第三方应用程序的标签。

# 准备

按照[中的说明操作 https://python-social-auth.readthedocs.io/en/latest/configuration/django.html](https://python-social-auth.readthedocs.io/en/latest/configuration/django.html) 将 Python Social Auth 安装到您的项目中。Python Social Auth 允许用户使用社交网络帐户或其开放 ID 登录。完成此操作后，管理的索引页将如下所示：

![](img/828e2e92-06ce-4cb5-b807-1216415cb22a.png)

# 怎么做。。。

首先，将 PYTHON 社交身份验证标签更改为更加用户友好的标签，例如社交身份验证。现在，按照以下步骤操作：

1.  创建一个名为`accounts`的应用程序。在`apps.py`文件中添加以下内容：

```py
# myproject/apps/accounts/apps.py
from django.apps import AppConfig
from django.utils.translation import ugettext_lazy as _

class AccountsConfig(AppConfig):
    name = "myproject.apps.accounts"
    verbose_name = _("Accounts")

    def ready(self):
        pass

class SocialDjangoConfig(AppConfig):
 name = "social_django"
    verbose_name = _("Social Authentication")
```

2.  设置 Python Social Auth 的步骤之一是将`"social_django"`应用程序添加到`INSTALLED_APPS`。现在，将该应用程序替换为`"myproject.apps.accounts.apps.SocialDjangoConfig"`：

```py
# myproject/settings/_base.py # …
INSTALLED_APPS = [
    # …
    #"social_django",
    "myproject.apps.accounts.apps.SocialDjangoConfig",
    # …
]
```

# 它是如何工作的。。。

如果您查看管理的索引页，您将看到如下内容：

![](img/ed96a18a-c5ab-44ed-b35f-5b191f230566.png)

`INSTALLED_APPS`设置接受应用程序路径或应用程序配置路径。我们可以传递应用程序配置，而不是默认的应用程序路径。在那里，我们更改应用程序的详细名称，甚至可以应用一些信号处理程序或对应用程序进行其他初始设置。

# 另见

*   *创建自定义账户应用*配方
*   *获取用户坟墓*配方

# 创建自定义帐户应用程序

Django 附带了一个用于身份验证的贡献`django.contrib.auth`应用程序。例如，它允许用户使用用户名和密码登录，以便能够使用管理功能。此应用程序的设计目的是让您可以使用自己的功能对其进行扩展。在此配方中，我们将创建自定义用户和角色模型，并为其设置管理。您可以通过电子邮件和密码登录，而不是使用用户名和密码。

# 准备

创建一个`accounts`应用程序，并将此应用程序置于`INSTALLED_APPS`下，设置如下：

```py
# myproject/apps/_base.py
INSTALLED_APPS = [
   # …
   "myproject.apps.accounts",
]
```

# 怎么做。。。

按照以下步骤覆盖用户和组模型：

1.  在`accounts`应用中创建`models.py`，内容如下：

```py
# myproject/apps/accounts/models.py import uuid

from django.contrib.auth.base_user import BaseUserManager
from django.db import models
from django.contrib.auth.models import AbstractUser, Group
from django.utils.translation import ugettext_lazy as _

class Role(Group):
    class Meta:
        proxy = True
        verbose_name = _("Role")
        verbose_name_plural = _("Roles")

    def __str__(self):
        return self.name

class UserManager(BaseUserManager):
    def create_user(self, username="", email="", password="", 
     **extra_fields):
        if not email:
            raise ValueError("Enter an email address")
        email = self.normalize_email(email)
        user = self.model(username=username, email=email, 
         **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, username="", email="", password=""):
        user = self.create_user(email=email, password=password, 
         username=username)
        user.is_superuser = True
        user.is_staff = True
        user.save(using=self._db)
        return user

class User(AbstractUser):
    uuid = models.UUIDField(primary_key=True, default=None, 
     editable=False)
    # change username to non-editable non-required field
    username = models.CharField(
        _("username"), max_length=150, editable=False, blank=True
    )
    # change email to unique and required field
    email = models.EmailField(_("email address"), unique=True)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []

    objects = UserManager()

    def save(self, *args, **kwargs):
        if self.pk is None:
            self.pk = uuid.uuid4()
        super().save(*args, **kwargs)
```

2.  在`accounts`应用程序中创建`admin.py`文件，其中包含`User`型号的管理配置：

```py
# myproject/apps/accounts/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin, Group, GroupAdmin
from django.urls import reverse
from django.contrib.contenttypes.models import ContentType
from django.http import HttpResponse
from django.shortcuts import get_object_or_404, redirect
from django.utils.encoding import force_bytes
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _
from django.contrib.auth.forms import UserCreationForm

from .helpers import download_avatar
from .models import User, Role

class MyUserCreationForm(UserCreationForm):
    def save(self, commit=True):
        user = super().save(commit=False)
        user.username = user.email
        user.set_password(self.cleaned_data["password1"])
        if commit:
            user.save()
        return user

@admin.register(User)
class MyUserAdmin(UserAdmin):
    save_on_top = True
    list_display = [
        "get_full_name",
        "is_active",
        "is_staff",
        "is_superuser",
    ]
    list_display_links = [
        "get_full_name",
    ]
    search_fields = ["email", "first_name", "last_name", "id", 
     "username"]
    ordering = ["-is_superuser", "-is_staff", "last_name", 
     "first_name"]

    fieldsets = [
        (None, {"fields": ("email", "password")}),
        (_("Personal info"), {"fields": ("first_name", 
         "last_name")}),
        (
            _("Permissions"),
            {
                "fields": (
                    "is_active",
                    "is_staff",
                    "is_superuser",
                    "groups",
                    "user_permissions",
                )
            },
        ),
        (_("Important dates"), {"fields": ("last_login", 
         "date_joined")}),
    ]
    add_fieldsets = (
        (None, {"classes": ("wide",), "fields": ("email", 
         "password1", "password2")}),
    )
    add_form = MyUserCreationForm

    def get_full_name(self, obj):
        return obj.get_full_name()

    get_full_name.short_description = _("Full name")

```

3.  在同一文件中，为`Role`型号添加配置：

```py
admin.site.unregister(Group)

@admin.register(Role)
class MyRoleAdmin(GroupAdmin):
    list_display = ("__str__", "display_users")
    save_on_top = True

    def display_users(self, obj):
        links = []
        for user in obj.user_set.all():
            ct = ContentType.objects.get_for_model(user)
            url = reverse(
                "admin:{}_{}_change".format(ct.app_label, 
                  ct.model), args=(user.pk,)
            )
            links.append(
                """<a href="{}" target="_blank">{}</a>""".format(
                    url,
                    user.get_full_name() or user.username,
                )
            )
        return mark_safe(u"<br />".join(links))

    display_users.short_description = _("Users")
```

# 它是如何工作的。。。

默认用户管理列表类似于以下屏幕截图：

![](img/0f12f73f-ee33-4eef-995b-e509b0d8d735.png)

默认组管理列表类似于以下屏幕截图：

![](img/a142a4a5-3f57-40b6-9387-f275500e616d.png)

在此配方中，我们创建了两个模型：

*   `Role`模型，它是`django.contrib.auth`应用程序中`Group`模型的代理。创建`Role`模型是为了将`Group`的详细名称重命名为`Role`。
*   `User`模型，它从`django.contrib.auth`扩展了与`User`模型相同的抽象`AbstractUser`类。创建`User`模型是为了将主键替换为`UUIDField`，并允许我们通过电子邮件和密码而不是用户名和密码登录。

管理员类`MyUserAdmin`和`MyRoleAdmin`扩展了贡献的`UserAdmin`和`GroupAdmin`类，并覆盖了一些属性。然后，我们注销了`User`和`Group`模型的现有管理类，并注册了新的、修改的管理类。

以下屏幕截图显示了用户管理的外观：

![](img/6433a0e7-b052-45b9-be81-5a8f7b747266.png)

修改后的用户管理设置在列表视图中显示比默认设置更多的字段、其他筛选器和排序选项，以及编辑表单顶部的提交按钮。

在新组管理设置的更改列表中，我们将显示已分配到特定组的用户。在浏览器中，这将类似于以下屏幕截图：

![](img/516c43fe-6b6d-47e7-879e-989fe89765cf.png)

# 另见

*   变更列表页面配方上的*定制栏*
*   *将地图插入变更表单*配方

# 获取用户 Gravatar

现在我们已经开始使用自定义的`User`模型进行身份验证，我们可以通过添加更多有用的字段来进一步增强它。在此配方中，我们将添加一个`avatar`字段，并能够从 Gravatar 服务（[中）下载用户的化身 https://en.gravatar.com/](https://en.gravatar.com/) ）。该服务的用户可以上传化身并将其分配到电子邮件中。通过这样做，不同的评论系统和社交平台将能够根据用户电子邮件的哈希显示来自 Gravatar 的化身。

# 准备

让我们继续使用我们在前面的食谱中创建的`accounts`应用程序。

# 怎么做。。。

按照以下步骤增强`accounts`应用程序中的`User`模型：

1.  将`avatar`字段和`django-imagekit`缩略图规范添加到`User`模型中：

```py
# myproject/apps/accounts/models.py import os

from imagekit.models import ImageSpecField
from pilkit.processors import ResizeToFill
from django.utils import timezone

# …

def upload_to(instance, filename):
 now = timezone.now()
 filename_base, filename_ext = os.path.splitext(filename)
 return "users/{user_id}/{filename}{ext}".format(
 user_id=instance.pk,
 filename=now.strftime("%Y%m%d%H%M%S"),
 ext=filename_ext.lower(),
 )

class User(AbstractUser):
    # …

 avatar = models.ImageField(_("Avatar"), upload_to=upload_to, 
     blank=True)
 avatar_thumbnail = ImageSpecField(
 source="avatar",
 processors=[ResizeToFill(60, 60)],
 format="JPEG",
 options={"quality": 100},
 )

    # …
```

2.  添加一些方法以下载并向`MyUserAdmin`类显示 Gravatar：

```py
# myprojects/apps/accounts/admin.py from django.contrib import admin
from django.contrib.auth.admin import UserAdmin, Group, GroupAdmin
from django.urls import reverse
from django.contrib.contenttypes.models import ContentType
from django.http import HttpResponse
from django.shortcuts import get_object_or_404
from django.utils.encoding import force_bytes
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _
from django.contrib.auth.forms import UserCreationForm

from .helpers import download_avatar
from .models import User, Role

class MyUserCreationForm(UserCreationForm):
    def save(self, commit=True):
        user = super().save(commit=False)
        user.username = user.email
        user.set_password(self.cleaned_data["password1"])
        if commit:
            user.save()
        return user

@admin.register(User)
class MyUserAdmin(UserAdmin):
    save_on_top = True
    list_display = [
        "get_avatar",
        "get_full_name",
        "download_gravatar",
        "is_active",
        "is_staff",
        "is_superuser",
    ]
    list_display_links = [
        "get_avatar",
        "get_full_name",
    ]
    search_fields = ["email", "first_name", "last_name", "id", 
     "username"]
    ordering = ["-is_superuser", "-is_staff", "last_name", 
     "first_name"]

    fieldsets = [
        (None, {"fields": ("email", "password")}),
        (_("Personal info"), {"fields": ("first_name", 
         "last_name")}),
        (
            _("Permissions"),
            {
                "fields": (
                    "is_active",
                    "is_staff",
                    "is_superuser",
                    "groups",
                    "user_permissions",
                )
            },
        ),
 (_("Avatar"), {"fields": ("avatar",)}),
        (_("Important dates"), {"fields": ("last_login", 
         "date_joined")}),
    ]
    add_fieldsets = (
        (None, {"classes": ("wide",), "fields": ("email", 
         "password1", "password2")}),
    )
    add_form = MyUserCreationForm

    def get_full_name(self, obj):
        return obj.get_full_name()

    get_full_name.short_description = _("Full name")

    def get_avatar(self, obj):
        from django.template.loader import render_to_string
        html = render_to_string("admin/accounts
         /includes/avatar.html", context={
            "obj": obj
        })
        return mark_safe(html)

    get_avatar.short_description = _("Avatar")

    def download_gravatar(self, obj):
        from django.template.loader import render_to_string
        info = self.model._meta.app_label, 
         self.model._meta.model_name
        gravatar_url = reverse("admin:%s_%s_download_gravatar" % 
         info, args=[obj.pk])
        html = render_to_string("admin/accounts
         /includes/download_gravatar.html", context={
            "url": gravatar_url
        })
        return mark_safe(html)

    download_gravatar.short_description = _("Gravatar")

    def get_urls(self):
        from functools import update_wrapper
        from django.conf.urls import url

        def wrap(view):
            def wrapper(*args, **kwargs):
                return self.admin_site.admin_view(view)(*args, 
                 **kwargs)

            wrapper.model_admin = self
            return update_wrapper(wrapper, view)

        info = self.model._meta.app_label, 
         self.model._meta.model_name

        urlpatterns = [
            url(
                r"^(.+)/download-gravatar/$",
                wrap(self.download_gravatar_view),
                name="%s_%s_download_gravatar" % info,
            )
        ] + super().get_urls()

        return urlpatterns

    def download_gravatar_view(self, request, object_id):
        if request.method != "POST":
            return HttpResponse(
                "{} method not allowed.".format(request.method), 
                 status=405
            )
        from .models import User

        user = get_object_or_404(User, pk=object_id)
        import hashlib

        m = hashlib.md5()
        m.update(force_bytes(user.email))
        md5_hash = m.hexdigest()
        # d=404 ensures that 404 error is raised if gravatar is not 
        # found instead of returning default placeholder
        url = "https://www.gravatar.com/avatar
         /{md5_hash}?s=800&d=404".format(
            md5_hash=md5_hash
        )
        download_avatar(object_id, url)
        return HttpResponse("Gravatar downloaded.", status=200)
```

3.  在`accounts`app 中添加一个`helpers.py`文件，内容如下：

```py
# myproject/apps/accounts/helpers.py 
def download_avatar(user_id, image_url):
    import tempfile
    import requests
    from django.contrib.auth import get_user_model
    from django.core.files import File

    response = requests.get(image_url, allow_redirects=True, 
     stream=True)
    user = get_user_model().objects.get(pk=user_id)

    if user.avatar:  # delete the old avatar
        user.avatar.delete()

    if response.status_code != requests.codes.ok:
        user.save()
        return

    file_name = image_url.split("/")[-1]

    image_file = tempfile.NamedTemporaryFile()

    # Read the streamed image in sections
    for block in response.iter_content(1024 * 8):
        # If no more file then stop
        if not block:
            break
        # Write image block to temporary file
        image_file.write(block)

    user.avatar.save(file_name, File(image_file))
    user.save()
```

4.  在管理文件中为化身创建模板：

```py
{# admin/accounts/includes/avatar.html #}
{% if obj.avatar %}
    <img src="{{ obj.avatar_thumbnail.url }}" alt="" 
     width="30" height="30" />
{% endif %}
```

5.  创建模板供`button`下载`Gravatar`：

```py
{# admin/accounts/includes/download_gravatar.html #}
{% load i18n %}
<button type="button" data-url="{{ url }}" class="button js_download_gravatar download-gravatar">
    {% trans "Get Gravatar" %}
</button>
```

6.  最后，使用 JavaScript 为用户更改列表管理创建一个模板，以处理鼠标单击 Get Gravatar 按钮：

```py
{# admin/accounts/user/change_list.html #}
{% extends "admin/change_list.html" %}
{% load static %}

{% block footer %}
{{ block.super }}
<style nonce="{{ request.csp_nonce }}">
.button.download-gravatar {
    padding: 2px 10px;
}
</style>
<script nonce="{{ request.csp_nonce }}">
django.jQuery(function($) {
    $('.js_download_gravatar').on('click', function(e) {
        e.preventDefault();
        $.ajax({
            url: $(this).data('url'),
            cache: 'false',
            dataType: 'json',
            type: 'POST',
            data: {},
            beforeSend: function(xhr) {
                xhr.setRequestHeader('X-CSRFToken', 
                 '{{ csrf_token }}');
            }
        }).then(function(data) {
            console.log('Gravatar downloaded.');
            document.location.reload(true);
        }, function(data) {
            console.log('There were problems downloading the 
             Gravatar.');
            document.location.reload(true);
        });
    })
})

</script>
{% endblock %}
```

# 它是如何工作的。。。

如果您现在查看用户更改列表管理，您将看到如下内容：

![](img/ddc67c53-0a92-4f43-8864-7722138222d9.png)

这些列从用户的头像开始，然后是全名，然后是获取头像的按钮。当用户单击 Get Gravatar 按钮时，JavaScript`onclick`事件处理程序向`download_gravatar_view`发出`POST`请求。此视图为用户的 Gravatar 创建一个 URL，该 URL 依赖于用户电子邮件的 MD5 散列，然后调用帮助函数为用户下载图像并将其链接到`avatar`字段。

# 还有更多。。。

Gravatar 图像非常小，下载速度相对较快。如果您从其他服务下载较大的图像，可以使用芹菜或休伊任务队列在后台检索图像。您可以在[了解芹菜 https://docs.celeryproject.org/en/latest/django/first-steps-with-django.html](https://docs.celeryproject.org/en/latest/django/first-steps-with-django.html) 、关于休伊的[https://huey.readthedocs.io/en/0.4.9/django.html](https://huey.readthedocs.io/en/0.4.9/django.html) 。

# 另见

*   *更改第三方 app*配方的 app 标签
*   *创建自定义账户应用*配方

# 将地图插入到变更表单中

谷歌地图提供了一个 JavaScript API，我们可以使用它将地图插入我们的网站。在这个配方中，我们将创建一个带有`Location`模型的`locations`应用程序，并扩展变更表单的模板，以便添加一个地图，管理员可以在其中找到并标记位置的地理坐标。

# 准备

注册 Google Maps API 密钥并将其公开给模板，就像我们在[第 4 章](04.html)*中的*使用 HTML5 数据属性*配方中所做的一样，模板和 JavaScript*。注意，对于这个配方，在 Google 云平台控制台中，您需要激活 Maps JavaScript API 和地理编码 API。要使这些 API 发挥作用，还需要设置计费数据。

我们将继续创建一个`locations`应用程序：

1.  将应用程序置于设置中的`INSTALLED_APPS`下：

```py
# myproject/settings/_base.py
INSTALLED_APPS = [
    # …
    "myproject.apps.locations",
]
```

2.  在那里创建一个带有名称、描述、地址、地理坐标和图片的`Location`模型，如下所示：

```py
# myproject/apps/locations/models.py
import os
import uuid
from collections import namedtuple

from django.contrib.gis.db import models
from django.urls import reverse
from django.conf import settings
from django.utils.translation import gettext_lazy as _
from django.utils.timezone import now as timezone_now

from myproject.apps.core.models import CreationModificationDateBase, UrlBase

COUNTRY_CHOICES = getattr(settings, "COUNTRY_CHOICES", [])

Geoposition = namedtuple("Geoposition", ["longitude", "latitude"])

def upload_to(instance, filename):
    now = timezone_now()
    base, extension = os.path.splitext(filename)
    extension = extension.lower()
    return f"locations/{now:%Y/%m}/{instance.pk}{extension}"

class Location(CreationModificationDateBase, UrlBase):
    uuid = models.UUIDField(primary_key=True, default=None, 
     editable=False)
    name = models.CharField(_("Name"), max_length=200)
    description = models.TextField(_("Description"))
    street_address = models.CharField(_("Street address"), 
     max_length=255, blank=True)
    street_address2 = models.CharField(
        _("Street address (2nd line)"), max_length=255, blank=True
    )
    postal_code = models.CharField(_("Postal code"), 
     max_length=255, blank=True)
    city = models.CharField(_("City"), max_length=255, blank=True)
    country = models.CharField(
        _("Country"), choices=COUNTRY_CHOICES, max_length=255, 
         blank=True
    )
    geoposition = models.PointField(blank=True, null=True)
    picture = models.ImageField(_("Picture"), upload_to=upload_to)

    class Meta:
        verbose_name = _("Location")
        verbose_name_plural = _("Locations")

    def __str__(self):
        return self.name

    def get_url_path(self):
        return reverse("locations:location_detail", 
         kwargs={"pk": self.pk})

    def save(self, *args, **kwargs):
        if self.pk is None:
            self.pk = uuid.uuid4()
        super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        if self.picture:
            self.picture.delete()
        super().delete(*args, **kwargs)

    def get_geoposition(self):
        if not self.geoposition:
            return None
        return Geoposition(self.geoposition.coords[0], 
         self.geoposition.coords[1])

    def set_geoposition(self, longitude, latitude):
        from django.contrib.gis.geos import Point
        self.geoposition = Point(longitude, latitude, srid=4326)
```

3.  接下来，我们需要为 PostgreSQL 数据库安装 PostGIS 扩展。最简单的方法是运行`dbshell`管理命令并执行以下命令：

```py
> CREATE EXTENSION postgis;
```

4.  现在，为具有地理位置的模型创建默认管理（我们将在*如何执行…*部分中对此进行更改）：

```py
# myproject/apps/locations/admin.py
from django.contrib.gis import admin
from .models import Location

@admin.register(Location)
class LocationAdmin(admin.OSMGeoAdmin):
    pass
```

贡献的`gis`模块中地理`Point`字段的默认 Django 管理使用`Leaflet.js`JavaScript 映射库。这些瓷砖是从开放的街道地图上获得的，行政部门将如下所示：

![](img/2a5e6034-e6a8-4277-b892-a9a672aa341b.png)

请注意，在默认设置中，您无法手动输入经度和纬度，也无法根据地址信息对地理位置进行地理编码。我们将在这个配方中实现这一点。

# 怎么做。。。

`Location`模型的管理将从多个文件中合并。执行以下步骤来创建它：

1.  让我们为`Location`模型创建管理配置。请注意，我们还创建了一个自定义模型表单，以创建单独的`latitude`和`longitude`字段：

```py
# myproject/apps/locations/admin.py from django.contrib import admin
from django import forms
from django.conf import settings
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

from .models import Location

LATITUDE_DEFINITION = _(
    "Latitude (Lat.) is the angle between any point and the "
    "equator (north pole is at 90°; south pole is at -90°)."
)

LONGITUDE_DEFINITION = _(
    "Longitude (Long.) is the angle east or west of a point "
    "on Earth at Greenwich (UK), which is the international "
    "zero-longitude point (longitude = 0°). The anti-meridian "
    "of Greenwich (the opposite side of the planet) is both "
    "180° (to the east) and -180° (to the west)."
)

class LocationModelForm(forms.ModelForm):
    latitude = forms.FloatField(
        label=_("Latitude"), required=False, help_text=LATITUDE_DEFINITION
    )
    longitude = forms.FloatField(
        label=_("Longitude"), required=False, help_text=LONGITUDE_DEFINITION
    )

    class Meta:
        model = Location
        exclude = ["geoposition"]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.instance:
            geoposition = self.instance.get_geoposition()
            if geoposition:
                self.fields["latitude"].initial = 
               geoposition.latitude
                self.fields["longitude"].initial = 
               geoposition.longitude

    def save(self, commit=True):
        cleaned_data = self.cleaned_data
        instance = super().save(commit=False)
        instance.set_geoposition(
            longitude=cleaned_data["longitude"],
            latitude=cleaned_data["latitude"],
        )
        if commit:
            instance.save()
            self.save_m2m()
        return instance

@admin.register(Location)
class LocationAdmin(admin.ModelAdmin):
    form = LocationModelForm
    save_on_top = True
    list_display = ("name", "street_address", "description")
    search_fields = ("name", "street_address", "description")

    def get_fieldsets(self, request, obj=None):
        map_html = render_to_string(
            "admin/locations/includes/map.html",
            {"MAPS_API_KEY": settings.GOOGLE_MAPS_API_KEY},
        )
        fieldsets = [
            (_("Main Data"), {"fields": ("name", "description")}),
            (
                _("Address"),
                {
                    "fields": (
                        "street_address",
                        "street_address2",
                        "postal_code",
                        "city",
                        "country",
                        "latitude",
 "longitude",
                    )
                },
            ),
            (_("Map"), {"description": map_html, "fields": []}),
            (_("Image"), {"fields": ("picture",)}),
        ]
        return fieldsets
```

2.  要创建自定义更改表单模板，请在模板目录中的`admin/locations/location/`下添加一个新的`change_form.html`文件。此模板将从默认的`admin/change_form.html`模板扩展，并将覆盖`extrastyle`和`field_sets`块，如下所示：

```py
{# admin/locations/location/change_form.html #} {% extends "admin/change_form.html" %}
{% load i18n static admin_modify admin_urls %}

{% block extrastyle %}
    {{ block.super }}
    <link rel="stylesheet" type="text/css"
          href="{% static 'site/css/location_map.css' %}" />
{% endblock %}

{% block field_sets %}
    {% for fieldset in adminform %}
        {% include "admin/includes/fieldset.html" %}
    {% endfor %}
    <script src="{% static 'site/js/location_change_form.js' 
     %}"></script>
{% endblock %}
```

3.  然后，我们必须为将插入到`Map`字段集中的地图创建模板，如下所示：

```py
{# admin/locations/includes/map.html #} {% load i18n %}
<div class="form-row map js_map">
    <div class="canvas">
        <!-- THE GMAPS WILL BE INSERTED HERE DYNAMICALLY -->
    </div>
    <ul class="locations js_locations"></ul>
    <div class="btn-group">
        <button type="button"
                class="btn btn-default locate-address  
                 js_locate_address">
            {% trans "Locate address" %}
        </button>
        <button type="button"
                class="btn btn-default remove-geo js_remove_geo">
            {% trans "Remove from map" %}
        </button>
    </div>
</div>
<script src="https://maps-api-ssl.google.com/maps/api/js?key={{ MAPS_API_KEY }}"></script>
```

4.  当然，默认情况下地图不会设置样式。因此，我们需要添加一些 CSS，如下代码所示：

```py
/* site_static/site/css/location_map.css */ .map {
    box-sizing: border-box;
    width: 98%;
}
.map .canvas,
.map ul.locations,
.map .btn-group {
    margin: 1rem 0;
}
.map .canvas {
    border: 1px solid #000;
    box-sizing: padding-box;
    height: 0;
    padding-bottom: calc(9 / 16 * 100%); /* 16:9 aspect ratio */
    width: 100%;
}
.map .canvas:before {
    color: #eee;
    color: rgba(0, 0, 0, 0.1);
    content: "map";
    display: block;
    font-size: 5rem;
    line-height: 5rem;
    margin-top: -25%;
    padding-top: calc(50% - 2.5rem);
    text-align: center;
}
.map ul.locations {
    padding: 0;
}
.map ul.locations li {
    border-bottom: 1px solid #ccc;
    list-style: none;
}
.map ul.locations li:first-child {
    border-top: 1px solid #ccc;
}
.map .btn-group .btn.remove-geo {
    float: right;
}
```

5.  接下来，让我们创建一个`location_change_form.js`JavaScript 文件。我们不想用全局变量污染环境。因此，我们将从闭包开始，以便为变量和函数创建一个私有范围。
    我们将在这个文件中使用 jQuery（因为 jQuery 附带了贡献的管理系统，使之易于跨浏览器），如下所示：

```py
/* site_static/site/js/location_change_form.js */
(function ($, undefined) {
    var gettext = window.gettext || function (val) {
        return val;
    };
    var $map, $foundLocations, $lat, $lng, $street, $street2,
        $city, $country, $postalCode, gMap, gMarker;
    // …this is where all the further JavaScript functions go…
}(django.jQuery));
```

6.  我们将创建 JavaScript 函数并逐一添加到`location_change_form.js`中。`getAddress4search()`函数将从地址字段中收集地址字符串，稍后用于地理编码，如下所示：

```py
function getAddress4search() {
    var sStreetAddress2 = $street2.val();
    if (sStreetAddress2) {
        sStreetAddress2 = " " + sStreetAddress2;
    }

    return [
        $street.val() + sStreetAddress2,
        $city.val(),
        $country.val(),
        $postalCode.val()
    ].join(", ");
}
```

7.  `updateMarker()`函数将采用`latitude`和`longitude`参数，并在地图上绘制或移动标记。它还将使标记可拖动，如下所示：

```py
function updateMarker(lat, lng) {
    var point = new google.maps.LatLng(lat, lng);

    if (!gMarker) {
        gMarker = new google.maps.Marker({
            position: point,
            map: gMap
        });
    }

    gMarker.setPosition(point);
    gMap.panTo(point, 15);
    gMarker.setDraggable(true);

    google.maps.event.addListener(gMarker, "dragend",
        function() {
            var point = gMarker.getPosition();
            updateLatitudeAndLongitude(point.lat(), point.lng());
        }
    );
}
```

8.  前面的 dragend 事件侦听器中引用的`updateLatitudeAndLongitude()`函数接受`latitude`和`longitude`参数，并使用`id_latitude`和`id_longitude`ID 更新字段的值，如下所示：

```py
function updateLatitudeAndLongitude(lat, lng) {
    var precision = 1000000;
    $lat.val(Math.round(lat * precision) / precision);
    $lng.val(Math.round(lng * precision) / precision);
}
```

9.  `autocompleteAddress()`函数从谷歌地图地理编码中获取结果，并将其列在地图下，以便选择正确的结果。如果只有一个结果，则更新地理位置和地址字段，如下所示：

```py
function autocompleteAddress(results) {
    var $item = $('<li/>');
    var $link = $('<a href="#"/>');

    $foundLocations.html("");
    results = results || [];

    if (results.length) {
        results.forEach(function (result, i) {
            $link.clone()
                 .html(result.formatted_address)
                 .click(function (event) {
                     event.preventDefault();
                     updateAddressFields(result
                      .address_components);

                     var point = result.geometry.location;
                     updateLatitudeAndLongitude(
                         point.lat(), point.lng());
                     updateMarker(point.lat(), point.lng());
                     $foundLocations.hide();
                 })
                 .appendTo($item.clone()
                  .appendTo($foundLocations));
        });
        $link.clone()
             .html(gettext("None of the above"))
             .click(function(event) {
                 event.preventDefault();
                 $foundLocations.hide();
             })
             .appendTo($item.clone().appendTo($foundLocations));
        $foundLocations.show();
    } else {
        $foundLocations.hide();
    }
}
```

10.  `updateAddressFields()`函数采用嵌套字典，以地址组件作为参数，并填充所有地址字段，如下所示：

```py
function updateAddressFields(addressComponents) {
    var streetName, streetNumber;
    var typeActions = {
        "locality": function(obj) {
            $city.val(obj.long_name);
        },
        "street_number": function(obj) {
            streetNumber = obj.long_name;
        },
        "route": function(obj) {
            streetName = obj.long_name;
        },
        "postal_code": function(obj) {
            $postalCode.val(obj.long_name);
        },
        "country": function(obj) {
            $country.val(obj.short_name);
        }
    };

    addressComponents.forEach(function(component) {
        var action = typeActions[component.types[0]];
        if (typeof action === "function") {
            action(component);
        }
    });

    if (streetName) {
        var streetAddress = streetName;
        if (streetNumber) {
            streetAddress += " " + streetNumber;
        }
        $street.val(streetAddress);
    }
}
```

11.  最后，我们有一个初始化函数，在加载页面时调用该函数。它将`onclick`事件处理程序附加到按钮上，创建谷歌地图，并在最初标记`latitude`和`longitude`字段中定义的地理位置，如下所示：

```py
$(function(){
    $map = $(".map");

    $foundLocations = $map.find("ul.js_locations").hide();
    $lat = $("#id_latitude");
    $lng = $("#id_longitude");
    $street = $("#id_street_address");
    $street2 = $("#id_street_address2");
    $city = $("#id_city");
    $country = $("#id_country");
    $postalCode = $("#id_postal_code");

    $map.find("button.js_locate_address")
        .click(function(event) {
            var geocoder = new google.maps.Geocoder();
            geocoder.geocode(
                {address: getAddress4search()},
                function (results, status) {
                    if (status === google.maps.GeocoderStatus.OK) {
                        autocompleteAddress(results);
                    } else {
                        autocompleteAddress(false);
                    }
                }
            );
        });

    $map.find("button.js_remove_geo")
        .click(function() {
            $lat.val("");
            $lng.val("");
            gMarker.setMap(null);
            gMarker = null;
        });

    gMap = new google.maps.Map($map.find(".canvas").get(0), {
        scrollwheel: false,
        zoom: 16,
        center: new google.maps.LatLng(51.511214, -0.119824),
        disableDoubleClickZoom: true
    });

    google.maps.event.addListener(gMap, "dblclick", function(event) 
    {
        var lat = event.latLng.lat();
        var lng = event.latLng.lng();
        updateLatitudeAndLongitude(lat, lng);
        updateMarker(lat, lng);
    });

    if ($lat.val() && $lng.val()) {
        updateMarker($lat.val(), $lng.val());
    }
});
```

# 它是如何工作的。。。

如果在浏览器中查看“更改位置”表单，您将看到字段集中显示的地图，后面是包含地址字段的字段集，如以下屏幕截图所示：

![](img/7d71d3a9-f2a1-4a60-bec1-13d786f860b4.png)

在地图下，有两个按钮：定位地址和从地图中删除。

单击“定位地址”按钮时，将调用地理编码以搜索输入地址的地理坐标。执行地理编码的结果是以嵌套字典格式列出一个或多个地址。我们将这些地址表示为可点击链接列表，如下所示：

![](img/7c5cc0dc-642e-4cf2-abce-03d0fde80113.png)

要在开发者工具的控制台中查看嵌套字典的结构，请在`autocompleteAddress()`函数的开头放置以下行：

```py
console.log(JSON.stringify(results, null, 4));
```

单击其中一个选项时，标记将显示在地图上，显示该位置的确切地理位置。纬度和经度字段将按如下方式填写：

![](img/f5e23aa4-d2ee-4a07-849c-109c29a007e1.png)

然后，管理员可以通过拖放来移动地图上的标记。此外，双击地图上的任意位置将更新地理坐标和标记位置。

最后，如果单击“从地图中删除”按钮，将清除地理坐标并删除标记。

管理使用一个自定义的`LocationModelForm`，它排除`geoposition`字段，添加`Latitude`和`Longitude`字段，并处理保存和加载它们的值。

# 另见

*   [第 4 章](04.html)*，模板和 JavaScript*